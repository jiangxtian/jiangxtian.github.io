[{"title":"MyBatis","url":"/2023/04/06/MyBatis/","content":"# MyBatis\n\n## 什么是Mybatis?\n\n![](https://pic.imgdb.cn/item/642ee5aaa682492fcc64a47b.jpg)\n\n## 数据库连接池\n\n数据库连接池是个容器，负责分配、管理数据库连接(Connection)\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏\n\n\n\n## 删除\n\n```sql\n@Delete(\"delete from emp where id =#{id}\")\npublic void delete(Integer id);\n```\n\n可以在application.properties中，打开mybatisl的日志，并指定输出到控制台。\n#指定mybatis输出日志的位置，输出控制台\nmybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutlmpl\n\n如果mapper接口方法形参只有一个普通类型的参数，料}里面的属性名可以随便写，如：#{id}、#{value}。\n\n![](https://pic.imgdb.cn/item/642f8d75a682492fccfaa2ac.jpg)\n\n#### 预编译SQl\n\n- 性能更高\n- 更安全（防止SQL注入）\n\nSQL注入\nSQL注入是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。\n\n#### 参数占位符\n\n![](https://pic.imgdb.cn/item/642f8fdca682492fccfe0beb.jpg)\n\n![](https://pic.imgdb.cn/item/642f91a6a682492fcc01236f.jpg)\n\n![](https://pic.imgdb.cn/item/642f91c1a682492fcc013ea5.jpg)\n\n #### 新建\n\n![](https://pic.imgdb.cn/item/642f9944a682492fcc088e7b.jpg)\n\n#### 新增（主键返回）\n\n描述：在数据添加成功后，需要获取插入数据库数据的主键。\n如：添加套餐数据时，还需要维护套餐菜品关系表数据。\n\n![](https://pic.imgdb.cn/item/642f9b5ca682492fcc0a59e6.jpg)\n\n```java\n@Options(keyProperty = \"id\",useGeneratedKeys = true)\n@Insert(\"insert into emp ( username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \" +\n        \"values(#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime})\")\npublic int insert(Emp emp);\n```\n\n### 更新\n\n```java\n// 更新\n@Update(\"UPDATE emp SET username =#{username},gender =#{gender},name = #{name},image= #{image},gender = #{gender}, job = #{job},entrydate= #{entrydate},dept_id = #{deptId},update_time = #{updateTime} where id = #{id}\")\npublic void update(Emp emp);\n```\n\n### 查询\n\n```java\n // 查询\n@Select(\"select * from emp where id = #{id}\")\npublic Emp getId( Integer id);\n```\n\n### 数据封装\n\n实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。\n如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。\n\n![](https://pic.imgdb.cn/item/642fa739a682492fcc185ede.jpg) \n\n```java\n// 方案一\n/*@Select(\"select id, username, password, name, gender, image, job, \" +\n        \"entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id}\")\npublic Emp getId(Integer id);*/\n\n\n// 方案二\n/*@Results({\n        @Result(column = \"dept_id\", property = \"deptId\"),\n        @Result(column = \"create_time\", property = \"createTime\"),\n        @Result(column = \"update_time\", property = \"updateTime\")\n})\n@Select(\"select * from emp where id = #{id}\")\npublic Emp getId(Integer id);*/\n\n///方案三：开启Mybatis的驼峰命名自动映射开关---a_column ------aColumn\n\n@Select(\"select * from emp where id = #{id}\")\npublic Emp getId( Integer id);\n```\n\n### 条件查询\n\n![](https://pic.imgdb.cn/item/642fb397a682492fcc27c306.jpg)\n\n#### 使用concat()\n\n```java\n // 条件查询\n    @Select(\"select * from emp where emp.name like concat('%',#{name},'%')and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc\")\n    public List<Emp> list(String name , short gender, LocalDate begin, LocalDate end);\n}\n```\n\n### 参数名说明\n\n![](https://pic.imgdb.cn/item/642fb469a682492fcc28c18c.jpg)\n\n## XML映射文件\n\n### 规范\n\n- XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。\n- XML映射文件的namespace.属性为Mapper接口全限定名一致。\n- XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。\n\n> 使用Mybatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。\n\n resultType:单条记录所封装的类型\n\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.springboot_mybatis_demo1.mapper.EmpMapper\">\n    <!--    resultType:单条记录所封装的类型-->\n    <select id=\"list\" resultType=\"com.springboot_mybatis_demo1.PoJo.Emp\">\n        select * from emp where emp.name like concat('%',#{name},'%')and gender = #{gender} and entrydate between\n        #{begin} and #{end} order by update_time desc\n    </select>\n\n</mapper>\n```\n\n## 动态SQL\n\n<if>:用于判断条件是否成立。使用test属性进行条件判断，如果条件为true,则拼接SQL。\n\n<where>:where元素只会在子元素有内容的情况下才插入where子句。而且会自动去除子句的开头的AND或OR。\n\n<set> 动态地在行首插入SET关键字，并会删掉额外的逗号。（用在update语句中）\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.springboot_mybatis_demo1.mapper.EmpMapper\">\n    <!--    resultType:单条记录所封装的类型-->\n    <select id=\"list\" resultType=\"com.springboot_mybatis_demo1.PoJo.Emp\">\n        select *\n        from emp\n        <where>\n            <if test=\"name != null\">\n                emp.name like concat('%', #{name}, '%')\n            </if>\n            <if test=\"gender != null\">\n                and gender = #{gender}\n            </if>\n            <if test=\"begin != null and end != null\">\n                and entrydate between #{begin} and #{end}\n            </if>\n        </where>\n        order by update_time desc\n\n    </select>\n\n</mapper>\n```\n\n\n\n动态更新员工信息，如果更新时传递有值，则更新；如果更新时没有传递值，则不更新。 \t\n\n```xml\n<update id=\"update\">\n    UPDATE emp\n    <set>\n    <if test=\"username != null\">\n        username =#{username},\n    </if>\n    <if test=\"gender != null\">\n        gender =#{gender},\n    </if>\n    <if test=\"name != null\">\n        name = #{name},\n    </if>\n    <if test=\"image != null\">\n        image= #{image},\n    </if>\n    <if test=\"job != null\">\n        job = #{job},\n    </if>\n    <if test=\"entrydate != null\">\n        entrydate= #{entrydate},\n    </if>\n    <if test=\"deptId != null\">\n        dept_id = #{deptId},\n    </if>\n    <if test=\"updateTime != null\">\n        update_time = #{updateTime}\n    </if>\n    </set>\n    where id = #{id}\n</update>\n```\n\n### foreach标签\n\n属性值：\n\n- collection:遍历的集合\n- item:遍历出来的元素\n- separator:分隔符\n- open:遍历开始前拼接的SQL片段\n- close:遍历结束后拼接的SQ工片段\n\n```xml\n<delete id=\"deleteIds\">\n    delete from emp where id in\n    <foreach collection=\"ids\" item=\"id\" separator=\",\" open=\"(\" close=\")\">\n        #{id}\n    </foreach>\n\n</delete>\n```\n\n<sql>:定义可重用的SQL片段。\n<include>:通过属性refid,指定包含的sql片段。\n\n```sql\n<sql id=\"aa\">\n    select id, username, password, name, gender, image from emp\n\n</sql>\n<select id=\"search\" resultType=\"java.lang.String\">\n    <include refid=\"aa\"></include>\n    where id = 2\n</select>\n```\n\n\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","javaWeb"]},{"title":"MySql","url":"/2023/04/05/MySql/","content":"# MySql\n\n## SQL简介\n\nSQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n\n- SQL语句可以单行或多行书写，以分号结尾。\n- SQL语句可以使用空格/缩进来增强语句的可读性。\n- MySQL数据库的SQL语句不区分大小写。\n- 注释：\n  1. 单行注释：-炷释内容或#注释内容(MySQL特有)\n  2. 多行注释：/*注释内容*/\n\n## DDL\n\nDDL英文全称是Data Definition Language,数据定义语言，用来定义数据库对象（数据库、表）。\n\n```sql\n查询所有数据库：show databases;\n查询当前数据库：select database0;\n创建数据库：create database[if not exists]数据库名；\n使用数据库：use数据库名；\n删除数据库：drop database[if exists]数据库名；\n注意事项\n上述语法中的database,也可以替换成schema。如：create schema db01;\n\n-- 创建\ncreate table表名(\n字段1字段类型[约束][comment字段1注释]，\n字段n字段类型[约束][comment字段n注释]\n)[comment表注释]；\n\n-- 约束\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n目的：保证数据库中数据的正确性、有效性和完整性。\n\n\n```\n\n### 约束\n\n| 约束     | 描述                                             | 关键字      |\n| -------- | ------------------------------------------------ | ----------- |\n| 非空约束 | 限制该字段值不能为null                           | not null    |\n| 唯一约束 | 保证字段的所有数据都是唯一、不重复的             | unique      |\n| 主键约束 | 主键是一行数据的唯一标识，要求非空且唯一         | primary key |\n| 默认约束 | 保存数据时，如果未指定该字段值，则采用默认值     | default     |\n| 外键约枣 | 让两张表的数据建立连接，保证数据的一致性和完整性 | foreign key |\n\n```SQL\n-- 创建表\ncreate table tb_user(\n    id int comment 'ID ，唯一标识',\n    username varchar(20) comment  '用户名',\n    name varchar(10) comment '姓名',\n    age int comment '年龄',\n    gender char(1) comment '性别'\n)comment '用户表';\n\n-- 创建约束\ncreate table tb_user(\n    id int primary key comment 'ID ，唯一标识',\n    username varchar(20) not null unique comment  '用户名',\n    name varchar(10) not null comment '姓名',\n    age int comment '年龄',\n    gender char(1) default '男' comment '性别'\n)comment '用户表';\n\n-- 自增auto_increment\ncreate table tb_user(\n    id int primary key auto_increment comment 'ID ，唯一标识',\n    username varchar(20) not null unique comment  '用户名',\n    name varchar(10) not null comment '姓名',\n    age int comment '年龄',\n    gender char(1) default '男' comment '性别'\n)comment '用户表';\n```\n\n### DDL表操作\n\n- 查询当前数据库所有表：show tables;\n- 查询表结构：desc表名；\n- 查询建表语句：show create table表名；\n\n```SQL\n--\nDDL:修改表结构\n--\n修改：为表tb emp添加字段gq varchar(1l)】\nalter table tb emp add gq varchar(11)comment 'QQ';\n--修改：修改tb emp字段类型gg varchar(l3)\nalter table tb_emp modify qq num varchar(13)comment 'QQ'\n--修攻：修改tb emp字段名qg为gg num varchar(13)\nalter table tb_emp change qq num qq num varchar(13)comment 'QQ';\n--修改：刚除tb emp的gq num字段\nalter table tb emp drop column gq num;\n修改：将tb emp表名修改为emp\nrename table tb emp to emp;\n删除表：drop table[if exists]表名；\n```\n\n\n\n## DML\n\n> DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\n\n### insert语法\n\n- 指定字段添加数据：insert into表名（字段名1，字段名2）values(值1，值2)；\n- 全部字段添加数据：insert into表名values(值1，值2，…)；\n- 批量添加数据（指定字段）：insert into表名（字段名1，字段名2）values(值1，值2)，（值1，值2）；\n- 批量添加数据（全部字段）：insert into表名values(值1，值2，…)，（值1，值2，…）；\n\n#### 注意事项\n\n- 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n- 字符串和日期型数据应该包含在引号中。\n- 插入的数据大小，应该在字段的规定范围内。\n\n### update\n\n- 修改数据：update表名set字段名1=值1，字段名2=值2，.[where条件]；\n- 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\n\n### delete\n\n- 删除数据：delete from表名[where条件]；\n\n#### 注意事项\n\n- DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\n- DELETE语句不能删除某一个字段的值（如果要操作，可以使用UPDATE,将该字段的值置为NULL)。\n\n## DQL\n\nDQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。\n\n关键字：SELECT\n\n![](https://pic.imgdb.cn/item/642d83c1a682492fcc9edb5a.jpg)\n\n#### 基本查询\n\n- 查询多个字段：select字段1，字段2，字段3 from表名；\n- 查询所有字段（通配符）：select * from表 名；\n- 设置别名：select 字段1[as别名1]，字段2[as别名2] from 表名；\n- 去除重复记录：select distinct 字段列表 from 表名；\n\n```sql\n-- 查询指定字段name,entrydate并返回\n select name,entrydate from tb_emp;\n\n-- 2,查询返回所有字段\n-- 不推荐（不直观、性能低）\nselect * from tb_emp;\n\n-- 推荐\nselect id, username, password, name, gender, image, job, entrydate, create_time, update_time from tb_emp;\n\n-- 3.查询所有员工的name,entrydate,并起别名（姓名、入职日期）\nselect name as '姓名' , entrydate as '入职日期' from tb_emp;\n\n-- 4.查询已有的员工关联了哪几种职位（不要重复）\nselect distinct job from tb_emp;\n```\n\n#### 条件查询\n\n条件查询：select字段列表from表名where条件列表；\n\n| 比较运算符    | 功能                                       |\n| ------------- | ------------------------------------------ |\n| >             | 大于                                       |\n| >=            | 大于等于                                   |\n| <             | 小于                                       |\n| <=            | 小于等于                                   |\n| =             | 等于                                       |\n| <>或！=       | 不等于                                     |\n| between ..and | 在某个范围之内（含最小、最大值）           |\n| in(...)       | 在in之后的列表中的值，多选一               |\n| like  占位符  | 模糊匹配（_匹配单个字符，%匹配任意个字符） |\n| is null       | 是nu11                                     |\n\n| 逻辑运算符 | 功能                         |\n| ---------- | ---------------------------- |\n| and或&&    | 并且（多个条件同时成立）     |\n| or或\\|\\|   | 或者（多个条件任意一个成立） |\n| not或！    | 非，不是\n‘                    |\n\n```sql\n-- 条件查询\n\n-- 1.查询继到为杨道的员工\nselect * from tb_emp where name = '杨逍';\n\n-- 2.查询id小于等于5的员工信息\nselect *from tb_emp where id <= 5;\n-- 3.查询没有分配职位的员工信息\n\nselect * from tb_emp where  job is null;\n\n-- 4.查询有职位的员工信息\n\nselect * from tb_emp where  job is not null;\n\n-- 5.查询密码不等于'123456'的员工信息\n\nselect * from tb_emp where password != '123456';\nselect * from tb_emp where password <> '123456';\n-- 6.查询入职日期在'2000-01-01'（包含)到'2010-01-01'（包含）之间的员工信息\nselect * from tb_emp where entrydate >= '2000-01-01' and entrydate <= '2010-01-01';\n\nselect * from tb_emp where entrydate between '2000-01-01' and '2010-01-01';\n-- 7.查询入职时间在'2000-01-01'（包含）到'2010-01-01'（包含）之间且性别为女的员工信息\nselect * from tb_emp where entrydate between '2000-01-01' and '2010-01-01' and gender = 2;\nselect * from tb_emp where entrydate between '2000-01-01' and '2010-01-01' && gender = 2;\n-- 8.查询职位是2（讲师），3（学工主管），4（教研主管）的员工信息\n\nselect * from tb_emp where job = 2 or job = 3 or job =4;\nselect * from tb_emp where job in (2,3,4);\n-- 9.查询姓名为两个字的员工信息\nselect * from tb_emp where name like '__';\n-- 10.查询姓'张'的员工信息\n\nselect * from tb_emp where name like '张%';\n```\n\n#### 聚合函数\n\n介绍：将一列数据作为一个整体，进行纵向计算。\n语法：select聚合函数（字段列表）from表名；\n\n| 函数  | 功能     |\n| ----- | -------- |\n| count | 统计数量 |\n| max   | 最大值   |\n| min   | 最小值   |\n| avg   | 平均值   |\n| sum   | 求和     |\n\n```sql\n-- 聚合函数   --- 不对NULL值进行运算\n\n-- 1.统计该企业员工数量  --- count\n-- A.count(字段)\nselect count(id) from tb_emp;\n\n-- B.count(常量)\nselect count(1) from tb_emp;\nselect count('a') from tb_emp;\n\n-- C.count(*)  -- 推荐，底层有优化\nselect count(*) from tb_emp;\n\n-- 2.统计该企业最早入职的员工 -- min\n\nselect min(entrydate) from tb_emp;\n\n-- 3.统计该企业最迟入职的员工   -max\n\nselect max(entrydate) from tb_emp;\n\n-- 4.统计该企业员工TD的平均值 -- avg\n\nselect avg(id) from tb_emp;\n\n-- 5.统计该企业员工的ID之和  --sum\n\nselect sum(id) from tb_emp;\n```\n\n\n\n#### 分组查询\n\n分组查询：select字段列表from表名[where条件]group by分组字段名[having分组后过滤条件]；\n\n**分组查询返回的字段主要包含两类，一类是聚合函数，另一个是返回分组字段**\n\n##### where与having区别\n\n1. 执行时机不同：Where.是分组之前进行过滤，不满足where条件，不参与分组；而having:是分组之后对结果进行过滤。\n2. 判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n##### 注意事项\n- 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n- 执行顺序：where>聚合函数>having。\n\n#### 排序查询\n\n●条件查询：select字段列表from表名[where条件列表] [group by分组字段]  order by字段1排序方式1，字段2排序方式2.；\n\nASC:升序（默认值）\nDESC:降序\n\n##### 注意事项\n\n如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。\n\n```sql\n-- 排序查询\n\n-- 1,根据入职时间，对员工进行升序排序\nselect  * from tb_emp order by entrydate;\n\n-- 2.根据入职时间，对员工进行降序排序\nselect  * from tb_emp order by entrydate desc ;\n\n-- 3.根据入职时间对公司的员工进行升序排序,如果入职时间相同，再按照更新时间进行降序排序\n\nselect  * from tb_emp order by entrydate ,update_time desc ;\n```\n\n #### 分页查询\n\n分页查询：select字段列表from表名limit起始索引，查询记录数；\n\n##### 注意事项\n\n1. 起始索引从0开始，起始索引=（查询页码-1)*每页显示记录数。\n2. 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。\n3. 如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。\n\n```sql\n-- 分页查询\n\n-- 1.从起始素引0开始查询负工数据，每页展示5条记录\nselect * from tb_emp limit 0,5;\n\n-- 2.查询第1页员工数据，每页展示5条记录\nselect * from tb_emp limit 0,5;\n-- 3.查询第2页员工数据，每页展示5条记录\nselect * from tb_emp limit 5,5;\n-- 4.查询第3页员工数据，每页展示5条记录\nselect * from tb_emp limit 10,5;\n\n-- 起始索引=（页码 -1）*每页展示记录数\n```\n\n#### 案例\n\n```sql\n-- 案例2-1：根据需求，完成员工性别信息的统计-count(*)\n-- if(条件表达式，true取值，false取值)\nselect gender, count(*)\nfrom tb_emp\ngroup by gender;\nselect if(gender = 1, '男性', '女性') as '性别', count(*)\nfrom tb_emp\ngroup by gender;\n\n-- 案例2-2：根据需求，完成员工职位信息的统计\n-- case表达式 when 值1 then 结果1 when 值2 then 结果2 when 值3 then 结果3.....else....end\nselect (case job when 1 then '班主任' when 2 then '讲师' when 3 then '学工主管' when 4 then '教研主管' else '未分配职位' end)\n    as '员工职位'\n     , count(*)\nfrom tb_emp\ngroup by job;\n```\n\n#### 总结\n\n![](https://pic.imgdb.cn/item/642e5dc6a682492fcca50113.jpg)\n\n\n\n## 多表设计\n\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间\n相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\n\n- 一对多（多对一）\n- 多对多\n- 一对一\n\n### 一对多\n\n### 外键语法\n\n\n\n```sql\n--\n创建表时指定\ncreate table表名(\n字段名数据类型，\n[constraint][外键名称]foreign key(外键字段名)references主表（字段名）\n):\n-建完表后，添加外键\nalter table表名add constraint外键名称foreign key(外键字段名)references主表（字段名）；\n```\n\n##### 物理外键\n\n- 概念：使用foreign key定义外键关联另外一张表。\n- 缺点：\n  - 影响增、删、改的效率(需要检查外键关系)。\n  - 仅用于单节点数据库，不适用与分布式、集群场景。\n  - 容易引发数据库的死锁问题，消耗性能。\n\n##### 逻辑外键\n\n- 概念：在业务层逻辑中，解决外键关联。\n- 通过逻辑外键，就可以很方便的解决上述问题。\n\n> 在现实开发中已经很少使用物理外键，甚至有的已经明文禁止使用物理外键\n\n### 一对一\n\n案例：用户与身份证信息的关系\n关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率\n\n实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\n\n\n\n![](https://pic.imgdb.cn/item/642e655ba682492fccaf93bf.jpg)\n\n### 多对多\n\n案例：学生与课程的关系\n关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n\n![](https://pic.imgdb.cn/item/642e65e0a682492fccb04c03.jpg)\n\n### 小结\n\n1. 一对多\n   在多的一方添加外键，关联另外一方的主键。\n2.  一对一\n   任意一方，添加外键，关联另外一方的主键。\n3. 多对多\n   通过中间表来维护，中间表的两个外键，分别关联另外两张表的主键。\n\n## 多表查询\n\n- 连接查询\n\n  - 内连接：相当于查询A、B交集部分数据\n\n  - 外连接\n    - 左外连接：查询左表所有数据（包括两张表交集部分数据）\n    - 右外连接：查询右表所有数据（包括两张表交集部分数据）\n\n- 子查询\n\n隐式内连接：select 字段列表 from表1，表2  where 条件..；\n显式内连接：select 字段列表 from 表1 [inner] join表2 on连接条件..\n\n```sql\n-- 内连接\n-- A.查询员工的姓名，及所属的部门名称（隐式内连接实现）\n\nselect tb_dept.name,tb_emp.name from tb_emp,tb_dept where tb_dept.id = tb_emp.dept_id;\n-- 起别名\nselect e.name,d.name from tb_emp e, tb_dept d where e.dept_id =  d.id;\n\n-- B.查询员工的姓名，及所属的部门名称（显式内连接实现）\n\nselect tb_dept.name,tb_emp.name from tb_dept inner join tb_emp on tb_dept.id = tb_emp.dept_id;\n```\n\n#### 外连接\n\n左外连接：select字段列表 from表1 left[outer]join 表2 on连接条件\n右外连接：select字段列表 from表1 right[outer]join 表2 on连接条件\n\n```sql\n-- 左外连接\n-- 1.查询员工表所有员工的姓名，和对应的部门名称（左外连接）\nselect tb_emp.name,tb_dept.name from tb_emp left join tb_dept on tb_dept.id = tb_emp.dept_id;\n\n-- 右外连接\n-- 查询部门表所有部门的名称，和对应的员工名称（右外连接）\nselect tb_emp.name,tb_dept.name from tb_emp right join tb_dept on tb_dept.id = tb_emp.dept_id;\nselect tb_emp.name,tb_dept.name from tb_dept left join tb_emp on tb_dept.id = tb_emp.dept_id;\n```\n\n#### 子查询\n\n介绍：SQL语句中嵌套select语句，称为嵌套查询，又称子查询。\n形式：select*from t1 where column1=（select column1 from t.2..)；\n子查询外部的语句可以是insert/update/delete/select的任何一个，最常见的是select。\n\n\n\n##### 分类\n\n标量子查询：子查询返回的结果为单个值\n\n- 子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式\n- 常用的操作符：=  <>   >    >=    <     <=\n\n```sql\n-- 标量子查询\n-- A.查询\"教研部”的所有员工信息\n\n-- a.查询教研部的ID\nselect id from tb_dept where tb_dept.name = '教研部';\n-- b. 在查询教研部下的员工\nselect * from tb_emp where tb_emp.dept_id = 2;\n\nselect * from tb_emp where tb_emp.dept_id = (select id from tb_dept where tb_dept.name = '教研部');\n-- B.查询在\"方东白”入职之后的员工信息\nselect entrydate from tb_emp where  name = '方东白';\nselect * from tb_emp where entrydate >(select entrydate from tb_emp where  name = '方东白');\n```\n\n列子查询：子查询返回的结果为一列\n\n```sql\n-- 列子查询\n-- A.查询\"教研部”和\"咨询部”的所有员工信息工\n-- 1. 查询\"教研部”和\"咨询部” 的部门ID\nselect id from tb_dept where name = '教研部' or name = '咨询部';\n\n\n-- 2.根据部门ID,查询该部T门下的员工信息-tb emp\nselect * from tb_emp where dept_id = 2 or dept_id = 3;\nselect * from tb_emp where dept_id in (select id from tb_dept where name = '教研部' or name = '咨询部');\n```\n\n行子查询：子查询返回的结果为一行\n\n```sql\n-- 行子查询\n-- 查询与\"韦一笑”的入职日期及职位都相同的员工信息：\nselect entrydate,job from tb_emp where name = '韦一笑';\nselect * from tb_emp where entrydate = (select entrydate from tb_emp where name = '韦一笑') and job =(select job from tb_emp where name = '韦一笑');\nselect * from tb_emp where (entrydate,job)=(select entrydate,job from tb_emp where name = '韦一笑');\n```\n\n表子查询：子查询返回的结果为多行多列\n\n子查询返回的结果是行多列，常作为临时表\n\n```sql\n-- 表子查询\n-- A.查询入职日期是\"2006-01-01\"之后的员工信息，及其部门名称\n\n-- a.查询入职日期是\"2006-01-01\"之后的员工信息\n\nselect * from tb_emp where entrydate > '2006-01-01';\n-- b.查询这部分员工信息及其部门名称\n\nselect e.*,d.name from (select * from tb_emp where entrydate > '2006-01-01') e,tb_dept d where e.dept_id = d.id;\n```\n\n### 案例\n\n```sql\n-- 1.查询价格低于10元的菜品的名称、价格及其菜品的分类名称\n\nselect d.name, d.price, s.name\nfrom dish d,\n     category s\nwhere d.price < 10\n  and d.category_id = s.id;\n\n-- 2.查询所有价格在10元（含）到50元（含）之间且状态为\"起售\"的菜品名称、价格及其分类名称(即使菜品没有分类，也需要将菜品查询出来)\nselect d.name, c.name\nfrom dish d\n         left join category c on d.category_id = c.id\nwhere d.price between 10 and 50\n  and d.status = 1;\n-- 3.查询每个分类下最贵的菜品，展示出分类的名称、最贵的菜品的价格.\nselect c.name, max(d.price)\nfrom category c,\n     dish d\nwhere d.category_id = c.id\ngroup by c.name;\n-- 4.查询各个分类下菜品状态为\"起售\"，并且该分类下菜品总数量大于等于3的分类名称\nselect c.name, count(*)\nfrom category c,\n     dish d\nwhere d.category_id = c.id\n  and d.status = 1\ngroup by c.name\nhaving count(*) >= 3;\n-- 5.查询出\"商务套餐八\"中包含了哪些菜品（展示出套餐名称、价格，包含的菜品名称、价格、份数\nselect s.name, s.price, d.name, d.price, sd.copies\nfrom setmeal s,\n     setmeal_dish sd,\n     dish d\nwhere s.id = sd.setmeal_id\n  and sd.dish_id = d.id\n  and s.name = '商务套餐A';\n-- 6.查询出低于菜品平均价格的菜品信息（展示出菜品名称、菜品价格）\nselect avg(price) from dish ;\nselect d.name,d.price from dish d where price<(select avg(price) from dish);\n```\n\n### 总结\n\n![](https://pic.imgdb.cn/item/642ed70ba682492fcc4b8e0d.jpg)\n\n## 事务\n\n> 事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n\n开启事务：start transaction;/begin;\n提交事务：commit;\n回滚事务：rollback;\n\n#### 四大特性\n\n原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败\n\n一致性：事务完成时，必须使所有的数据都保持一致状态\n\n隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n\n持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n\n#### 总结\n\n1. 事务介绍\n   - 组操作的集合，这组操作要么全部成功，要么全部失败。\n2. 事务操作\n   - start transaction /begin\n   - commit\n   - rollback\n3. 事务四大特性\n   - 原子性\n   - 一致性\n   - 隔离性\n   - 持久性\n\n\n\n## 索引\n\n索引(index)是帮助数据库高效获取数据的数据结构\n\n- 优点\n\n  > 提高数据查询的效率，降低数据库的1O成本。\n  > 通过索引列对数据进行排序，降低数据排序的成本，\n  > 降低CPU消耗。\n\n- 缺点\n\n  > 索引会占用存储空间。\n  > 索引大大提高了查询效率，同时却也降低了insert、\n  > update、delete的效率。\n\n#### 结构\n\nMySQL数据库中默认的索引结构是B+tree。\n\n#### 语法\n\n创建索引\ncreate[unique]index索引名on表名（字段名，）；\n查看索引\nshow index from表名；\n删除索引\ndrop index索引名on表名；\n\n#### 注意事项\n主键字段，在建表时，会自动创建主键索引。\n添加唯一约束时，数据库实际上会添加唯一索引\n\n主键索引是性能是最高的\n","tags":["Java","Java个人总结"],"categories":["程序猿","javaWeb"]},{"title":"springboot基础","url":"/2023/04/05/springboot/","content":"# springboot基础\n\n# 请求\n\n\n\n1. 原始方式获取请求参数\n   - Controller方法形参中声明HttpServletRequest对象\n   - 调用对象的getParameter(参数名)\n2. SpringBoot中接收简单参数\n   - 请求参数名与方法形参变量名相同\n   - 会自动进行类型转换\n3. @RequestParam注解\n   - 方法形参名称与请求参数名称不匹配，通过该注解完成映射\n   - 该注解的required属性默认是true,代表请求参数必须传递\n\n```java\n// 原始方法\n/*@RequestMapping(\"/simpleParam\")\npublic String simpleParam(HttpServletRequest request){\n    String name = request.getParameter(\"name\");\n    int  age = Integer.parseInt(request.getParameter(\"age\"));\n    System.out.println(\"姓名：\"+name+\"age\"+age);\n    return \"ok\";\n}*/\n// 基于springboot\n/*@RequestMapping(\"/simpleParam\")\npublic String simpleParams(String name ,int age ){\n    System.out.println(name+\":\"+age);\n    return \"ok\";\n\n}*/\n\n// 请求参数不匹配的情况下需要@RequestParam(),参数required默认是true，为true时客户端必须传递此参数\n/*@RequestMapping(\"/simpleParam\")\npublic  String simpleParam(@RequestParam(name = \"name\",required = false) String username , int age ){\n    System.out.println(username+\":\"+age);\n    return \"ok\";\n}*/\n```\n\n## 实体对象参数\n\n规则：请求参数名与形参对象属性名相同，即可直接通过PoJo接收\n\n```java\n// 简单实体参数\n/*@RequestMapping(\"/simpleParam\")\npublic String simplePoJo(User user){\n    System.out.println(user);\n    return \"ok\";\n}*/\n\n// 复杂实体参数\n@RequestMapping(\"/complexPoJo\")\npublic String complexPoJo(User user){\n    System.out.println(user);\n    return \"ok\";\n```\n\n```java\npackage com.zandj.springbootdemo01.PoJo;\n\npublic class User {\n    private String name;\n    private int age;\n    private Address address;\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    public User() {\n    }\n\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", address=\" + address +\n                '}';\n    }\n}\n```\n\n```java\npackage com.zandj.springbootdemo01.PoJo;\n\npublic class Address {\n    private String province;\n    private String city;\n\n    public Address() {\n    }\n\n    public Address(String province, String city) {\n        this.province = province;\n        this.city = city;\n    }\n\n    /**\n     * 获取\n     * @return province\n     */\n    public String getProvince() {\n        return province;\n    }\n\n    /**\n     * 设置\n     * @param province\n     */\n    public void setProvince(String province) {\n        this.province = province;\n    }\n\n    /**\n     * 获取\n     * @return city\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * 设置\n     * @param city\n     */\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    public String toString() {\n        return \"Address{province = \" + province + \", city = \" + city + \"}\";\n    }\n}\n```\n\n## 数组集合参数\n\n- 数组参数\n\n  > 数组：请求参数名与形参中数组变量名相同，可以直接使用数组封装\n\n```java\n// 数组参数\n@RequestMapping(\"/arrayParam\")\npublic String arrayParam(String[] hobby) {\n    System.out.println(Arrays.toString(hobby));\n    return \"ok\";\n}\n```\n\n- 集合参数\n\n  > 集合参数：请求参数名与形参集合名称相同且请求参数为多个，@RequestParam绑定参数关系\n\n```java\n// 集合参数\n@RequestMapping(\"/listParam\")\npublic String listParam(@RequestParam List<String> hobby) {\n    System.out.println(hobby.toString());\n    return \"ok\";\n}\n```\n\n## 日期参数\n\n> 日期参数：使用@DateTimeFormat注解完成日期参数格式转换\n\n```java\n// 日期参数\n@RequestMapping(\"/dateParam\")\npublic String dateParam(@DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") LocalDateTime time){\n    System.out.println(time);\n    return \"ok\";\n}\n```\n\n## json格式参数\n\n- JSON参数：JSON数据键名与形参对象属性名相同，定义POO类型形参即可接收参数，需要使用@RequestBody标识\n\n```java\n// json参数\n@RequestMapping(\"/jsonParam\")\npublic String jsonParam(@RequestBody User user){\n    System.out.println(user);\n    return \"OK\";\n}\n```\n\n## 路径参数\n\n路径参数：通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数\n\n- 单个参数\n\n```java\n// 路径参数\n@RequestMapping(\"/path/{id}\")\npublic String jsonParam(@PathVariable Integer id){\n    System.out.println(id);\n    return \"OK\";\n}\n```\n\n- 多个路径参数\n\n```java\n@RequestMapping(\"/path/{id}/{name}\")\npublic String jsonParam(@PathVariable Integer id,  @PathVariable String name){\n    System.out.println(id+\":\"+name);\n    return \"OK\";\n}\n```\n\n## 参数传递总结\n\n![](https://pic.imgdb.cn/item/642d0985a682492fcccf3d68.jpg)\n\n# 响应\n\n## @ResponseBody\n\n- 类型：方法注解、类注解\n- 位置：Controller方法上/类上\n- 作用：将方法返回值直接响应，如果返回值类型是实体对象/集合，将会转换为SON格式响应\n- 说明：@RestController=@Controller+@ResponseBody;\n\n### 对响应结果统一封装\n\n\n\n```java\npackage com.zandj.PoJo;\n\n/**\n * 统一响应结果封装类\n */\npublic class Result {\n    private Integer code ;//1 成功 , 0 失败\n    private String msg; //提示信息\n    private Object data; //数据 data\n\n    public Result() {\n    }\n    public Result(Integer code, String msg, Object data) {\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    }\n    public Integer getCode() {\n        return code;\n    }\n    public void setCode(Integer code) {\n        this.code = code;\n    }\n    public String getMsg() {\n        return msg;\n    }\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n    public Object getData() {\n        return data;\n    }\n    public void setData(Object data) {\n        this.data = data;\n    }\n\n    public static Result success(Object data){\n        return new Result(1, \"success\", data);\n    }\n    public static Result success(){\n        return new Result(1, \"success\", null);\n    }\n    public static Result error(String msg){\n        return new Result(0, msg, null);\n    }\n\n    @Override\n    public String toString() {\n        return \"Result{\" +\n                \"code=\" + code +\n                \", msg='\" + msg + '\\'' +\n                \", data=\" + data +\n                '}';\n    }\n}\n```\n\n## 三层架构\n\n![](https://pic.imgdb.cn/item/642d18c1a682492fcce9c807.jpg)\n\n![](https://pic.imgdb.cn/item/642d18dba682492fccea5eab.jpg)\n\n![](https://pic.imgdb.cn/item/642d1c89a682492fccf26ba2.jpg)\n\n## 分层解耦\n\n- 内聚：软件中各个功能模块内部的功能联系。\n- 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。\n- 软件设计原则：高内聚低耦合。\n\n![](https://pic.imgdb.cn/item/642d234ca682492fccfe600c.jpg)\n\n- 控制反转：Inversion Of Control,简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。\n- 依赖注入：Dependency Injection,简称Dl。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\n- Bean对象：IOC容器中创建、管理的对象，称之为bean。\n\n## IOC详解\n\n### Bean的声明\n\n![](https://pic.imgdb.cn/item/642d2742a682492fcc0b107e.jpg)\n\n> 在对应层打上对应的注解\n>\n> controller层由于已经打上restcontroller注解，该注解在底层已经包含了controller注解，因此在controller层不需要再打注解\n>\n> 在service层要打上@Service注解\n>\n> 当有些类不属于这三层，但还想交给容器管理，可以打上@component注解\n\n- 声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。\n- 使用以上四个注解都可以声明bean,但是在springboot集成web开发中，声明控制器bean只能用@Controller。.\n\n## Bean的组件扫描\n\n- 前面声明bean的四大注解，要想生效，还需要被组件扫描注解@ComponentScan:扫描。\n- @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootApplication\n  中，默认扫描的范围是启动类所在包及其子包。\n\n解决方法\n\n![](https://pic.imgdb.cn/item/642d2a1ba682492fcc0f822b.jpg)\n\n声明当前包是因为新打的注解会覆盖原有的扫描位置，并且这种方法不推荐，还应遵循官方推荐全部项目写在当前包下\n\n## DI细节\n\n### Bean注入\n\n@Autowired注解，默认是按照类型进行，如果存在多个相同类型的bean,将会报出如下错误：\n\n![](https://pic.imgdb.cn/item/642d2b7da682492fcc114f41.jpg)\n\n### 通过以下几种方案来解决：\n@Primary\n@Qualifier\n@Resource\n\n![](https://pic.imgdb.cn/item/642d2c37a682492fcc123c44.jpg)\n\n**引号内为Bean的名字，Bean名字默认是类名**\n\n### 依赖注入的注解\n\n@Autowired:默认按照类型自动装配。\n如果同类型的bean存在多个：\n\n- @Primary\n- @Autowired+@Qualifier(\"bean的名称\")\n- @Resource(name=\"bean的名称\")\n\n### @Resource与@Autowired区别\n\n- @Autowired是spring框架提供的注解而@Resource:是jDK提供的注解。\n- @Autowired默认是按照类型注入，而@Resource默认是按照名称注入。\n\n# 开发流程\n\n\n\n![](https://pic.imgdb.cn/item/64300e6ba682492fcce7b1b8.jpg)\n\n\n\n一个完整的请求路径，应该是类上的@RequestMapping的value属性+方法上的@RequestMapping的value属性。\n\n![](https://pic.imgdb.cn/item/643017a6a682492fccf42311.jpg)\n\n@RequestParam(defaultValue=\"T\")/设置请求参数默认值\n\n##### PageHelper分页插件\n\n```java\n引入依赖：pagehelper-.spring-boot-starter\n使用：\nPageHelper.startPage(pageNum,pageSize);\nList<Emp>list empMapper.list();\nPage<Emp>page =(Page<Emp>)list;\n```\n\n### MultipartFile\n\n- String getOriginalFilename();// 获取原始文件名\n- void transferTo(File dest);//将接收的文件转存到磁盘文件中\n- long getsize();//获取文件的大小，单位：字节\n- byte[]getBytes();//获取文件内容的字节数组\n- InputStream getinputStream();//获取接收到的文件内容的输入流\n\n#配置单个文件最大上传大小\nspring.servlet.multipart.max-file-size=10MB\n#配置单个请求最大上传大小（一次请求可以上传多个文件）\nspring.servlet.multipart.max-request-size=100MB\n\n### 参数配置化\n\n![](https://pic.imgdb.cn/item/64311fe30d2dde57773fe933.jpg)\n\n### yml\n\n- 大小写敏感\n- 数值前边必须有空格，作为分隔符\n- 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格(idea中会自动将Tab转换为空格)\n- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n- #表示注释，从这个字符一直到行尾，都会被解析器忽略\n\n### @ConfigurationProperties@Value\n\n- 相同点\n\n  > 都是用来注入外部配置的属性的。\n\n- 不同点\n\n  > @Value:注解只能一个一个的进行外部属性的注入。\n  >\n  > @ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。\n\n## 登录认证\n\n![](https://pic.imgdb.cn/item/64312a6b0d2dde5777512dc6.jpg)\n\n会话技术\n\n- 会话：用户打开浏览器，访问Wb服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。\n- 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\n- 会话跟踪方案：\n  - 客户端会话跟踪技术：Cookie\n  - 服务端会话跟踪技术：Session\n  - 令牌技术\n","tags":["Java","Java个人总结"],"categories":["程序猿","javaWeb"]},{"title":"Maven","url":"/2023/04/04/Maven/","content":"# Maven\n\n## Maven的作用\n\n1. 依赖管理-- 方便快捷的管理项目依赖的资\n   源jar包，避免版本冲突问题\n2. 统一项目结构---提供标准、统一的项目结构\n3. 项目构建---标准跨平台(Linux、Windows、\n   MacOs)的自动化项目构建方式\n\n![](https://pic.imgdb.cn/item/642bf6f66ea21b9a9e78d9f7.jpg)\n\n![](https://pic.imgdb.cn/item/642bf76d6ea21b9a9e7a36d7.jpg)\n\n## 介绍\n\n![](https://pic.imgdb.cn/item/642bf8026ea21b9a9e7bd8d4.jpg)\n\n##Maven坐标\n\n![](https://pic.imgdb.cn/item/642c058c6ea21b9a9ecb52a7.jpg)\n\n## 依赖传递\n\n![](https://pic.imgdb.cn/item/642c0a316ea21b9a9ef57fca.jpg)\n\n## 依赖范围\n\n![](https://pic.imgdb.cn/item/642c0bf66ea21b9a9e0108da.jpg)\n\n## 生命周期\n\n- maven生命周期\n  clean:清理\n  compile:编译\n  test:测试\n  package:打包\n  install:安装\n\n1.Web服务器\n对HTTP协议操作进行封装，简化web程序开发。\n部署web项目，对外提供网上信息浏览服务。\n\n## tomcat\n\n![](https://pic.imgdb.cn/item/642c31966ea21b9a9e4271b9.jpg)\n\n基于Springboot开发的web应用程序，内置了tomcat服务器，当启\n动类运行时，会自动启动内嵌的tomcat服务器。\n\n## 起步依赖\n\nspring-boot-starter-web\nspring-boot-starter-test\n","tags":["Java","Java个人总结"],"categories":["程序猿","javaWeb"]},{"title":"HTML","url":"/2023/04/03/HTML/","content":"# HTML\n\n## Form表单\n\naction:表单提交的url,往何处提交数据.如果不指定，默认提交到当前页面\nmethod:表单的提交方式.\nget:在url后面拼接表单数据，比如：？username=Tom&age=l2,url长度有限制.默认值\npost：在消息体（清求体）中传递的，参数大小无限制的.\n\n```html\n<form action=\"\">\n        用户名：<input type=\"text\" name=\"username\">\n        年龄：<input type=\"text\" name=\"age\">\n\n        <input type=\"submit\" value=\"提交\">\n    </form>\n```\n\n```html\n <form action=\"\" method=\"post\">\n        用户名：<input type=\"text\" name=\"username\">\n        年龄：<input type=\"text\" name=\"age\">\n\n        <input type=\"submit\" value=\"提交\">\n    </form>\n```\n\n**注意：表单项必须有name属性才可以提交**\n\n![](https://pic.imgdb.cn/item/642a98eea682492fcc49ca25.jpg)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <!-- 内部引入 -->\n    <!-- <script>\n        alert('hello');\n    </script> -->\n    <!-- 外部引入 -->\n    <script src=\"js/a.js\"></script>\n</head>\n<body>\n    \n</body>\n</html>\n```\n\n### var变量\n\n- 通过var变量声明出来的作用域比较大，是全局变量\n\n- 是可以重复定义的\n\n  ` var x= 5；` \n\n  ` var x = \"a\"`\n\n### let变量\n\n- 局部变量，不能重复定义\n\n### const\n\n- 常量，不能改变\n\n## js原始类型\n\n- number:数字（整数、小数、NaN(Not a Number))\n- string:字符串，单双引皆可\n- boolean:布尔。true,false\n- null:对象为空\n- undefined:当声明的变量未初始化时，该变量的默认值是undefined\n- 使用typeof运算符可以获取数据类型\n\n### ==和===的区别\n\n==会进行类型转换，===不会进行类型转换\n\n```html\nvar a = 10;\n        console.log(a == \"10\");// true\n        console.log(a === \"10\");// false\n        console.log(a === 10); // true\n```\n\n### 字符串类型转为数字：\n\n将字符串字面值转为数字。如果字面值不是数字，则转为NaN。\n### 其他类型转为boolean:\n\n- Number:0和NaN为false,其他均转为true。\n- String:空字符串为false,其他均转为true。\n- Null和undefined:均转为false。\n\n```html\nalert(parseInt(\"12\")); //12 I\n        alert(parseInt(\"12A45\")); //12\n        alert(parseInt(\"A45\")); //NaN (not a number)\n```\n\n## 函数\n\n- 介绍：函数（方法）是被设计为执行特定任务的代码块。\n\n- 定义：JavaScript函数通过function关键字进行定义，语法为：\n\n  ```js\n  // 定义方式一\n  function functionName(参数1，参数二，，，){\n      \n  }\n  function add(a,b){\n              return a+b;\n          }\n  // 定义方式二\n  var functionName = function(参数一，参数二。。){\n  }\n  var add = function(a,b){\n  \treturn a+b;\n  }\n  \n  ```\n\n  \n\n- 注意：\n  形式参数不需要类型。因为avaScript是弱类型语言\n  返回值也不需要定义类型，可以在函数内部直接使用return返回即可\n\n- 调用：函数名称（实际参数列表）\n\n## js 对象\n\n### Array\n\nJavaScript中Array对象用于定义数组。\n\n```js\nvar arr = new Array(1,2,3,4);  // 定义方式一\n        var arrs = [1,2,.3,4,5];\n        console.log(arr[0]);\n        console.log(arrs[4]);\n```\n\n- 特点：长度可变类型可变\n- JavaScript中的数组相当于Java中集合，数组的长度是可变的，而JavaScript是弱类型，所以可以存储任意的类型的数据。\n\n```java\nvar arr = new Array(1,2,3,4);  // 定义方式一\n        arr[10] = 87;\n        console.log(arr[10]);// 87\n        arr[9] = \"true\";\n        console.log(arr); //  1,2,3,4,\"true\",87\n```\n\nforEach(): 遍历数组中的每个**有值**的元素，并调用一次传入的函数\n\n```js\narr.forEach(function(e){\n            console.log(e);\n        });\n// 简化\n// ES6箭头函数\narr.forEach((e) =>{\n            console.log(e);\n        })\n```\n\n\n\npush():将新元素添加到数组的末尾，并返回新的长度。\nsplice():从数组中删除元素。\n\n### String\n\ncharAt()      返回在指定位置的字符。\nindexof()\t\t检索字符串。\ntrim()\t\t去除字符串两边的空格\nsubstring()\t\t提取字符串中两个指定的索引号之间的字符。\n\n## JS对象\n\n![](https://pic.imgdb.cn/item/642aca27a682492fccfff38c.jpg)\n\n```js\nvar user = {\n            name: \"aa\",\n            age: 12,\n            gender: \"male\",\n            eat: function () {\n                alert(\"chi\")\n            }\n        }\n\n        alert(user.name);\n        user.eat();\n\n//简化\nvar user = {\n            name: \"aa\",\n            age: 12,\n            gender: \"male\",\n            eat() {\n                alert(\"chi\")\n            }\n        }\n\n        alert(user.name);\n        user.eat();\n```\n\n### json\n\n- 概念：JavaScript Object Notation,JavaScripti对象标记法。\n- SON是通过JavaScript对象标记法书写的文本。\n- 由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。\n\n####  json中value的数据类型为：\n\n- 数字（整数或浮点数）\n- 字符串（在双引号中）\n- 逻辑值(true或false)\n- 数组（在方括号中）\n- 对象（在花括号中）\n- null\n\n### JS0N字符串转为JS对象\n\nJSON.parse(userStr);\n\n```js\n// 定义\n        var变量名 = '{\"key1\":value1,\"key2\":value2}';\n        var userStr = '{\"name\":\"Jerry\",\"age\":18,\"addr\":[\"a\",\"b\",\"c\"],\"user\":{\"name\":\"tom\",\"age\":12}}';\n        var val = JSON.parse(userStr);\n        console.log(val.name); // Jerry\n        var s =JSON.stringify(val)\n        alert(s);\n```\n\n\n\n### JS对象转为JSON字符串\n\nJSON.stringify(val)\n\n## BOM\n\n- 慨念BrowserObject Model浏览器对象模型，允许制avaScript与浏览器对话，JavaScript将浏览器的各个组成部分封装为对象\n\n组成\n\n- Window:浏览器窗口对象\n- Navigator:浏览器对象\n- Screen:屏幕对象\n- History:历史记录对象\n- Location:地址栏对象\n\n1. window\n\n   ![](https://pic.imgdb.cn/item/642ad074a682492fcc1d8be8.jpg)\n\n   ```js\n   // 获取\n           // window.alert(\"aaa\");\n   \n           // 方法\n           // confirm  -- 对话框-- 确认：true；取消：false\n           // var flag = confirm(\"确定删除么\");\n           // alert(flag);\n           // 定时器 - setInterval-- 周期性执行某个函数\n           // var i = 0;\n           // setInterval(function(){\n           //     i++;\n           //     console.log(\"执行了\"+i);\n           // },2000)\n   \n           // 定时器 setTimeout-- 延迟指定时间执行一次\n           setTimeout(function(){\n               alert(\"aaa\")\n           },3000)\n   \n   ```\n\n   ### location\n\n   ![](https://pic.imgdb.cn/item/642ad4b2a682492fcc2b64b2.jpg)\n\n```js\nalert(location.href);\n        // 会自动跳转到目的地址\n        location.href = \"https://www.baidu.com\";\n```\n\n## Dom\n\n![](https://pic.imgdb.cn/item/642ad4b2a682492fcc2b64b2.jpg)\n\n# Vue\n\n![](https://pic.imgdb.cn/item/642ae683a682492fcce7b75a.jpg)\n\n```vue\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <script src=\"js/vue.js\"></script>\n</head>\n\n<body>\n    <div id=\"app\">\n        <!-- <a v-bind:href=\"url\">链接1</a>\n        <a :href=\"url\">链接2</a>\n        <input type=\"text\" name=\"\" id=\"\" v-model=\"url\"> -->\n\n\n        <!-- <button v-on:click=\"handle()\">点我一下</button>\n        <button @click=\"handle()\">点我一下</button> -->\n\n        <!-- <div v-for=\"(item, index) in arrs\" :key=\"index\">\n            这是item{{item}},这是index{{index}}\n        </div> -->\n\n        <table width=60% cellspacing=\"0\" border=\"1\">\n            <tr>\n                <th>编号</th>\n                <th>姓名</th>\n                <th>年龄</th>\n                <th>性别</th>\n                <th>成绩</th>\n                <th>等级</th>\n            </tr>\n            <tr v-for=\"(item, index) in user\" :key=\"index\" align=\"center\">\n                <td>{{index+1}}</td>\n                <td>{{item.name}}</td>\n                <td>{{item.age}}</td>\n                <td>\n                    <span v-if=\"item.gender == 1\">男</span>\n                    <span v-if=\"item.gender == 2\">女</span>\n                </td>\n\n                <td>{{item.source}}</td>\n                <td>\n                    <span v-if=\"item.source >=80\">优秀</span>\n                    <span style=\"color: red;\" v-else>不及格</span>\n                </td>\n            </tr>\n        </table>\n\n\n\n    </div>\n    <script>\n        new Vue({\n            el: \"#app\",\n            data: {\n                url: \"https://www.baidu.com\",\n                arrs: [1, 3, 5, 7, 9, 11],\n                user: [{\n                    name: \"tom\",\n                    age: 12,\n                    gender: 1,\n                    source: 78\n                }, {\n                    name: \"lissa\",\n                    age: 15,\n                    gender: 1,\n                    source: 30\n                }, {\n                    name: \"jack\",\n                    age: 12,\n                    gender: 2,\n                    source: 57\n                }, {\n                    name: \"jerry\",\n                    age: 18,\n                    gender: 1,\n                    source: 80\n                }, ]\n            },\n            methods: {\n\n\n            }\n        })\n    </script>\n</body>\n\n</html>\n```\n\n![](https://pic.imgdb.cn/item/642af1d7a682492fcc7b1177.jpg)\n\n![](https://pic.imgdb.cn/item/642af2b2a682492fcc82895b.jpg)\n\n![](https://pic.imgdb.cn/item/642b924e6ea21b9a9e68d9b6.jpg)\n\n# Ajax\n\n**概念：Asynchronous JavaScript And XML,异步的JavaScriptz和XML。**\n作用：\n●数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。\n●异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用的校验等等。\n\n![](https://pic.imgdb.cn/item/642b93576ea21b9a9e6c128a.jpg)\n\n## 同步和异步\n\n![](https://pic.imgdb.cn/item/642b93c76ea21b9a9e6d2535.jpg)\n\n## axios\n\n介绍：Axios对原生的Ajax进行了封装，简化书写，快速开发。\n官网：https://www.axios-http.cn/\n\n![](https://pic.imgdb.cn/item/642b95ad6ea21b9a9e71a8ac.jpg)\n\n## 请求方式别名\n\n![](https://pic.imgdb.cn/item/642b9fab6ea21b9a9e8e823d.jpg)\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n</head>\n\n<body>\n    <input type=\"button\" value=\"获取数据GET\" onclick=\"get()\">\n    <input type=\"button\" value=\"删除数据post\" onclick=\"post()\">\n    <script>\n        function get() {\n            // axios({\n            //     method: \"get\",\n            //     url:\"http://yapi.smart-xwork.cn/mock/169327/emp/list\",\n\n            // }).then(result =>{\n            //     console.log(result.data);\n            // })\n\n            // 简写\n            axios.get(\"http://yapi.smart-xwork.cn/mock/169327/emp/list\").then(result => {\n                console.log(result.data);\n            })\n        }\n\n        function post() {\n            // axios({\n            //     method: \"post\",\n            //     url: \"http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\",\n            //     data: \"id=1\"\n\n            // }).then(result => {\n            //     console.log(result.data);\n            // })\n\n\n            // 简写\n            axios.post(\"http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\", \"id=1\").then(result => {\n                console.log(result.data);\n            })\n\n        }\n    </script>\n\n</body>\n\n</html>\n```\n\n## 案例\n\n  ```js\n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"UTF-8\">\n      <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <title>Document</title>\n      <script src=\"js/vue.js\"></script>\n      <script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n  </head>\n  <body>\n      <div id=\"app\">\n          <table border=\"1\" cellspacing=\"0\" width=\"60%\">\n              <tr>\n                  <th>编号</th>\n                  <th>姓名</th>\n                  <th>图像</th>\n                  <th>性别</th>\n                  <th>职位</th>\n                  <th>入职时间</th>\n                  <th>最后操作时间</th>\n              </tr>\n              <tr v-for=\"(item, index) in val\" :key=\"index\" align=\"center\">\n                  <td>{{item.id}}</td>\n                  <td>{{item.name}}</td>\n                  <td>\n                      <img :src=\"item.image\" width=\"70px\" height=\"50px\">\n                  </td>\n                  <td>\n                      <span v-if=\"item.gender == 1\">男</span>\n                      <span v-if=\"item.gender == 2\">女</span>\n                  </td>\n                  <td>{{item.job}}</td>\n                  <td>{{item.entrydate}}</td>\n                  <td>{{item.updatetime}}</td>\n              </tr>\n          </table>\n  \n      </div>\n      <script>\n          new Vue({\n              el:\"#app\",\n              data:{\n                  val:[]\n              },\n              mounted () {\n                  axios.get(\"http://yapi.smart-xwork.cn/mock/169327/emp/list\").then(result =>{\n                      this.val = result.data.data;\n  \n                  })\n              }\n          })\n      </script>\n  </body>\n  </html>\n  ```\n\n## 前后端分离开发\n\n![](https://pic.imgdb.cn/item/642bb12c6ea21b9a9e0334f7.jpg)\n\n## Yapi\n\n提供接口服务。api管理平台\n\n## 前端工程化\n\n前端工程化：是指在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。\n\n### 环境准备\n\n![](https://pic.imgdb.cn/item/642bb5326ea21b9a9e0c5268.jpg)\n\n### Vue项目-目录结构\n\n![](https://pic.imgdb.cn/item/642bbd006ea21b9a9e41cd01.jpg)\n\n![](https://pic.imgdb.cn/item/642bc3976ea21b9a9e7eb7b6.jpg)\n\n## vuerouter\n\n介绍：Vue Router是Vue的官方路由。\n组成：\nVueRouter:路由器类，根据路由请求在路由视图中动态渲染选中的组件\n<router--link>:请求链接组件，浏览器会解析成<a>\n<router-vieW>:动态视图组件，用来渲染展示与路由路径对应的组件\n","tags":["Web","HTML"],"categories":["程序猿","javaWeb"]},{"title":"单元测试Junit","url":"/2023/04/02/单元测试/","content":"# 1. 单元测试Junit\n\n## 1.1 什么是单元测试？（掌握）\n\n对部分代码进行测试。\n\n## 1.2 Junit的特点？（掌握）\n\n* 是一个第三方的工具。（把别人写的代码导入项目中）（专业叫法：导jar包）\n\n* 如果运行结果显示绿色，表示运行结果是正确的。\n\n  如果运行结果显示红色，表示运行结果是错误的。\n\n## 1.3 基本用法：（掌握）\n\n1，一定要先写一个方法。\n\n2，在这个方法的上面写@Test\n\n3，鼠标点一下@Test  按alt + 回车，点击Junit4\n\n​\t此时就可以自动导包。\n\n​\t如果自动导包失败（连接外网，或者自己手动导包）\n\n​\t如果导包成功在左下角就会出现Junit4的相关jar包\n\n### 手动导包（掌握）\n\n1，在当前模块下，右键新建一个文件夹（lib）\n\n2，把今天资料里面的两个jar包，拷贝到lib文件夹里面\n\n3，选中两个jar右键点击add as a lib....\n\n4，到代码中，找到@Test，按alt + 回车，再来导入。\n\n### 运行测试代码（掌握）\n\n* 只能直接运行无参无返回值的非静态方法\n* 想要运行谁，就右键点击哪个方法。如果想要运行一个类里面所有的测试方法，选择类名，有点点击即可。\n\n### Junit正确的打开方式（正确的使用方式）（掌握）\n\n注意点：并不是直接在要测试的方法上面直接加@Test\n\n原因：因为要测试的方法有可能是有参数的，有返回值，或者是静态的。\n\n### 正确的使用方式：（掌握）\n\n1，新建测试类\n\n2，新建测试方法（要测试的方法名 + Test） methodTest\n\n3，在这个方法中直接调用要测试的方法\n\n4，在测试方法的上面写@Test\n\n代码示例：\n\n```java\n//真正用来测试的类\n//测试用例（测试类）\npublic class JunitTest {\n\n    //在这个类里面再写无参无返回值的非静态方法\n    //在方法中调用想要测试的方法\n\n    @Test\n    public void method2Test(){\n        //调用要测试的方法\n        JunitDemo1 jd = new JunitDemo1();\n        jd.method2(10);\n    }\n}\n```\n\n### 实际开发中单元测试的使用方式（掌握）\n\n需求：测试File中的delete方法，写的是否正确（掌握）\n\n开发中的测试原则：\n\n不污染原数据。\n\n代码示例：\n\n```java\npublic class JunitDemo3 {\n    //在实际开发中，真正完整的单元测试该怎么写？\n    //前提：\n    //以后在工作的时候，测试代码不能污染原数据。（修改，篡改）\n    //1.利用Before去对数据做一个初始化的动作\n    //2.利用Test真正的去测试方法\n    //3.利用After去还原数据\n    \n    //需求：测试File类中的delete方法是否书写正确？？？\n    @Before\n    public void beforemethod() throws IOException {\n        //先备份\n        File src = new File(\"C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt\");\n        File dest = new File(\"C:\\\\Users\\\\moon\\\\Desktop\\\\copy.txt\");\n\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while((b = fis.read()) != -1){\n            fos.write(b);\n        }\n        fos.close();\n        fis.close();\n    }\n\n    //作为一个标准的测试人员，运行完单元测试之后，不能污染原数据\n    //需要达到下面两个要求：\n    //1.得到结果\n    //2.a.txt还在而且其他的备份文件消失\n    @Test\n    public void method(){\n        File file = new File(\"C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt\");\n        boolean delete = file.delete();\n\n        //检查a.txt是否存在\n        boolean exists = file.exists();\n\n        //只有同时满足了下面所有的断言，才表示delete方法编写正确\n        Assert.assertEquals(\"delete方法出错了\",delete,true);\n        Assert.assertEquals(\"delete方法出错了\",exists,false);\n    }\n\n\n    @After\n    public void aftermethod() throws IOException {\n        //还要对a.txt做一个还原\n        File src = new File(\"C:\\\\Users\\\\moon\\\\Desktop\\\\copy.txt\");\n        File dest = new File(\"C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt\");\n\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while((b = fis.read()) != -1){\n            fos.write(b);\n        }\n        fos.close();\n        fis.close();\n\n        //备份数据要删除\n        src.delete();\n\n    }\n}\n```\n\n作业：\n\n​\t测试Properties类中的store方法是否书写正确？\n\n开发心得：\n\n1.Before  准备数据\n\n2.Test  测试方法\n\n3.After 还原\n\n\n\nBefore\n\n```java\n准备数据\n1.创建Properties的对象\n2.put数据到集合当中\n//只不过在下面的方法中，我们也需要用到Properties的对象，所以写完之后要挪到成员位置\n```\n\nTest\n\n```java\n调用store方法，保存数据到本地文件\n\n断言1：\n\t判断当前文件是否存在\n断言2：\n\t文件的大小一定是大于0\n断言3：\n\t再次读取文件中的数据，判断是否跟集合中一致\n\n结论：\n\t如果所有的断言都通过了，表示store方法是正确的\n```\n\nAfter\n\n```java\n把本地文件给删除\n```\n\n### 扩展点：\n\n在单元测试中，相对路径是相对当前模块而言的。\n\n代码示例：\n\n```java\nFile file = new File(\"aweihaoshuai.txt\");\nfile.createNewFile();\n//此时是把aweihaoshuai.txt这个文件新建到模块中了。\n```\n\n\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"注解","url":"/2023/04/02/注解/","content":"# 1. 注解 \n\n## 1.1 注释和注解的区别？（掌握）\n\n共同点：都可以对程序进行解释说明。\n\n不同点：注释，是给程序员看的。只在Java中有效。在class文件中不存在注释的。\n\n​\t\t当编译之后，会进行注释擦除。\n\n​\t\t注解，是给虚拟机看的。当虚拟机看到注解之后，就知道要做什么事情了。\n\n##1.2 如何使用注解（掌握）\n\n在以前看过注解@Override。\n\n当子类重写父类方法的时候，在重写的方法上面写@Override。\n\n当虚拟机看到@Override的时候，就知道下面的方法是重写的父类的。检查语法，如果语法正确编译正常，如果语法错误，就会报错。\n\n## 1.3 Java中已经存在的注解（掌握）\n\n@Override：表示方法的重写\n\n@Deprecated：表示修饰的方法已过时\n\n@SuppressWarnings(\"all\")：压制警告\n\n\n\n除此之外，还需要掌握第三方框架中提供的注解：\n\n比如：Junit\n\n@Test 表示运行测试方法\n\n@Before 表示在Test之前运行，进行数据的初始化\n\n@After 表示在Test之后运行，进行数据的还原\n\n\n\n## 1.4 自定义注解（了解）\n\n自定义注解单独存在是没有什么意义的，一般会跟反射结合起来使用，会用发射去解析注解。\n\n针对于注解，只要掌握会使用别人已经写好的注解即可。\n\n关于注解的解析，一般是在框架的底层已经写好了。\n\n## 1.5 特殊属性（掌握）\n\nvalue：\n\n​\t当注解中只有\"一个属性\",并且属性名是\"value\",使用注解时,可以省略value属性名\n\n代码示例：\n\n```java\n//注解的定义\npublic @interface Anno2 {\n    public String value();\n\n    public int age() default 23;\n}\n\n//注解的使用\n@Anno2(\"123\")\npublic class AnnoDemo2 {\n\n    @Anno2(\"123\")\n    public void method(){\n\n    }\n}\n```\n\n## 1.6 元注解（了解）\n\n可以写在注解上面的注解\n\n@Target ：指定注解能在哪里使用\n\n@Retention ：可以理解为保留时间(生命周期) \n\n#### Target:\n\n​    作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。\n\n​    可使用的值定义在ElementType枚举类中，常用值如下\n\n* TYPE，类，接口\n* FIELD, 成员变量\n* METHOD, 成员方法\n* PARAMETER, 方法参数\n* CONSTRUCTOR, 构造方法\n* LOCAL_VARIABLE, 局部变量\n\n#### Retention：\n\n​    作用：用来标识注解的生命周期(有效范围)\n\n​    可使用的值定义在RetentionPolicy枚举类中，常用值如下\n\n* SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在\n* CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值\n* RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段\n\n注解的解析：\n\n## 1.7 模拟JUnit自带的@Test注解（了解）\n\n代码示例：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyTest {\n}\n\npublic class MyTestMethod {\n\n    @MyTest\n    public void method1(){\n        System.out.println(\"method1\");\n    }\n\n    public void method2(){\n        System.out.println(\"method2\");\n    }\n\n    @MyTest\n    public void method3(){\n        System.out.println(\"method3\");\n    }\n}\n\npublic class MyTestDemo {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n        //1,获取class对象\n        Class clazz = Class.forName(\"com.itheima.test2.MyTestMethod\");\n\n        //获取对象\n        Object o = clazz.newInstance();\n\n        //2.获取所有方法\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            //method依次表示类里面的每一个方法\n            method.setAccessible(true);\n            //判断当前方法有没有MyTest注解\n            if(method.isAnnotationPresent(MyTest.class)){\n                method.invoke(o);\n            }\n        }\n    }\n}\n```\n\n## 1.8 注解小结：\n\n掌握如何使用已经存在的注解即可。\n\n@Override：表示方法的重写\n\n@Deprecated：表示修饰的方法已过时\n\n@SuppressWarnings(\"all\")：压制警告\n\n@Test：表示要运行的方法\n\n在以后的实际开发中，注解是使用框架已经提供好的注解。\n\n自定义注解+解析注解（很难的，**了解**），一般会出现在框架的底层。当以后我们要自己写一个框架的时候，才会用到自定义注解+解析注解。\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"XML","url":"/2023/04/02/xml/","content":"## 1.xml\n\n### 1.1概述【理解】\n\n+ 万维网联盟(W3C)\n\n  万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。\n  建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。\n  是Web技术领域最具权威和影响力的国际中立性技术标准机构。\n  到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南，\n\n  + 如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、\n\n  + 可扩展标记语言XML（标准通用标记语言下的一个子集）\n\n  + 以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等\n\n+ xml概述\n\n  XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言\n  标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)\n  可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的\n\n+ 作用\n\n  + 用于进行存储数据和传输数据\n  + 作为软件的配置文件\n\n+ 作为配置文件的优势\n\n  + 可读性好\n  + 可维护性高\n\n### 1.2标签的规则【应用】\n\n+ 标签由一对尖括号和合法标识符组成\n\n  ```java\n  <student>\n  ```\n\n+ 标签必须成对出现\n\n  ```java\n  <student> </student>\n  前边的是开始标签，后边的是结束标签\n  ```\n\n+ 特殊的标签可以不成对,但是必须有结束标记\n\n  ```java\n  <address/>\n  ```\n\n+ 标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来\n\n  ```java\n  <student id=\"1\"> </student>\n  ```\n\n+ 标签需要正确的嵌套\n\n  ```java\n  这是正确的: <student id=\"1\"> <name>张三</name> </student>\n  这是错误的: <student id=\"1\"><name>张三</student></name>\n  ```\n\n### 1.3语法规则【应用】\n\n+ 语法规则\n\n  + XML文件的后缀名为：xml\n\n  + 文档声明必须是第一行第一列\n\n    <?xml version=“1.0” encoding=“UTF-8” standalone=“yes”?>\n    version：该属性是必须存在的\n    encoding：该属性不是必须的\n\n    ​\t打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)\n\n    standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no\n\n  + 必须存在一个根标签，有且只能有一个\n\n  + XML文件中可以定义注释信息\n\n  + XML文件中可以存在以下特殊字符\n\n    ```java\n    &lt; < 小于\n    &gt; > 大于\n    &amp; & 和号\n    &apos; ' 单引号\n    &quot; \" 引号\n    ```\n\n  + XML文件中可以存在CDATA区\n\n    <![CDATA[ …内容… ]]>\n\n+ 示例代码\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n  <!--注释的内容-->\n  <!--本xml文件用来描述多个学生信息-->\n  <students>\n  \n      <!--第一个学生信息-->\n      <student id=\"1\">\n          <name>张三</name>\n          <age>23</age>\n          <info>学生&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;的信息</info>\n          <message> <![CDATA[内容 <<<<<< >>>>>> ]]]></message>\n      </student>\n  \n      <!--第二个学生信息-->\n      <student id=\"2\">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n  \n  </students>\n  ```\n\n### 1.4xml解析【应用】\n\n+ 概述\n\n  xml解析就是从xml中获取到数据\n\n+ 常见的解析思想\n\n  DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。\n  会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值\n\n  ![](https://pic.imgdb.cn/item/64296995a682492fcc99b393.jpg)\n\n+ 常见的解析工具\n\n  + JAXP: SUN公司提供的一套XML的解析的API\n  + JDOM: 开源组织提供了一套XML的解析的API-jdom\n  + DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java\n  + pull: 主要应用在Android手机端解析XML\n\n+ 解析的准备工作\n\n  1. 我们可以通过网站：https://dom4j.github.io/ 去下载dom4j\n\n     今天的资料中已经提供,我们不用再单独下载了,直接使用即可\n\n  2. 将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar\n\n  3. 在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中\n\n  4. 选中jar包 -> 右键 -> 选择add as library即可\n\n+ 需求\n\n  + 解析提供好的xml文件\n  + 将解析到的数据封装到学生对象中\n  + 并将学生对象存储到ArrayList集合中\n  + 遍历集合\n\n+ 代码实现\n\n  ```java\n  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n  <!--注释的内容-->\n  <!--本xml文件用来描述多个学生信息-->\n  <students>\n  \n      <!--第一个学生信息-->\n      <student id=\"1\">\n          <name>张三</name>\n          <age>23</age>\n      </student>\n  \n      <!--第二个学生信息-->\n      <student id=\"2\">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n  \n  </students>\n  \n  // 上边是已经准备好的student.xml文件\n  public class Student {\n      private String id;\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String id, String name, int age) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getId() {\n          return id;\n      }\n  \n      public void setId(String id) {\n          this.id = id;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  \n      @Override\n      public String toString() {\n          return \"Student{\" +\n                  \"id='\" + id + '\\'' +\n                  \", name='\" + name + '\\'' +\n                  \", age=\" + age +\n                  '}';\n      }\n  }\n  \n  /**\n   * 利用dom4j解析xml文件\n   */\n  public class XmlParse {\n      public static void main(String[] args) throws DocumentException {\n          //1.获取一个解析器对象\n          SAXReader saxReader = new SAXReader();\n          //2.利用解析器把xml文件加载到内存中,并返回一个文档对象\n          Document document = saxReader.read(new File(\"myxml\\\\xml\\\\student.xml\"));\n          //3.获取到根标签\n          Element rootElement = document.getRootElement();\n          //4.通过根标签来获取student标签\n          //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.\n          //elements(\"标签名\"):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回\n          //List list = rootElement.elements();\n          List<Element> studentElements = rootElement.elements(\"student\");\n          //System.out.println(list.size());\n  \n          //用来装学生对象\n          ArrayList<Student> list = new ArrayList<>();\n  \n          //5.遍历集合,得到每一个student标签\n          for (Element element : studentElements) {\n              //element依次表示每一个student标签\n    \n              //获取id这个属性\n              Attribute attribute = element.attribute(\"id\");\n              //获取id的属性值\n              String id = attribute.getValue();\n  \n              //获取name标签\n              //element(\"标签名\"):获取调用者指定的子标签\n              Element nameElement = element.element(\"name\");\n              //获取这个标签的标签体内容\n              String name = nameElement.getText();\n  \n              //获取age标签\n              Element ageElement = element.element(\"age\");\n              //获取age标签的标签体内容\n              String age = ageElement.getText();\n  \n  //            System.out.println(id);\n  //            System.out.println(name);\n  //            System.out.println(age);\n  \n              Student s = new Student(id,name,Integer.parseInt(age));\n              list.add(s);\n          }\n          //遍历操作\n          for (Student student : list) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 1.5DTD约束【理解】\n\n+ 什么是约束\n\n  用来限定xml文件中可使用的标签以及属性\n\n+ 约束的分类\n\n  + DTD\n  + schema\n\n+ 编写DTD约束\n\n  + 步骤\n\n    1. 创建一个文件，这个文件的后缀名为.dtd\n\n    2. 看xml文件中使用了哪些元素\n\n       <!ELEMENT> 可以定义元素\n\n    3. 判断元素是简单元素还是复杂元素\n\n       简单元素：没有子元素。\n       复杂元素：有子元素的元素；\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    ```\n  ```\n\n  ```\n\n+ 引入DTD约束\n\n  + 引入DTD约束的三种方法\n\n    + 引入本地dtd\n\n      <!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径'>\n\n    + 在xml文件内部引入\n\n      <!DOCTYPE 根元素名称 [ dtd文件内容 ]>\n\n    + 引入网络dtd\n\n      <!DOCTYPE 根元素的名称 PUBLIC \"DTD文件名称\" \"DTD文档的URL\">\n\n  + 代码实现\n\n    + 引入本地DTD约束\n\n      ```xml\n      // 这是persondtd.dtd文件中的内容,已经提前写好\n      <!ELEMENT persons (person)>\n      <!ELEMENT person (name,age)>\n      <!ELEMENT name (#PCDATA)>\n      <!ELEMENT age (#PCDATA)>\n\n      // 在person1.xml文件中引入persondtd.dtd约束\n      <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n      <!DOCTYPE persons SYSTEM 'persondtd.dtd'>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 在xml文件内部引入\n\n      ```xml\n      <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n      <!DOCTYPE persons [\n              <!ELEMENT persons (person)>\n              <!ELEMENT person (name,age)>\n              <!ELEMENT name (#PCDATA)>\n              <!ELEMENT age (#PCDATA)>\n              ]>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 引入网络dtd\n\n      ```xml\n      <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n      <!DOCTYPE persons PUBLIC \"dtd文件的名称\" \"dtd文档的URL\">\n      \n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n      \n      </persons>\n      ```\n\n+ DTD语法\n\n  + 定义元素\n\n    定义一个元素的格式为：<!ELEMENT 元素名 元素类型>\n    简单元素：\n\n    ​\tEMPTY: 表示标签体为空\n\n    ​\tANY: 表示标签体可以为空也可以不为空\n\n    ​\tPCDATA: 表示该元素的内容部分为字符串\n\n    复杂元素：\n    ​\t直接写子元素名称. 多个子元素可以使用\",\"或者\"|\"隔开；\n    ​\t\",\"表示定义子元素的顺序 ; \"|\": 表示子元素只能出现任意一个\n    ​\t\"?\"零次或一次, \"+\"一次或多次, \"*\"零次或多次;如果不写则表示出现一次\n\n    ![](https://pic.imgdb.cn/item/642969c5a682492fcc9a41af.jpg)\n\n\n  + 定义属性\n\n    格式\n\n    定义一个属性的格式为：<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束>\n    属性的类型：\n    ​\tCDATA类型：普通的字符串\n\n    属性的约束:\n\n    ​\t// #REQUIRED： 必须的\n    ​\t// #IMPLIED： 属性不是必需的\n    ​\t// #FIXED value：属性值是固定的\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person+)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    <!ATTLIST person id CDATA #REQUIRED>\n    \n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <!DOCTYPE persons SYSTEM 'persondtd.dtd'>\n    \n    <persons>\n        <person id=\"001\">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n    \n        <person id = \"002\">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n    \n    </persons>\n    ​```\n    ```\n\n### 1.6schema约束【理解】\n\n+ schema和dtd的区别\n\n  1. schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd\n  2. 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）\n  3. dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型\n  4. schema 语法更加的复杂\n\n  ![](https://pic.imgdb.cn/item/642969dfa682492fcc9a87fa.jpg)\n\n+ 编写schema约束\n\n  + 步骤\n\n    1，创建一个文件，这个文件的后缀名为.xsd。\n    2，定义文档声明\n    3，schema文件的根标签为： <schema>\n    4，在<schema>中定义属性：\n    ​\txmlns=http://www.w3.org/2001/XMLSchema\n    5，在<schema>中定义属性 ：\n    ​\ttargetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。\n    6，在<schema>中定义属性 ：\n    ​\telementFormDefault=\"qualified“，表示当前schema文件是一个质量良好的文件。\n    7，通过element定义元素\n    8，判断当前元素是简单元素还是复杂元素\n\n    ![](https://pic.imgdb.cn/item/642969f2a682492fcc9abfd6.jpg)\n\n  + 代码实现\n\n    ```java\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <schema\n        xmlns=\"http://www.w3.org/2001/XMLSchema\"\n        targetNamespace=\"http://www.itheima.cn/javase\"\n        elementFormDefault=\"qualified\"\n    >\n    \n        <!--定义persons复杂元素-->\n        <element name=\"persons\">\n            <complexType>\n                <sequence>\n                    <!--定义person复杂元素-->\n                    <element name = \"person\">\n                        <complexType>\n                            <sequence>\n                                <!--定义name和age简单元素-->\n                                <element name = \"name\" type = \"string\"></element>\n                                <element name = \"age\" type = \"string\"></element>\n                            </sequence>\n                            \n                        </complexType>\n                    </element>\n                </sequence>\n            </complexType>\n    \n        </element>\n    \n    </schema>\n    \n    ```\n\n+ 引入schema约束\n\n  + 步骤\n\n    1，在根标签上定义属性xmlns=\"http://www.w3.org/2001/XMLSchema-instance\"\n    2，通过xmlns引入约束文件的名称空间\n    3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间\n    ​\t格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi\n    4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径\n    ​\t格式为：xsi:schemaLocation = \"名称空间url 文件路径“\n\n  + 代码实现\n\n    ```java\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    \n    <persons\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns=\"http://www.itheima.cn/javase\"\n        xsi:schemaLocation=\"http://www.itheima.cn/javase person.xsd\"\n    >\n        <person>\n            <name>张三</name>\n            <age>23</age>\n        </person>\n    \n    </persons>\n    ​```\n    ```\n\n+ schema约束定义属性\n\n  + 代码示例\n\n    ```java\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <schema\n        xmlns=\"http://www.w3.org/2001/XMLSchema\"\n        targetNamespace=\"http://www.itheima.cn/javase\"\n        elementFormDefault=\"qualified\"\n    >\n    \n        <!--定义persons复杂元素-->\n        <element name=\"persons\">\n            <complexType>\n                <sequence>\n                    <!--定义person复杂元素-->\n                    <element name = \"person\">\n                        <complexType>\n                            <sequence>\n                                <!--定义name和age简单元素-->\n                                <element name = \"name\" type = \"string\"></element>\n                                <element name = \"age\" type = \"string\"></element>\n                            </sequence>\n                            \n                            <!--定义属性，required( 必须的)/optional( 可选的)-->\n                            <attribute name=\"id\" type=\"string\" use=\"required\"></attribute>\n                        </complexType>\n                        \n                    </element>\n                </sequence>\n            </complexType>\n        </element>\n        \n    </schema>\n    \n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <persons\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns=\"http://www.itheima.cn/javase\"\n        xsi:schemaLocation=\"http://www.itheima.cn/javase person.xsd\"\n    >\n        <person id=\"001\">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n    \n    </persons>\n    ​```\n    ```\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"类加载器","url":"/2023/04/02/类加载器/","content":"# 写在前面的话：\n\n> 基础加强包含了：\n>\n> 反射，动态代理，类加载器，xml，注解，日志，单元测试等知识点\n>\n> 其中最难的是反射和动态代理，其他知识点都非常简单\n>\n\n## 1.类加载器\n\n### 1.1类加载器\n\n+ 作用\n\n  负责将.class文件（存储的物理文件）加载在到内存中\n\n  ![](https://pic.imgdb.cn/item/6429669aa682492fcc936fad.jpg)\n\n### 1.2类加载的完整过程\n\n+ 类加载时机\n\n  简单理解：字节码文件什么时候会被加载到内存中？\n\n  有以下的几种情况：\n\n  + 创建类的实例（对象）\n  + 调用类的类方法\n  + 访问类或者接口的类变量，或者为该类变量赋值\n  + 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\n  + 初始化某个类的子类\n  + 直接使用java.exe命令来运行某个主类\n\n  总结而言：用到了就加载，不用不加载\n\n+ 类加载过程\n\n  1. 加载\n\n     + 通过包名 + 类名，获取这个类，准备用流进行传输\n     + 在这个类加载到内存中\n     + 加载完毕创建一个class对象\n\n     ![](https://pic.imgdb.cn/item/642966b3a682492fcc93947f.jpg)\n\n  2. 链接\n\n     + 验证\n\n       确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\n\n       (文件中的信息是否符合虚拟机规范有没有安全隐患)\n\n     ![](https://pic.imgdb.cn/item/642966c6a682492fcc93aea3.jpg)\n\n     + 准备\n\n       负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值\n\n       (初始化静态变量)\n\n     ![](https://pic.imgdb.cn/item/642966d5a682492fcc93c8f9.jpg)\n\n     + 解析\n\n       将类的二进制数据流中的符号引用替换为直接引用\n\n       (本类中如果用到了其他类，此时就需要找到对应的类)\n\n     ![](https://pic.imgdb.cn/item/642966e9a682492fcc93e877.jpg)\n\n  3. 初始化\n\n     根据程序员通过程序制定的主观计划去初始化类变量和其他资源\n\n     (静态变量赋值以及初始化其他资源)\n\n     ![](https://pic.imgdb.cn/item/64296700a682492fcc940b6a.jpg)\n\n+ 小结\n\n  + 当一个类被使用的时候，才会加载到内存\n  + 类加载的过程: 加载、验证、准备、解析、初始化\n\n### 1.3类加载的分类【理解】\n\n+ 分类\n  + Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null\n  + Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块\n  + System class loader：系统类加载器,负责加载用户类路径上所指定的类库\n\n+ 类加载器的继承关系\n\n  + System的父加载器为Platform\n  + Platform的父加载器为Bootstrap\n\n+ 代码演示\n\n  ```java\n  public class ClassLoaderDemo1 {\n      public static void main(String[] args) {\n          //获取系统类加载器\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n  \n          //获取系统类加载器的父加载器 --- 平台类加载器\n          ClassLoader classLoader1 = systemClassLoader.getParent();\n  \n          //获取平台类加载器的父加载器 --- 启动类加载器\n          ClassLoader classLoader2 = classLoader1.getParent();\n  \n          System.out.println(\"系统类加载器\" + systemClassLoader);\n          System.out.println(\"平台类加载器\" + classLoader1);\n          System.out.println(\"启动类加载器\" + classLoader2);\n  \n      }\n  }\n  ```\n\n### 1.4双亲委派模型【理解】\n\n+ 介绍\n\n  如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式\n\n  ![](https://pic.imgdb.cn/item/6429670ea682492fcc942072.jpg)\n\n\n### 1.5ClassLoader 中的两个方法【应用】\n\n- 方法介绍\n\n  | 方法名                                      | 说明        |\n  | ---------------------------------------- | --------- |\n  | public static ClassLoader getSystemClassLoader() | 获取系统类加载器  |\n  | public InputStream getResourceAsStream(String name) | 加载某一个资源文件 |\n\n- 示例代码\n\n  ```java\n  public class ClassLoaderDemo2 {\n      public static void main(String[] args) throws IOException {\n          //static ClassLoader getSystemClassLoader() 获取系统类加载器\n          //InputStream getResourceAsStream(String name)  加载某一个资源文件\n  \n          //获取系统类加载器\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n  \n          //利用加载器去加载一个指定的文件\n          //参数：文件的路径（放在src的根目录下，默认去那里加载）\n          //返回值：字节流。\n          InputStream is = systemClassLoader.getResourceAsStream(\"prop.properties\");\n  \n          Properties prop = new Properties();\n          prop.load(is);\n  \n          System.out.println(prop);\n  \n          is.close();\n      }\n  }\n  ```\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"log日志","url":"/2023/04/02/log日志/","content":"# 日志\n\n## 1.1 作用：\n\n​\t跟输出语句一样，可以把程序在运行过程中的详细信息都打印在控制台上。\n\n​\t利用log日志还可以把这些详细信息保存到文件和数据库中。\n\n## 1.2 使用步骤：\n\n​\t不是java的，也不是自己写的，是第三方提供的代码，所以我们要导入jar包。\n\n* 把第三方的代码导入到当前的项目当中\n\n  新建lib文件夹，把jar粘贴到lib文件夹当中，全选后右键点击选择add as a ....\n\n  检测导入成功：导入成功后jar包可以展开。在项目重构界面可以看到导入的内容\n\n* 把配置文件粘贴到src文件夹下\n\n* 在代码中获取日志对象\n\n* 调用方法打印日志\n\n## 1.3 日志级别\n\n```\nTRACE, DEBUG, INFO, WARN, ERROR\n```\n\n还有两个特殊的：\n\n​\tALL：输出所有日志\n\n​\tOFF：关闭所有日志\n\n日志级别从小到大的关系：\n\n​\tTRACE < DEBUG < INFO < WARN < ERROR\n\n## 1.4 配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <!--\n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。\n    -->\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <!--输出流对象 默认 System.out 改为 System.err-->\n        <target>System.out</target>\n        <encoder>\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度\n                %msg：日志消息，%n是换行符-->\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <!-- File是输出的方向通向文件的 -->\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n            <charset>utf-8</charset>\n        </encoder>\n        <!--日志输出路径-->\n        <file>C:/code/itheima-data.log</file>\n        <!--指定日志文件拆分和压缩规则-->\n        <rollingPolicy\n                       class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <!--通过指定压缩文件名称，来确定分割文件方式-->\n            <fileNamePattern>C:/code/itheima-data2-%d{yyyy-MMdd}.log%i.gz</fileNamePattern>\n            <!--文件拆分大小-->\n            <maxFileSize>1MB</maxFileSize>\n        </rollingPolicy>\n    </appender>\n\n    <!--\n\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\n   ， 默认debug\n    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。\n    -->\n    <root level=\"info\">\n        <appender-ref ref=\"CONSOLE\"/>\n        <appender-ref ref=\"FILE\" />\n    </root>\n</configuration>\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"代理个人笔记","url":"/2023/04/02/代理/","content":"# 代理\n\n![](https://pic.imgdb.cn/item/64295e17a682492fcc879c03.jpg)\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"网络编程","url":"/2023/03/28/网络编程/","content":"## 1. 网络编程入门\n\n### 1.1 网络编程概述\n\n- 计算机网络\n\n  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统\n\n- 网络编程\n\n  在网络通信协议下，不同计算机上运行的程序，可以进行数据传输\n\n### 1.2 网络编程三要素\n\n- IP地址\n\n  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识\n\n- 端口\n\n  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识\n\n- 协议\n\n  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议\n\n### 1.3 IP地址\n\nIP地址：是网络中设备的唯一标识\n\n- IP地址分为两大类\n  - IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多\n  - IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题\n- DOS常用命令：\n  - ipconfig：查看本机IP地址\n  - ping IP地址：检查网络是否连通\n- 特殊IP地址：\n  - 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用\n\n### 1.4 InetAddress\n\nInetAddress：此类表示Internet协议（IP）地址\n\n- 相关方法\n\n  | 方法名                                    | 说明                                                         |\n  | ----------------------------------------- | ------------------------------------------------------------ |\n  | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 |\n  | String getHostName()                      | 获取此IP地址的主机名                                         |\n  | String getHostAddress()                   | 返回文本显示中的IP地址字符串                                 |\n\n- 代码演示\n\n  ```java\n  public class InetAddressDemo {\n      public static void main(String[] args) throws UnknownHostException {\n  \t\t//InetAddress address = InetAddress.getByName(\"itheima\");\n          InetAddress address = InetAddress.getByName(\"192.168.1.66\");\n  \n          //public String getHostName()：获取此IP地址的主机名\n          String name = address.getHostName();\n          //public String getHostAddress()：返回文本显示中的IP地址字符串\n          String ip = address.getHostAddress();\n  \n          System.out.println(\"主机名：\" + name);\n          System.out.println(\"IP地址：\" + ip);\n      }\n  }\n  ```\n\n### 1.5 端口和协议\n\n- 端口\n\n  - 设备上应用程序的唯一标识\n\n- 端口号\n\n  - 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败\n\n- 协议\n\n  - 计算机网络中，连接和通信的规则被称为网络通信协议\n\n- UDP协议\n\n  - 用户数据报协议(User Datagram Protocol)\n  - UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。\n  - 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输\n  - 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议\n\n- TCP协议\n\n  - 传输控制协议 (Transmission Control Protocol)\n\n  - TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”\n\n  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠\n\n    第一次握手，客户端向服务器端发出连接请求，等待服务器确认\n\n    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求\n\n    第三次握手，客户端再次向服务器端发送确认信息，确认连接\n\n  - 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等\n\n## 2.UDP通信程序\n\n### 2.1 UDP发送数据\n\n- Java中的UDP通信\n\n  - UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念\n  - Java提供了DatagramSocket类作为基于UDP协议的Socket\n\n- 构造方法\n\n  | 方法名                                                      | 说明                                                 |\n  | ----------------------------------------------------------- | ---------------------------------------------------- |\n  | DatagramSocket()                                            | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 |\n  | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |\n\n- 相关方法\n\n  | 方法名                         | 说明                   |\n  | ------------------------------ | ---------------------- |\n  | void send(DatagramPacket p)    | 发送数据报包           |\n  | void close()                   | 关闭数据报套接字       |\n  | void receive(DatagramPacket p) | 从此套接字接受数据报包 |\n\n- 发送数据的步骤\n\n  - 创建发送端的Socket对象(DatagramSocket)\n  - 创建数据，并把数据打包\n  - 调用DatagramSocket对象的方法发送数据\n  - 关闭发送端\n\n- 代码演示\n\n  ```java\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口\n          DatagramSocket ds = new DatagramSocket();\n  \n          //创建数据，并把数据打包\n          //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n          //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。\n          byte[] bys = \"hello,udp,我来了\".getBytes();\n  \n          DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName(\"127.0.0.1\"),10086);\n  \n          //调用DatagramSocket对象的方法发送数据\n          //void send(DatagramPacket p) 从此套接字发送数据报包\n          ds.send(dp);\n  \n          //关闭发送端\n          //void close() 关闭此数据报套接字\n          ds.close();\n      }\n  }\n  ```\n\n### 2.2UDP接收数据\n\n- 接收数据的步骤\n\n  - 创建接收端的Socket对象(DatagramSocket)\n  - 创建一个数据包，用于接收数据\n  - 调用DatagramSocket对象的方法接收数据\n  - 解析数据包，并把数据在控制台显示\n  - 关闭接收端\n\n- 构造方法\n\n  | 方法名                              | 说明                                            |\n  | ----------------------------------- | ----------------------------------------------- |\n  | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |\n\n- 相关方法\n\n  | 方法名            | 说明                                     |\n  | ----------------- | ---------------------------------------- |\n  | byte[]  getData() | 返回数据缓冲区                           |\n  | int  getLength()  | 返回要发送的数据的长度或接收的数据的长度 |\n\n- 示例代码\n\n  ```java\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n        \t//创建接收端的Socket对象(DatagramSocket)\n        \tDatagramSocket ds = new DatagramSocket(12345);\n  \n        \t//创建一个数据包，用于接收数据\n        \tbyte[] bys = new byte[1024];\n        \tDatagramPacket dp = new DatagramPacket(bys, bys.length);\n  \n        \t//调用DatagramSocket对象的方法接收数据\n        \tds.receive(dp);\n  \n        \t//解析数据包，并把数据在控制台显示\n        \tSystem.out.println(\"数据是：\" + new String(dp.getData(), 0,                                             dp.getLength()));\n          }\n      }\n  }\n  ```\n\n### 2.3UDP通信程序练习\n\n- 案例需求\n\n  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束\n\n  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n\n- 代码实现\n\n  ```java\n  /*\n      UDP发送数据：\n          数据来自于键盘录入，直到输入的数据是886，发送数据结束\n   */\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          //键盘录入数据\n          Scanner sc = new Scanner(System.in);\n          while (true) {\n            \tString s = sc.nextLine();\n              //输入的数据是886，发送数据结束\n              if (\"886\".equals(s)) {\n                  break;\n              }\n              //创建数据，并把数据打包\n              byte[] bys = s.getBytes();\n              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(\"192.168.1.66\"), 12345);\n  \n              //调用DatagramSocket对象的方法发送数据\n              ds.send(dp);\n          }\n          //关闭发送端\n          ds.close();\n      }\n  }\n  \n  /*\n      UDP接收数据：\n          因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n   */\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n          //创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(12345);\n          while (true) {\n              //创建一个数据包，用于接收数据\n              byte[] bys = new byte[1024];\n              DatagramPacket dp = new DatagramPacket(bys, bys.length);\n              //调用DatagramSocket对象的方法接收数据\n              ds.receive(dp);\n              //解析数据包，并把数据在控制台显示\n              System.out.println(\"数据是：\" + new String(dp.getData(), 0, dp.getLength()));\n          }\n          //关闭接收端\n  //        ds.close();\n      }\n  }\n  ```\n\n### 2.4UDP三种通讯方式\n\n- 单播\n\n  单播用于两个主机之间的端对端通信\n\n- 组播\n\n  组播用于对一组特定的主机进行通信\n\n- 广播\n\n  广播用于一个主机对整个局域网上所有主机上的数据通信\n\n### 2.5UDP组播实现\n\n- 实现步骤\n\n  - 发送端\n    1. 创建发送端的Socket对象(DatagramSocket)\n    2. 创建数据，并把数据打包(DatagramPacket)\n    3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n    4. 释放资源\n  - 接收端\n    1. 创建接收端Socket对象(MulticastSocket)\n    2. 创建一个箱子,用于接收数据\n    3. 把当前计算机绑定一个组播地址\n    4. 将数据接收到箱子中\n    5. 解析数据包,并打印数据\n    6. 释放资源\n\n- 代码实现\n\n  ```java\n  // 发送端\n  public class ClinetDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          String s = \"hello 组播\";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName(\"224.0.1.0\");\n          int port = 10000;\n          // 2. 创建数据，并把数据打包(DatagramPacket)\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n          // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n          ds.send(dp);\n          // 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端Socket对象(MulticastSocket)\n          MulticastSocket ms = new MulticastSocket(10000);\n          // 2. 创建一个箱子,用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.\n          ms.joinGroup(InetAddress.getByName(\"224.0.1.0\"));\n          // 4. 将数据接收到箱子中\n          ms.receive(dp);\n          // 5. 解析数据包,并打印数据\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 6. 释放资源\n          ms.close();\n      }\n  }\n  ```\n\n### 2.6UDP广播实现\n\n- 实现步骤\n\n  - 发送端\n    1. 创建发送端Socket对象(DatagramSocket)\n    2. 创建存储数据的箱子,将广播地址封装进去\n    3. 发送数据\n    4. 释放资源\n  - 接收端\n    1. 创建接收端的Socket对象(DatagramSocket)\n    2. 创建一个数据包，用于接收数据\n    3. 调用DatagramSocket对象的方法接收数据\n    4. 解析数据包，并把数据在控制台显示\n    5. 关闭接收端\n\n- 代码实现\n\n  ```java\n  // 发送端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n        \t// 1. 创建发送端Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n  \t\t// 2. 创建存储数据的箱子,将广播地址封装进去\n          String s = \"广播 hello\";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName(\"255.255.255.255\");\n          int port = 10000;\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n  \t\t// 3. 发送数据\n          ds.send(dp);\n  \t\t// 4. 释放资源\n          ds.close();\n      }\n  }\n  \n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(10000);\n          // 2. 创建一个数据包，用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 调用DatagramSocket对象的方法接收数据\n          ds.receive(dp);\n          // 4. 解析数据包，并把数据在控制台显示\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 5. 关闭接收端\n          ds.close();\n      }\n  }\n  ```\n\n##3. TCP通信程序\n\n### 3.1TCP发送数据\n\n- Java中的TCP通信\n\n  - Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。\n  - Java为客户端提供了Socket类，为服务器端提供了ServerSocket类\n\n- 构造方法\n\n  | 方法名                               | 说明                                           |\n  | ------------------------------------ | ---------------------------------------------- |\n  | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号       |\n  | Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |\n\n- 相关方法\n\n  | 方法名                         | 说明                 |\n  | ------------------------------ | -------------------- |\n  | InputStream  getInputStream()  | 返回此套接字的输入流 |\n  | OutputStream getOutputStream() | 返回此套接字的输出流 |\n\n- 示例代码\n\n  ```java\n  public class Client {\n      public static void main(String[] args) throws IOException {\n          //TCP协议，发送数据\n  \n          //1.创建Socket对象\n          //细节：在创建对象的同时会连接服务端\n          //      如果连接不上，代码会报错\n          Socket socket = new Socket(\"127.0.0.1\",10000);\n  \n          //2.可以从连接通道中获取输出流\n          OutputStream os = socket.getOutputStream();\n          //写出数据\n          os.write(\"aaa\".getBytes());\n  \n          //3.释放资源\n          os.close();\n          socket.close();\n      }\n  }\n  ```\n\n### 3.2TCP接收数据\n\n- 构造方法\n\n  | 方法名                  | 说明                             |\n  | ----------------------- | -------------------------------- |\n  | ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 |\n\n- 相关方法\n\n  | 方法名          | 说明                           |\n  | --------------- | ------------------------------ |\n  | Socket accept() | 监听要连接到此的套接字并接受它 |\n\n- 注意事项\n\n  1. accept方法是阻塞的,作用就是等待客户端连接\n  2. 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接\n  3. 针对客户端来讲,是往外写的,所以是输出流\n     针对服务器来讲,是往里读的,所以是输入流\n  4. read方法也是阻塞的\n  5. 客户端在关流的时候,还多了一个往服务器写结束标记的动作\n  6. 最后一步断开连接,通过四次挥手协议保证连接终止\n\n- 三次握手和四次挥手\n\n  - 三次握手\n\n    ![07_TCP三次握手](/img/07_TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)\n\n  - 四次挥手\n\n    ![08_TCP四次挥手](img/08_TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)\n\n- 示例代码\n\n  ```java\n  public class Server {\n      public static void main(String[] args) throws IOException {\n          //TCP协议，接收数据\n  \n          //1.创建对象ServerSocker\n          ServerSocket ss = new ServerSocket(10000);\n  \n          //2.监听客户端的链接\n          Socket socket = ss.accept();\n  \n          //3.从连接通道中获取输入流读取数据\n          InputStream is = socket.getInputStream();\n          int b;\n          while ((b = is.read()) != -1){\n              System.out.println((char) b);\n          }\n  \n          //4.释放资源\n          socket.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.3TCP程序练习（传输中文）\n\n发送端：\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //TCP协议，发送数据\n\n        //1.创建Socket对象\n        //细节：在创建对象的同时会连接服务端\n        //      如果连接不上，代码会报错\n        Socket socket = new Socket(\"127.0.0.1\",10000);\n\n\n        //2.可以从连接通道中获取输出流\n        OutputStream os = socket.getOutputStream();\n        //写出数据\n        os.write(\"你好你好\".getBytes());//12字节\n\n        //3.释放资源\n        os.close();\n        socket.close();\n\n    }\n}\n\n```\n\n接收端：\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //TCP协议，接收数据\n\n        //1.创建对象ServerSocker\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.监听客户端的链接\n        Socket socket = ss.accept();\n\n        //3.从连接通道中获取输入流读取数据\n        InputStream is = socket.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is);\n        BufferedReader br = new BufferedReader(isr);\n\n        // BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        int b;\n        while ((b = br.read()) != -1){\n            System.out.print((char) b);\n        }\n\n        //4.释放资源\n        socket.close();\n        ss.close();\n\n    }\n}\n```\n\n## 4. 综合练习\n\n### 练习一：多发多收\n\n需求：\n\n​\t客户端：多次发送数据\n\n​\t服务器：接收多次接收数据，并打印\n\n代码示例：\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：多次发送数据\n        //服务器：接收多次接收数据，并打印\n\n        //1. 创建Socket对象并连接服务端\n        Socket socket = new Socket(\"127.0.0.1\",10000);\n\n        //2.写出数据\n        Scanner sc = new Scanner(System.in);\n        OutputStream os = socket.getOutputStream();\n\n        while (true) {\n            System.out.println(\"请输入您要发送的信息\");\n            String str = sc.nextLine();\n            if(\"886\".equals(str)){\n                break;\n            }\n            os.write(str.getBytes());\n        }\n        //3.释放资源\n        socket.close();\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：多次发送数据\n        //服务器：接收多次接收数据，并打印\n\n        //1.创建对象绑定10000端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.等待客户端来连接\n        Socket socket = ss.accept();\n\n        //3.读取数据\n        InputStreamReader isr = new InputStreamReader(socket.getInputStream());\n        int b;\n        while ((b = isr.read()) != -1){\n            System.out.print((char)b);\n        }\n\n        //4.释放资源\n        socket.close();\n        ss.close();\n    }\n}\n```\n\n\n\n### 练习二：接收并反馈\n\n- 案例需求\n\n  客户端：发送数据，接受服务器反馈\n\n  服务器：收到消息后给出反馈\n\n- 案例分析\n\n  - 客户端创建对象，使用输出流输出数据\n  - 服务端创建对象，使用输入流接受数据\n  - 服务端使用输出流给出反馈数据\n  - 客户端使用输入流接受反馈数据\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket(\"127.0.0.1\",10000);\n  \n          OutputStream os = socket.getOutputStream();\n          os.write(\"hello\".getBytes());\n         // os.close();如果在这里关流,会导致整个socket都无法使用\n          socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响\n          \n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine())!=null){\n              System.out.println(line);\n          }\n          br.close();\n          os.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n  \n          Socket accept = ss.accept();\n  \n          InputStream is = accept.getInputStream();\n          int b;\n          while((b = is.read())!=-1){\n              System.out.println((char) b);\n          }\n  \n          System.out.println(\"看看我执行了吗?\");\n  \n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write(\"你谁啊?\");\n          bw.newLine();\n          bw.flush();\n  \n          bw.close();\n          is.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 练习三：上传练习（TCP协议）\n\n- 案例需求\n\n  客户端：数据来自于本地文件，接收服务器反馈\n\n  服务器：接收到的数据写入本地文件，给出反馈\n\n- 案例分析\n\n  - 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束\n  - 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息\n  - 客户端接受服务端的回馈信息\n\n- 相关方法\n\n  | 方法名                | 说明                               |\n  | --------------------- | ---------------------------------- |\n  | void shutdownInput()  | 将此套接字的输入流放置在“流的末尾” |\n  | void shutdownOutput() | 禁止用此套接字的输出流             |\n\n- 代码实现\n\n  ```java\n  public class Client {\n      public static void main(String[] args) throws IOException {\n          //客户端：将本地文件上传到服务器。接收服务器的反馈。\n          //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n  \n  \n          //1. 创建Socket对象，并连接服务器\n          Socket socket = new Socket(\"127.0.0.1\",10000);\n  \n          //2.读取本地文件中的数据，并写到服务器当中\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"mysocketnet\\\\clientdir\\\\a.jpg\"));\n          BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n          byte[] bytes = new byte[1024];\n          int len;\n          while ((len = bis.read(bytes)) != -1){\n              bos.write(bytes,0,len);\n          }\n  \n          //往服务器写出结束标记\n          socket.shutdownOutput();\n  \n  \n          //3.接收服务器的回写数据\n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line = br.readLine();\n          System.out.println(line);\n  \n  \n          //4.释放资源\n          socket.close();\n  \n      }\n  }\n  ```\n\n  ```java\n  public class Server {\n      public static void main(String[] args) throws IOException {\n          //客户端：将本地文件上传到服务器。接收服务器的反馈。\n          //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n  \n  \n          //1.创建对象并绑定端口\n          ServerSocket ss = new ServerSocket(10000);\n  \n          //2.等待客户端来连接\n          Socket socket = ss.accept();\n  \n          //3.读取数据并保存到本地文件中\n          BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"mysocketnet\\\\serverdir\\\\a.jpg\"));\n          int len;\n          byte[] bytes = new byte[1024];\n          while ((len = bis.read(bytes)) != -1){\n              bos.write(bytes,0,len);\n          }\n          bos.close();\n          //4.回写数据\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n          bw.write(\"上传成功\");\n          bw.newLine();\n          bw.flush();\n  \n          //5.释放资源\n          socket.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 练习四：文件名重复\n\n     ```java\npublic class UUIDTest {\n    public static void main(String[] args) {\n        String str = UUID.randomUUID().toString().replace(\"-\", \"\");\n        System.out.println(str);//9f15b8c356c54f55bfcb0ee3023fce8a\n    }\n}\n     ```\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket(\"127.0.0.1\",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"mysocketnet\\\\clientdir\\\\a.jpg\"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.等待客户端来连接\n        Socket socket = ss.accept();\n\n        //3.读取数据并保存到本地文件中\n        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n        String name = UUID.randomUUID().toString().replace(\"-\", \"\");\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"mysocketnet\\\\serverdir\\\\\" + name + \".jpg\"));\n        int len;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read(bytes)) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        bos.close();\n        //4.回写数据\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        bw.write(\"上传成功\");\n        bw.newLine();\n        bw.flush();\n\n        //5.释放资源\n        socket.close();\n        ss.close();\n    }\n}\n```\n\n### 练习五：服务器改写为多线程\n\n服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。\n\n优化方案一：\n\n​\t使用循环\n\n弊端：\n\n​\t第一个用户正在上传数据，第二个用户就来访问了，此时第二个用户是无法成功上传的。\n\n​\t所以，使用多线程改进\n\n优化方案二：\n\n​\t每来一个用户，就开启多线程处理\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket(\"127.0.0.1\",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"mysocketnet\\\\clientdir\\\\a.jpg\"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        while (true) {\n            //2.等待客户端来连接\n            Socket socket = ss.accept();\n\n            //开启一条线程\n            //一个用户就对应服务端的一条线程\n            new Thread(new MyRunnable(socket)).start();\n        }\n\n    }\n}\n\n\npublic class MyRunnable implements Runnable{\n\n    Socket socket;\n\n    public MyRunnable(Socket socket){\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            //3.读取数据并保存到本地文件中\n            BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n            String name = UUID.randomUUID().toString().replace(\"-\", \"\");\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"mysocketnet\\\\serverdir\\\\\" + name + \".jpg\"));\n            int len;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n            }\n            bos.close();\n            //4.回写数据\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bw.write(\"上传成功\");\n            bw.newLine();\n            bw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //5.释放资源\n           if(socket != null){\n               try {\n                   socket.close();\n               } catch (IOException e) {\n                   e.printStackTrace();\n               }\n           }\n        }\n    }\n}\n```\n\n### 练习六：线程池改进\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket(\"127.0.0.1\",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"mysocketnet\\\\clientdir\\\\a.jpg\"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //创建线程池对象\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                3,//核心线程数量\n                16,//线程池总大小\n                60,//空闲时间\n                TimeUnit.SECONDS,//空闲时间（单位）\n                new ArrayBlockingQueue<>(2),//队列\n                Executors.defaultThreadFactory(),//线程工厂，让线程池如何创建线程对象\n                new ThreadPoolExecutor.AbortPolicy()//阻塞队列\n        );\n\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        while (true) {\n            //2.等待客户端来连接\n            Socket socket = ss.accept();\n\n            //开启一条线程\n            //一个用户就对应服务端的一条线程\n            //new Thread(new MyRunnable(socket)).start();\n            pool.submit(new MyRunnable(socket));\n        }\n\n    }\n}\n```\n\n```java\npublic class MyRunnable implements Runnable{\n\n    Socket socket;\n\n    public MyRunnable(Socket socket){\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            //3.读取数据并保存到本地文件中\n            BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n            String name = UUID.randomUUID().toString().replace(\"-\", \"\");\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"mysocketnet\\\\serverdir\\\\\" + name + \".jpg\"));\n            int len;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n            }\n            bos.close();\n            //4.回写数据\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bw.write(\"上传成功\");\n            bw.newLine();\n            bw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //5.释放资源\n           if(socket != null){\n               try {\n                   socket.close();\n               } catch (IOException e) {\n                   e.printStackTrace();\n               }\n           }\n        }\n    }\n}\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"多线程额外扩展","url":"/2023/03/28/多线程（额外扩展）/","content":"# 1 线程状态\n\n## 1.1 状态介绍\n\n当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\n\n```java\npublic class Thread {\n    \n    public enum State {\n    \n        /* 新建 */\n        NEW , \n\n        /* 可运行状态 */\n        RUNNABLE , \n\n        /* 阻塞状态 */\n        BLOCKED , \n\n        /* 无限等待状态 */\n        WAITING , \n\n        /* 计时等待 */\n        TIMED_WAITING , \n\n        /* 终止 */\n        TERMINATED;\n    \n\t}\n    \n    // 获取当前线程的状态\n    public State getState() {\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n    \n}\n```\n\n通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n\n| 线程状态      | 具体含义                                                     |\n| ------------- | ------------------------------------------------------------ |\n| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |\n| RUNNABLE      | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |\n| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |\n| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |\n| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |\n| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态     |\n\n各个状态的转换，如下图所示：\n\n![1571652681276](assets/1571652681276.png) \n\n## 1.2 案例演示\n\n为了验证上面论述的状态即状态转换的正确性，也为了加深对线程状态转换的理解，下面通过三个案例演示线程间中的状态转换。\n\n### 1.2.1 案例一\n\n本案例主要演示TIME_WAITING的状态转换。\n\n需求：编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> TIME_WAITING -> RUNNABLE ->  TERMINATED\n\n为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。\n\n代码实现\n\n```java\npublic class ThreadStateDemo01 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个内部线程\n        Thread thread = new Thread(() -> {\n            System.out.println(\"2.执行thread.start()之后，线程的状态：\" + Thread.currentThread().getState());\n            try {\n                //休眠100毫秒\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"4.执行Thread.sleep(long)完成之后，线程的状态：\" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println(\"1.通过new初始化一个线程，但是还没有start()之前，线程的状态：\" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //休眠50毫秒\n        Thread.sleep(50);\n\n        //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态\n        //用main线程来获取thread1线程的状态，因为thread1线程睡眠时间较长\n        //所以当main线程执行的时候，thread1线程还没有睡醒，还处于计时等待状态\n        System.out.println(\"3.执行Thread.sleep(long)时，线程的状态：\" + thread.getState());\n\n        //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕\n        Thread.sleep(100);\n\n        System.out.println(\"5.线程执行完毕之后，线程的状态：\" + thread.getState() + \"\\n\");\n\n    }\n\n}\n```\n\n控制台输出\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING\n4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### 1.2.2 案例二\n\n本案例主要演示WAITING的状态转换。\n\n需求：编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> WAITING -> RUNNABLE -> TERMINATED\n\n```java\npublic class ThreadStateDemo02 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj = new Object();\n\n        //定义一个内部线程\n        Thread thread1 = new Thread(() -> {\n            System.out.println(\"2.执行thread.start()之后，线程的状态：\" + Thread.currentThread().getState());\n            synchronized (obj) {\n                try {\n\n                    //thread1需要休眠100毫秒\n                    Thread.sleep(100);\n\n                    //thread1100毫秒之后，通过wait()方法释放obj对象是锁\n                    obj.wait();\n                    \n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"4.被object.notify()方法唤醒之后，线程的状态：\" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println(\"1.通过new初始化一个线程，但是还没有start()之前，线程的状态：\" + thread1.getState());\n\n        //启动线程\n        thread1.start();\n\n        //main线程休眠150毫秒\n        Thread.sleep(150);\n\n        //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态\n        System.out.println(\"3.执行object.wait()时，线程的状态：\" + thread1.getState());\n\n        //声明另一个线程进行解锁\n        new Thread(() -> {\n            synchronized (obj) {\n                //唤醒等待的线程\n                obj.notify();\n            }\n        }).start();\n\n        //main线程休眠10毫秒等待thread1线程能够苏醒\n        Thread.sleep(10);\n\n        //获取thread1运行结束之后的状态\n        System.out.println(\"5.线程执行完毕之后，线程的状态：\" + thread1.getState() + \"\\n\");\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.执行object.wait()时，线程的状态：WAITING\n4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n### 1.2.3 案例三\n\n本案例主要演示BLOCKED的状态转换。\n\n需求：编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> BLOCKED -> RUNNABLE -> TERMINATED\n\n```java\npublic class ThreadStateDemo03 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        //定义一个对象，用来加锁和解锁\n        Object obj2 = new Object();\n\n        //定义一个线程，先抢占了obj2对象的锁\n        new Thread(() -> {\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //第一个线程要持有锁100毫秒\n                    obj2.wait();                          //然后通过wait()方法进行等待状态，并释放obj2的对象锁\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n\n        //定义目标线程，获取等待获取obj2的锁\n        Thread thread = new Thread(() -> {\n            System.out.println(\"2.执行thread.start()之后，线程的状态：\" + Thread.currentThread().getState());\n            synchronized (obj2) {\n                try {\n                    Thread.sleep(100);              //thread3要持有对象锁100毫秒\n                    obj2.notify();                        //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"4.阻塞结束后，线程的状态：\" + Thread.currentThread().getState());\n        });\n\n        //获取start()之前的状态\n        System.out.println(\"1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：\" + thread.getState());\n\n        //启动线程\n        thread.start();\n\n        //先等100毫秒\n        Thread.sleep(50);\n\n        //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞\n        System.out.println(\"3.因为等待锁而阻塞时，线程的状态：\" + thread.getState());\n\n        //再等300毫秒\n        Thread.sleep(300);\n\n        //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕\n        System.out.println(\"5.线程执行完毕之后，线程的状态：\" + thread.getState());\n\n    }\n\n}\n\n\n//---------------------代码简化--------------------------------------------\nObject obj = new Object();\n\n        Thread t1 = new Thread(()->{\n            synchronized (obj){\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        t1.start();\n\n\n        Thread t2 = new Thread(()->{\n            System.out.println(\"线程开启之后的状态\" + Thread.currentThread().getState());\n            synchronized (obj){\n                System.out.println(\"进入之后的状态\" + Thread.currentThread().getState());\n            }\n        });\n\n\n\n        System.out.println(\"创建线程对象后,但是不调用start方法的状态\" + t2.getState());\n        t2.start();\n        Thread.sleep(100);\n        System.out.println(t2.getState());\n        Thread.sleep(2000);\n        System.out.println(t2.getState());\n```\n\n控制台输出结果\n\n```java\n1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW\n2.执行thread.start()之后，线程的状态：RUNNABLE\n3.因为等待锁而阻塞时，线程的状态：BLOCKED\n4.阻塞结束后，线程的状态：RUNNABLE\n5.线程执行完毕之后，线程的状态：TERMINATED\n```\n\n通过上面3个案例的代码演示，我们可以证明开始章节说所述的线程状态以及线程状态转换都是正确的。\n\n\n\n# 2 线程池\n\n## 2.1 概述\n\n提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n\n线程池存在的意义：\n\n系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n\n统资源的消耗，这样就有点\"舍本逐末\"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n\n会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n\n## 2.2 自定义线程池\n\n### 2.2.1 线程池的设计思路\n\n线程池的思路和生产者消费者模型是很接近的\n\n1. 准备一个任务容器\n2. 一次性启动多个(2个)消费者线程\n3. 刚开始任务容器是空的，所以线程都在wait\n4. 直到一个外部线程向这个任务容器中扔了一个\"任务\"，就会有一个消费者线程被唤醒\n5. 这个消费者线程取出\"任务\"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来\n\n在整个过程中，都不需要创建新的线程，而是循环使用这些已经存在的线程。\n\n![1571655104091](assets/1571655104091.png) \n\n### 2.2.2 代码实现\n\n实现思路：\n\n- 创建一个线程池类(ThreadPool)\n- 在该类中定义两个成员变量poolSize(线程池初始化线程的个数) , BlockingQueue<Runnable>(任务容器)\n- 通过构造方法来创建两个线程对象(消费者线程)，并且启动\n- 使用内部类的方式去定义一个线程类(TaskThread),可以提供一个构造方法用来初始化线程名称\n- 两个消费者线程需要不断的从任务容器中获取任务，如果没有任务，则线程处于阻塞状态。\n- 提供一个方法(submit)向任务容器中添加任务\n- 定义测试类进行测试\n\n线程池类\n\n```java\npublic class ThreadPool {\n\n    // 初始化线程个数\n    private static final int DEFAULT_POOL_SIZE = 2 ;\n\n    // 在该类中定义两个成员变量poolSize(线程池初始化线程的个数) , BlockingQueue<Runnable>(任务容器)\n    private int poolSize = DEFAULT_POOL_SIZE ;\n    private BlockingQueue<Runnable> blockingQueue = new LinkedBlockingQueue<Runnable>() ;\n\n    // 无参构造方法\n    public ThreadPool(){\n        this.initThread();\n    }\n\n    // 有参构造方法，通过构造方法来创建两个线程对象(消费者线程)，并且启动\n    public ThreadPool(int poolSize) {\n        if(poolSize > 0) {\n            this.poolSize = poolSize ;\n        }\n        this.initThread();\n    }\n\n    // 初始化线程方法\n    public void initThread(){\n        for(int x = 0 ; x < poolSize ; x++) {\n            new TaskThread(\"线程--->\" + x).start();\n        }\n    }\n\n    // 提供一个方法(submit)向任务容器中添加任务\n    public void submit(Runnable runnable) {\n\n        try {\n            blockingQueue.put(runnable);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    // 使用内部类的方式去定义一个线程类\n    public class TaskThread extends Thread {\n\n        // 提供一个构造方法，用来初始化线程名称\n        public TaskThread(String name) {\n            super(name);\n        }\n\n        @Override\n        public void run() {\n\n            while(true) {\n\n                try {\n\n                    // 两个消费者线程需要不断的从任务容器中获取任务，如果没有任务，则线程处于阻塞状态。\n                    Runnable task = blockingQueue.take();\n                    task.run();\n\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n\n        }\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class ThreadPoolDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建线程池对象,无参构造方法创建\n        // ThreadPool threadPool = new ThreadPool();\n        ThreadPool threadPool = new ThreadPool(5);\n\n        // 提交任务\n        for(int x = 0 ; x < 10 ; x++) {\n            threadPool.submit( () -> {\n                System.out.println(Thread.currentThread().getName() + \"---->>>处理了任务\");\n            });\n        }\n\n    }\n\n}\n```\n\n使用无参构造方法创建线程池对象，控制台输出结果\n\n```java\n线程--->0---->>>处理了任务\n线程--->1---->>>处理了任务\n线程--->0---->>>处理了任务\n线程--->1---->>>处理了任务\n线程--->0---->>>处理了任务\n线程--->1---->>>处理了任务\n线程--->0---->>>处理了任务\n线程--->1---->>>处理了任务\n线程--->0---->>>处理了任务\n线程--->1---->>>处理了任务\n```\n\n通过控制台的输出，我们可以看到在线程池中存在两个线程，通过这2个线程处理了10个任务。\n\n使用有参构造方法创建线程池对象，传递的参数是5，控制台输出结果\n\n```\n线程--->3---->>>处理了任务\n线程--->4---->>>处理了任务\n线程--->2---->>>处理了任务\n线程--->0---->>>处理了任务\n线程--->2---->>>处理了任务\n线程--->4---->>>处理了任务\n线程--->3---->>>处理了任务\n线程--->1---->>>处理了任务\n线程--->2---->>>处理了任务\n线程--->0---->>>处理了任务\n```\n\n通过控制台的输出，我们可以看到在线程池中存在两个线程，通过这5个线程处理了10个任务。\n\n## 2.3 JDK中线程池\n\n### 2.3.1 Executors\n\nJDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n\n我们可以使用Executors中所提供的**静态**方法来创建线程池。\n\n<font color=\"blue\" size=\"3\">**获取线程池的方法**</font>：\n\n//通过不同的方法创建出来的线程池具有不同的特点。\n\n```java\nExecutorService newCachedThreadPool(): \t\t\t\t创建一个可缓存线程池，可灵活的去创建线程，并且灵活的回收线程，若无可回收，则新建线程。\nExecutorService newFixedThreadPool(int nThreads): \t初始化一个具有固定数量线程的线程池\nExecutorService newSingleThreadExecutor(): \t\t\t初始化一个具有一个线程的线程池\n\t\t\t\t\t\t\t\t\t//做完一个，再做一个，不停歇，直到做完，老黄牛性格\nScheduledExecutorService newSingleThreadScheduledExecutor(): 初始化一个具有一个线程的线程池，支持定时及周期性任务执行\n\t\t\t\t\t\t\t\t\t//按照固定的计划去执行线程，一个做完之后按照计划再做另一个\n```\n\n这个方法返回的都是ExecutorService类型的对象(ScheduledExecutorService继承ExecutorService),而ExecutorService可以看做就是一个线程池，那么ExecutorService\n\n给我们提供了哪些方法供我们使用呢？\n\n<font color=\"blue\" size=\"3\">**ExecutorService中的常见方法**</font>：\n\n```java\nFuture<?> submit(Runnable task)：\t提交任务方法\nvoid shutdown()：\t\t\t\t\t关闭线程池的方法\t\n```\n\n\n\n<font color=\"blue\" size=\"3\">**案例1**</font>：演示newCachedThreadPool方法所获取到的线程池的特点\n\n测试类\n\n```java\npublic class ExecutorsDemo01 {\n\n    // 演示Executors中的newCachedThreadPool返回的线程池的特点\n    public static void main(String[] args) throws InterruptedException {\n\n        // 获取线程池对象\n        ExecutorService threadPool = Executors.newCachedThreadPool();\n\n        // 提交任务\n        threadPool.submit(() -> {\n            System.out.println( Thread.currentThread().getName() + \"---执行了任务\");\n        });\n\n        // 提交任务\n        threadPool.submit(() -> {\n            System.out.println( Thread.currentThread().getName() + \"---执行了任务\");\n        });\n\n        // 不使用线程池了，还可以将线程池关闭\n        threadPool.shutdown();\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-2---执行了任务\npool-1-thread-1---执行了任务\n```\n\n针对每一个任务，线程池为其分配一个线程去执行，我们可以在第二次提交任务的时候，让主线程休眠一小会儿，看程序的执行结果。\n\n```java\npublic class ExecutorsDemo02 {\n\n    // 演示Executors中的newCachedThreadPool返回的线程池的特点\n    public static void main(String[] args) throws InterruptedException {\n\n        // 获取线程池对象\n        ExecutorService threadPool = Executors.newCachedThreadPool();\n\n        // 提交任务\n        threadPool.submit(() -> {\n            System.out.println( Thread.currentThread().getName() + \"---执行了任务\");\n        });\n\n        // 线程休眠2秒，主线程休眠2秒，此时之前提交的任务应该已经执行完毕\n        TimeUnit.SECONDS.sleep(2);\n\n        // 提交任务\n        threadPool.submit(() -> {\n            System.out.println( Thread.currentThread().getName() + \"---执行了任务\");\n        });\n\n        // 不使用线程池了，还可以将线程池关闭\n        threadPool.shutdown();\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-1---执行了任务\npool-1-thread-1---执行了任务\n```\n\n我们发现是通过一个线程执行了两个任务。此时就说明线程池中的线程\"pool-1-thread-1\"被线程池回收了，成为了空闲线程，当我们再次提交任务的时候，该线程就去执行新的任务。\n\n\n\n<font color=\"blue\" size=\"3\">**案例2**</font>：演示newFixedThreadPool方法所获取到的线程池的特点\n\n测试类\n\n```java\npublic class ExecutorsDemo03 {\n\n    // 演示newFixedThreadPool方法所获取到的线程池的特点\n    public static void main(String[] args) {\n\n        // 获取线程池对象,初始化一个具有固定数量线程的线程池\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);  // 在该线程池中存在3个线程\n\n        // 提交任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPool.submit( () -> {\n                System.out.println(Thread.currentThread().getName() + \"----->>>执行了任务\" );\n            });\n        }\n\n        // 关闭线程池\n        threadPool.shutdown();\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-1----->>>执行了任务\npool-1-thread-2----->>>执行了任务\npool-1-thread-2----->>>执行了任务\npool-1-thread-2----->>>执行了任务\npool-1-thread-3----->>>执行了任务\n```\n\n通过控制台的输出结果，我们可以看到5个任务是通过3个线程进行执行的，说明此线程池中存在三个线程对象\n\n\n\n<font color=\"blue\" size=\"3\">**案例3**</font>：演示newSingleThreadExecutor方法所获取到的线程池的特点\n\n测试类\n\n```java\npublic class ExecutorsDemo04 {\n\n    // 演示newSingleThreadExecutor方法所获取到的线程池的特点\n    public static void main(String[] args) {\n\n        // 获取线程池对象,初始化一个具有一个线程的线程池\n        ExecutorService threadPool = Executors.newSingleThreadExecutor();\n\n        // 提交任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPool.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"----->>>执行了任务\");\n            });\n        }\n\n        // 关闭线程池\n        threadPool.shutdown();\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-1----->>>执行了任务\npool-1-thread-1----->>>执行了任务\npool-1-thread-1----->>>执行了任务\npool-1-thread-1----->>>执行了任务\npool-1-thread-1----->>>执行了任务\n```\n\n通过控制台的输出结果，我们可以看到5个任务是通过1个线程进行执行的,说明此线程池中只存在一个线程对象。\n\n\n\n<font color=\"blue\" size=\"3\">**案例4**</font>： 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(初始化一个具有一个线程的线程池)\n\n测试类\n\n```java\npublic class ExecutorsDemo05 {\n\n    // 演示：newSingleThreadScheduledExecutor方法所获取到的线程池的第一个特点(初始化一个具有一个线程的线程池)\n    public static void main(String[] args) {\n\n        // 获取线程池对象\n        ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();\n\n        // 提交任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPool.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->>执行了任务\");\n            });\n        }\n\n        // 关闭线程池\n        threadPool.shutdown();\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-1---->>执行了任务\npool-1-thread-1---->>执行了任务\npool-1-thread-1---->>执行了任务\npool-1-thread-1---->>执行了任务\npool-1-thread-1---->>执行了任务\n```\n\n通过控制台的输出结果，我们可以看到5个任务是通过1个线程进行执行的,说明此线程池中只存在一个线程对象。\n\n\n\n<font color=\"blue\" size=\"3\">**案例5**</font>： 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行)\n\nScheduledExecutorService中和定时以及周期性执行相关的方法\n\n```java\n/*\n\t定时执行\n\tcommand: 任务类对象\n\tdelay  : 延迟多长时间开始执行任务, 任务提交到线程池以后我们需要等待多长时间开始执行这个任务\n\tunit   : 指定时间操作单元\n*/\npublic ScheduledFuture<?> schedule(Runnable command,long delay, TimeUnit unit);\n\n/*\n\t周期性执行\n\tcommand: \t\t任务类对象\n\tinitialDelay: \t延迟多长时间开始第一次该执行任务, 任务提交到线程池以后我们需要等待多长时间开始第一次执行这个任务\n\tperiod:        \t下一次执行该任务所对应的时间间隔\n\tunit: \t\t\t指定时间操作单元\n*/\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);\n```\n\n测试类1(演示定时执行)\n\n```java\npublic class ExecutorsDemo06 {\n\n    // 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行)\n    public static void main(String[] args) {\n\n        // 获取线程池对象\n        ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();\n\n        // 提交任务,10s以后开始执行该任务\n        threadPool.schedule( () -> {\n            System.out.println(Thread.currentThread().getName() + \"---->>>执行了该任务\");\n        } , 10 , TimeUnit.SECONDS) ;\n\n        // 关闭线程池\n        threadPool.shutdown();\n    }\n\n}\n```\n\n测试类2(演示周期性执行)\n\n```java\npublic class ExecutorsDemo07 {\n\n    // 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行)\n    public static void main(String[] args) {\n\n        // 获取线程池对象\n        ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor();\n\n        // 提交任务,10s以后开始第一次执行该任务，然后每隔1秒执行一次\n        threadPool.scheduleAtFixedRate( () -> {\n            System.out.println(Thread.currentThread().getName() + \"---->>>执行了该任务\");\n        } , 10 ,1, TimeUnit.SECONDS) ;\n\n    }\n\n}\n```\n\n### 2.3.2 ThreadPoolExecutor\n\n#### 1) 基本使用\n\n刚才我们是通过Executors中的静态方法去创建线程池的，通过查看源代码我们发现，其底层都是通过ThreadPoolExecutor构建的。比如：newFixedThreadPool方法的源码\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    \n    // 创建了ThreadPoolExecutor对象，然后直接返回\n\treturn new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());\n}\n```\n\n那么也可以使用ThreadPoolExecutor去创建线程池。\n\nThreadPoolExecutor最完整的构造方法：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n```\n\n参数说明\n\n```java\ncorePoolSize：   核心线程的最大值，不能小于0\nmaximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize\nkeepAliveTime：  空闲线程最大存活时间,不能小于0\nunit：           时间单位\nworkQueue：      任务队列，不能为null\nthreadFactory：  创建线程工厂,不能为null      \nhandler：        任务的拒绝策略,不能为null    \n```\n\n案例演示通过ThreadPoolExecutor创建线程池\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    // 演示基本使用\n    public static void main(String[] args) {\n\n        // 通过ThreadPoolExecutor创建一个线程池对象\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 60 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<Runnable>(3) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        /**\n         * 以上代码表示的意思是：核心线程池中的线程数量最大为1,整个线程池中最多存在3个线程,空闲线程最大的存活时间为60,时间单位为秒,阻塞队列使用的是有界阻塞队列\n         * 容量为3,使用默认的线程工厂;以及默认的任务处理策略\n         */\n\n        // 提交任务\n        threadPoolExecutor.submit( () -> {\n            System.out.println(Thread.currentThread().getName() + \"------>>>执行了任务\");\n        });\n\n        // 关闭线程池\n        threadPoolExecutor.shutdown();\n\n    }\n\n}\n```\n\n#### 2) 工作原理\n\n接下来我们就来研究一下线程池的工作原理，如下图所示\n\n![1571732060388](assets/1571732060388.png) \n\n\n\n当我们通过submit方法向线程池中提交任务的时候，具体的工作流程如下：\n\n1. 客户端每次提交一个任务，线程池就会在核心线程池中创建一个工作线程来执行这个任务。当核心线程池中的线程已满时，则进入下一步操作。\n2. 把任务试图存储到工作队列中。如果工作队列没有满，则将新提交的任务存储在这个工作队列里，等待核心线程池中的空闲线程执行。如果工作队列满了，则进入下个流程。\n3. 线程池会再次在非核心线程池区域去创建新工作线程来执行任务，直到当前线程池总线程数量超过最大线程数时，就是按照指定的任务处理策略处理多余的任务。\n\n\n\n举例说明：\n\n假如有一个工厂，工厂里面有10个工人(正式员工)，每个工人同时只能做一件任务。因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；当10个工人都有任务在做时，\n\n如果还来了任务，就把任务进行排队等待；如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；然后就将任务也分配\n\n给这4个临时工人做；如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。当这14个工人当中有人空闲时，而新任务增长的速度\n\n又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。\n\n\n\n这里的工厂可以看做成是一个线程池，每一个工人可以看做成是一个线程。其中10个正式员工，可以看做成是核心线程池中的线程，临时工就是非核心线程池中的线程。当临时工处于空闲状态\n\n的时候，那么如果空闲的时间超过keepAliveTime所指定的时间，那么就会被销毁。\n\n\n\n#### 3) 案例演示\n\n接下来我们就通过一段代码的断点测试，来演示一下线程池的工作原理。\n\n案例代码\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交3个任务，此时会产生一个核心线程,一个临时工线程，队列中会存在一个任务，20s后临时工线程被回收，核心线程不会被回收\n        for(int x = 0 ; x < 3 ; x++) {\n            threadPoolExecutor.submit(() -> {\t\t// 断点位置\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\");\n            });\n        }\n\n    }\n\n}\n```\n\n初次debug方式启动线程，查看变量值\n\n![1571735388181](assets/1571735388181.png) \n\n由于此时还没有提交任务，因此线程池中的线程数量为0，工作队列的任务数量也为0；提交一个任务\n\n![1571735465100](assets/1571735465100.png) \n\n再次查看各个值的变化\n\n![1571735607347](assets/1571735607347.png) \n\n再次提交一个任务\n\n![1571735465100](assets/1571735465100.png) \n\n再次查看各个值的变化\n\n![1571735715977](assets/1571735715977.png) \n\n此时会把第二个任务存储到工作队列中，因此工作队列的值为1了。再次提交一个任务\n\n![1571735465100](assets/1571735465100.png) \n\n再次查看各个值的变化\n\n![1571735904991](assets/1571735904991.png) \n\n此时3个任务都以及提交完毕，断点跳过。经过20s以后，再次查看该进程中的线程。\n\n![1571736824748](assets/1571736824748.png) \n\n我们发现非核心线程已经被线程池回收了。\n\n#### 4) 任务拒绝策略\n\nRejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\n\n```java\nThreadPoolExecutor.AbortPolicy: \t\t    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。\nThreadPoolExecutor.DiscardPolicy： \t\t   丢弃任务，但是不抛出异常 这是不推荐的做法。\nThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。\nThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。\n```\n\n注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n\n\n\n<font color=\"blue\" size=\"3\">**案例演示1**</font>：演示ThreadPoolExecutor.AbortPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\");\n            });\n        }\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\nException in thread \"main\" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@566776ad[Not completed, task = java.util.concurrent.Executors$RunnableAdapter@edf4efb[Wrapped task = com.itheima.javase.thread.pool.demo04.ThreadPoolExecutorDemo01$$Lambda$14/0x0000000100066840@2f7a2457]] rejected from java.util.concurrent.ThreadPoolExecutor@6108b2d7[Running, pool size = 3, active threads = 3, queued tasks = 1, completed tasks = 0]\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)\n\tat java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:118)\n\tat com.itheima.javase.thread.pool.demo04.ThreadPoolExecutorDemo01.main(ThreadPoolExecutorDemo01.java:20)\npool-1-thread-1---->> 执行了任务\npool-1-thread-3---->> 执行了任务\npool-1-thread-2---->> 执行了任务\npool-1-thread-3---->> 执行了任务\n```\n\n控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n<font color=\"blue\" size=\"3\">**案例演示2**</font>：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\");\n            });\n        }\n\n    }\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-1---->> 执行了任务\npool-1-thread-1---->> 执行了任务\npool-1-thread-3---->> 执行了任务\npool-1-thread-2---->> 执行了任务\n```\n\n控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n<font color=\"blue\" size=\"3\">**案例演示3**</font>：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n\n            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰\n            final int y = x ;\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\" + y);\n            });\n            \n        }\n\n    }\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-2---->> 执行了任务2\npool-1-thread-1---->> 执行了任务0\npool-1-thread-3---->> 执行了任务3\npool-1-thread-1---->> 执行了任务4\n```\n\n由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n\n\n\n<font color=\"blue\" size=\"3\">**案例演示4**</font>：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo04 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\");\n            });\n\n        }\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\npool-1-thread-1---->> 执行了任务\npool-1-thread-3---->> 执行了任务\npool-1-thread-2---->> 执行了任务\npool-1-thread-1---->> 执行了任务\nmain---->> 执行了任务\n```\n\n通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n\n\n\n# 3 volatile关键字\n\n## 3.1 看程序说结果\n\n分析如下程序，说出在控制台的输出结果。\n\nThread的子类\n\n```java\npublic class VolatileThread extends Thread {\n\n    // 定义成员变量\n    private boolean flag = false ;\n    public boolean isFlag() { return flag;}\n\n    @Override\n    public void run() {\n\n        // 线程休眠1秒\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 将flag的值更改为true\n        this.flag = true ;\n        System.out.println(\"flag=\" + flag);\n\n    }\n}\n```\n\n测试类\n\n```java\npublic class VolatileThreadDemo01 {\n    \n    public static void main(String[] args) {\n\n        // 创建VolatileThread线程对象\n        VolatileThread volatileThread = new VolatileThread() ;\n        volatileThread.start();\n\n        // 在main线程中获取开启的线程中flag的值\n        while(true) {\n            System.out.println(\"main线程中获取开启的线程中flag的值为\" + volatileThread.isFlag());\n        }\n        \n    }\n}\n```\n\n控制台输出结果\n\n```java\n前面是false，过了一段时间之后就变成了true\n```\n\n按照我们的分析，当我们把volatileThread线程启动起来以后，那么volatileThread线程开始执行。在volatileThread线程的run方法中，线程休眠1s，休眠一秒以后那么flag的值应该为\n\ntrue，此时我们在主线程中不停的获取flag的值。发现前面释放false，后面是true\n\n信息，那么这是为什么呢？要想知道原因，那么我们就需要学习一下JMM。\n\n## 3.2 JMM\n\n概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。\n\nJava内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。\n\n特点：\n\n1. 所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。\n\n2. 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。\n\n3. 线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主\n\n   内存完成。\n\n![1571743818653](assets/1571743818653.png) \n\n## 3.3 问题分析\n\n了解了一下JMM,那么接下来我们就来分析一下上述程序产生问题的原因。\n\n![1571744627663](assets/1571744627663.png)  \n\n产生问题的流程分析：\n\n1. VolatileThread线程从主内存读取到数据放入其对应的工作内存\n\n2. 将flag的值更改为true，但是这个时候flag的值还没有回写主内存\n\n3. 此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false\n\n4. VolatileThread线程将flag的值写回到主内存，但是main函数里面的while(true)调用的是系统比较底层的代码，速度快，快到没有时间再去读取主内存中的值，所以while(true)\n\n   读取到的值一直是false。(如果有一个时刻main线程从主内存中读取到了flag的最新值，那么if语句就可以执行，main线程何时从主内存中读取最新的值，我们无法控制)\n\n我们可以让主线程执行慢一点，执行慢一点以后，在某一个时刻，可能就会读取到主内存中最新的flag的值，那么if语句就可以进行执行。\n\n测试类\n\n```java\npublic class VolatileThreadDemo02 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // 创建VolatileThread线程对象\n        VolatileThread volatileThread = new VolatileThread() ;\n        volatileThread.start();\n\n        // main方法\n        while(true) {\n            if(volatileThread.isFlag()) {\n                System.out.println(\"执行了======\");\n            }\n\n            // 让线程休眠100毫秒\n            TimeUnit.MILLISECONDS.sleep(100);\n        }\n\n    }\n}\n```\n\n控制台输出结果\n\n```java\nflag=true\n执行了======\n执行了======\n执行了======\n....\n```\n\n此时我们可以看到if语句已经执行了。当然我们在真实开发中可能不能使用这种方式来处理这个问题，那么这个问题应该怎么处理呢？我们就需要学习下一小节的内容。\n\n## 3.4 问题处理\n\n### 3.4.1 加锁\n\n第一种处理方案，我们可以通过加锁的方式进行处理。\n\n测试类\n\n```java\npublic class VolatileThreadDemo03 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // 创建VolatileThread线程对象\n        VolatileThread volatileThread = new VolatileThread() ;\n        volatileThread.start();\n\n        // main方法\n        while(true) {\n\n            // 加锁进行问题处理\n            synchronized (volatileThread) {\n                if(volatileThread.isFlag()) {\n                    System.out.println(\"执行了======\");\n                }\n            }\n\n        }\n\n    }\n}\n```\n\n控制台输出结果\n\n```java\nflag=true\n执行了======\n执行了======\n执行了======\n....\n```\n\n\n\n工作原理说明\n\n对上述代码加锁完毕以后，某一个线程支持该程序的过程如下：\n\na.线程获得锁\n\nb.清空工作内存\n\nc.从主内存拷贝共享变量最新的值到工作内存成为副本\n\nd.执行代码\n\ne.将修改后的副本的值刷新回主内存中\n\nf.线程释放锁\n\n### 3.4.2 volatile关键字\n\n第二种处理方案，我们可以通过volatile关键字来修饰flag变量。\n\n线程类\n\n```java\npublic class VolatileThread extends Thread {\n\n    // 定义成员变量\n    private volatile boolean flag = false ;\n    public boolean isFlag() { return flag;}\n\n    @Override\n    public void run() {\n\n        // 线程休眠1秒\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 将flag的值更改为true\n        this.flag = true ;\n        System.out.println(\"flag=\" + flag);\n\n    }\n}\n//--------------------------------更新之后的案例-------------------------------------------\npublic class VolatileTest extends Thread{\n    boolean flag = false;\n    int i = 0;\n\n    public void run() {\n        while (!flag) {\n            i++;\n        }\n        System.out.println(\"stope\" + i);\n    }\n\n    public static void main(String[] args) throws Exception {\n        VolatileTest vt = new VolatileTest();\n        vt.start();\n\n        Thread.sleep(10);\n        vt.flag = true;\n\n    }\n}\n```\n\n控制台输出结果\n\n```java\nflag=true\n执行了======\n执行了======\n执行了======\n....\n```\n\n\n\n工作原理说明\n\n![1571746088704](assets/1571746088704.png) \n\n执行流程分析\n\n1. VolatileThread线程从主内存读取到数据放入其对应的工作内存\n2. 将flag的值更改为true，但是这个时候flag的值还没有回写主内存\n3. 此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false\n4. VolatileThread线程将flag的值写到主内存\n5. main线程工作内存中的flag变量副本失效\n6. main线程再次使用flag时，main线程会从主内存读取最新的值，放入到工作内存中，然后在进行使用\n\n\n\n总结： volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。\n\n​      但是volatile不保证原子性(关于原子性问题，我们在下面的小节中会介绍)。\n\n\n\nvolatile与synchronized的区别：\n\n1. volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。\n\n2. volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他（互斥）的机制(因此有时我们也将synchronized这种锁称\n\n   之为排他（互斥）锁)，synchronized修饰的代码块，被修饰的代码块称之为同步代码块，无法被中断可以保证原子性，也可以间接的保证可见性。\n\n\n\n# 4 原子性\n\n概述：所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n\n//比如说：你喂你女朋友吃冰淇淋，如果没有女朋友，你就假想一下，实在不行，你就喂你旁边的哥们吃一口冰淇淋。这就是一个不可分割的整体，一个是你喂，一个是她吃。这就是一个整体，如果没有她吃，那么你喂就没有意义，如果没有你喂，她吃就没有意义。\n\n//比如：从张三的账户给李四的账户转1000元，这个动作将包含两个基本的操作：从张三的账户扣除1000元，给李四的账户增加1000元。这两个操作必须符合原子性的要求，要么都成功要么\n\n都失败。\n\n## 4.1 看程序说结果\n\n分析如下程序的执行结果\n\n线程类\n\n```java\npublic class VolatileAtomicThread implements Runnable {\n\n    // 定义一个int类型的变量\n    private int count = 0 ;\n\n    @Override\n    public void run() {\n        \n        // 对该变量进行++操作，100次\n        for(int x = 0 ; x < 100 ; x++) {\n            count++ ;\t\t\t\t\t\n            System.out.println(\"冰淇淋的个数 =========>>>> \" + count);\n        }\n        \n    }\n\n}\n```\n\n测试类\n\n```java\npublic class VolatileAtomicThreadDemo {\n\n    public static void main(String[] args) {\n\n        // 创建VolatileAtomicThread对象\n        VolatileAtomicThread volatileAtomicThread = new VolatileAtomicThread() ;\n\n        // 开启100个线程对count进行++操作\n        for(int x = 0 ; x < 100 ; x++) {\n            new Thread(volatileAtomicThread).start();\n        }\n        \n    }\n\n}\n```\n\n程序分析：我们在主线程中通过for循环启动了100个线程，每一个线程都会对VolatileAtomicThread类中的count加100次。那么直接结果应该是10000。但是真正的执行结果和我们分析\n\n的是否一样呢？运行程序(多运行几次)，查看控制台输出结果\n\n```java\n....\ncount =========>>>> 9997\ncount =========>>>> 9998\ncount =========>>>> 9999\n```\n\n通过控制台的输出，我们可以看到最终count的结果可能并不是10000。接下来我们就来分析一下问题产生的原因。\n\n## 4.2 问题分析说明\n\n以上问题主要是发生在count++操作上：\n\ncount++操作包含3个步骤：\n\n- 从主内存中读取数据到工作内存\n- 对工作内存中的数据进行++操作\n- 将工作内存中的数据写回到主内存\n\ncount++操作不是一个原子性操作，也就是说在某一个时刻对某一个操作的执行，有可能被其他的线程打断。\n\n![1571794778139](assets/1571794778139.png) \n\n产生问题的执行流程分析：\n\n1. 假设此时count的值是100，线程A需要对改变量进行自增1的操作，首先它需要从主内存中读取变量count的值。由于CPU的切换关系，此时CPU的执行权被切换到了B线程。A线程就处\n\n   于就绪状态，B线程处于运行状态。\n\n2. 线程B也需要从主内存中读取count变量的值,由于线程A没有对count值做任何修改因此此时B读取到的数据还是100\n\n3. 线程B工作内存中对count执行了+1操作，但是未刷新之主内存中\n\n4. 此时CPU的执行权切换到了A线程上，由于此时线程B没有将工作内存中的数据刷新到主内存，因此A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作。\n\n5. 线程B将101写入到主内存\n6. 线程A将101写入到主内存\n\n虽然计算了2次，但是只对A进行了1次修改。\n\n## 4.3 volatile原子性测试\n\n我们刚才说到了volatile在多线程环境下只保证了共享变量在多个线程间的可见性，但是不保证原子性。那么接下来我们就来做一个测试。测试的思想，就是使用volatile修饰count。\n\n线程类\n\n```java\npublic class VolatileAtomicThread implements Runnable {\n\n    // 定义一个int类型的变量,并且使用volatile修饰\n    private volatile int count = 0 ;\n\n    @Override\n    public void run() {\n        \n        // 对该变量进行++操作，100次\n        for(int x = 0 ; x < 100 ; x++) {\n            count++ ;\t\t\t\t\t\n            System.out.println(\"count =========>>>> \" + count);\n        }\n        \n    }\n\n}\n```\n\n控制台输出结果(需要运行多次)\n\n```java\n...\ncount =========>>>> 9997\ncount =========>>>> 9998\ncount =========>>>> 9999\n```\n\n通过控制台结果的输出，我们可以看到程序还是会出现问题。因此也就证明volatile关键字是不保证原子性的。\n\n## 4.4 volatile使用场景\n\nvolatile关键字不保证原子性操作，那么同学们可能会存在一些疑问，volatile关键字在什么情况下进行使用呢？这里我们举两个基本的使用场景。\n\n### 4.4.1 状态标志\n\n比如现在存在一个线程不断向控制台输出一段话\"传智播客中国IT教育的标杆....\",当这个线程执行5秒以后，将该线程结束。\n\n实现思路：定义一个boolean类型的变量，这个变量就相当于一个标志。当这个变量的值为true的时候，线程一直执行，10秒以后我们把这个变量的值更改为false，此时结束该线程的执行。\n\n为了保证一个线程对这个变量的修改，另外一个线程立马可以看到，这个变量就需要通过volatile关键字进行修饰。\n\n线程类\n\n```java\npublic class VolatileUseThread implements Runnable {\n\n    // 定义标志变量\n    private volatile boolean shutdown = false ;\n\n    @Override\n    public void run() {\n\n        while(!shutdown) {\n            System.out.println(\"传智播客中国IT教育的标杆....\");\n        }\n\n    }\n\n    // 关闭线程\n    public void shutdown() {\n        this.shutdown = true ;\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class VolatileUseThreadDemo01 {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // 创建线程任务类对象\n        VolatileUseThread volatileUseThread = new VolatileUseThread() ;\n\n        // 创建线程对象\n        Thread thread = new Thread(volatileUseThread);\n\n        // 启动线程\n        thread.start();\n\n        // 主线程休眠\n        TimeUnit.SECONDS.sleep(5);\n\n        // 关闭线程\n        volatileUseThread.shutdown();\n\n    }\n\n}\n```\n\n观察控制台输出，volatileUseThread线程执行5秒以后程序结束。\n\n### 4.4.2 独立观察\n\n//AI养猪。。。。\n\n//设备区测量温度\n\n//当温度高了。。。需要给猪开空调。。。加冰棍。。。加喝的水。。。\n\n\n\nvolatile的另一种简单使用场景是：定期\"发布\"观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器数据，并更新包\n\n含这个volatile变量的值。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。这种使用就是多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读。\n\n我们可以设计一个程序，模拟上面的温度传感器案例。\n\n实现步说明\n\n1. 定义一个温度传感器(TemperatureSensor)的类,在该类中定义两个成员变量(temperature(温度值)，type(传感器的类型))，temperature变量需要被volatile修饰\n2. 定义一个读取温度传感器的线程的任务类(ReadTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要读取温度传感器的数据)\n3. 定义一个定时采集温度的线程任务类(GatherTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要将读到的温度设置给传感器)\n\n4. 创建测试类(TemperatureSensorDemo)\n   1. 创建TemperatureSensor对象\n   2. 创建ReadTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来\n   3. 创建GatherTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来\n   4. 创建2个Thread对象，并启动，把第二步所创建的对象作为构造方法参数传递过来，这两个线程负责读取TemperatureSensor中的温度数据\n   5. 创建1个Thread对象，并启动，把第三步所创建的对象作为构造方法参数传递过来，这个线程负责读取定时采集数据中的温度数据\n\nTemperatureSensor类\n\n```java\npublic class TemperatureSensor {        // 温度传感器类\n\n    private volatile int temperature ;  // 温度值\n\n    private String type ;               // 传感器的类型\n\n    public int getTemperature() {\n        return temperature;\n    }\n\n    public void setTemperature(int temperature) {\n        this.temperature = temperature;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n}\n```\n\nReadTemperatureRunnable类\n\n```java\npublic class ReadTemperatureRunnable implements Runnable {\n\n    // 温度传感器\n    private TemperatureSensor temperatureSensor ;\n    public ReadTemperatureRunnable(TemperatureSensor temperatureSensor) {\n        this.temperatureSensor = temperatureSensor ;\n    }\n\n    @Override\n    public void run() {\n\n        // 不断的读取温度传感器中的数据\n        while(true) {\n\n            // 读取数据\n            System.out.println(Thread.currentThread().getName() + \"---读取到的温度数据为------>>> \" + temperatureSensor.getTemperature());\n\n            try {\n                // 让线程休眠100毫秒，便于观察\n                TimeUnit.MILLISECONDS.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n    }\n\n}\n```\n\nGatherTemperatureRunnable类\n\n```java\npublic class GatherTemperatureRunnable implements Runnable {\n\n    // 温度传感器\n    private TemperatureSensor temperatureSensor ;\n    public GatherTemperatureRunnable(TemperatureSensor temperatureSensor) {\n        this.temperatureSensor = temperatureSensor ;\n    }\n\n    @Override\n    public void run() {\n\n        // 定义一个变量，表示环境初始温度\n        int temperature = 23 ;\n\n        // 不断进行数据采集\n        while(true) {\n\n            // 将采集到的数据设置给温度传感器\n            System.out.println(Thread.currentThread().getName() + \"-----采集到的数据为----->>> \" + temperature);\n            temperatureSensor.setTemperature(temperature);\n\n            try {\n                // 线程休眠2秒,模拟每隔两秒采集一次数据\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            // 环境温度改变\n            temperature += 2 ;\n\n        }\n\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class TemperatureSensorDemo {\n\n    public static void main(String[] args) {\n\n        // 创建TemperatureSensor对象\n        TemperatureSensor temperatureSensor = new TemperatureSensor();\n\n        // 创建ReadTemperatureRunnable类对象\n        ReadTemperatureRunnable readTemperatureRunnable = new ReadTemperatureRunnable(temperatureSensor) ;\n\n        // 创建GatherTemperatureRunnable类对象\n        GatherTemperatureRunnable gatherTemperatureRunnable = new GatherTemperatureRunnable(temperatureSensor) ;\n\n        // 创建2个Thread对象，并启动; 这两个线程负责读取TemperatureSensor中的温度数据\n        for(int x = 0 ; x < 2 ; x++) {\n            new Thread(readTemperatureRunnable).start();\n        }\n\n        // 创建1个Thread对象，并启动，这个线程负责读取定时采集数据中的温度数据\n        Thread gatherThread = new Thread(gatherTemperatureRunnable);\n        gatherThread.setName(\"温度采集线程\");\n        gatherThread.start();\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\n...\n温度采集线程-----采集到的数据为----->>> 23\nThread-0---读取到的温度数据为------>>> 23\n...\n温度采集线程-----采集到的数据为----->>> 25\nThread-1---读取到的温度数据为------>>> 25\n...\n```\n\n通过控制台的输出，我们可以看到当温度采集线程刚采集到环境温度以后，那么此时两个温度读取线程就可以立即感知到环境温度的变化。\n\n## 4.5 问题处理\n\n接下来我们就来讲解一下我们上述案例(引入原子性问题的案例)的解决方案。\n\n### 4.5.1 锁机制\n\n我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\n\n线程任务类\n\n```java\npublic class VolatileAtomicThread implements Runnable {\n\n    // 定义一个int类型的变量,\n    private int count = 0 ;\n\n    // 定义一个Object类型的变量，该变量将作为同步代码块的锁\n    private Object obj = new Object();\n\n    @Override\n    public void run() {\n        \n        // 对该变量进行++操作，100次\n        for(int x = 0 ; x < 100 ; x++) {\n            synchronized (obj){\n                count++ ;\n                System.out.println(\"count =========>>>> \" + count);\n            }\n\n        }\n        \n    }\n\n}\n```\n\n控制台输出结果\n\n```java\ncount =========>>>> 9998\ncount =========>>>> 9999\ncount =========>>>> 10000\n```\n\n### 4.5.2 原子类\n\n#### 1) AtomicInteger\n\n概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\n\nAtomicBoolean： 原子更新布尔类型\n\nAtomicInteger： 原子更新整型\n\nAtomicLong：\t原子更新长整型\n\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\n\n```java\npublic AtomicInteger()：\t   \t\t\t\t初始化一个默认值为0的原子型Integer\npublic AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n\nint get():   \t\t\t \t\t\t\t 获取值\nint getAndIncrement():      \t\t\t 以原子方式将当前值加1，注意，这里返回的是自增前的值。\nint incrementAndGet():     \t\t\t\t 以原子方式将当前值加1，注意，这里返回的是自增后的值。\nint addAndGet(int data):\t\t\t\t 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。\nint getAndSet(int value):   \t\t\t 以原子方式设置为newValue的值，并返回旧值。\n```\n\n案例演示AtomicInteger的基本使用：\n\n```java\npublic class AtomicIntegerDemo01 {\n\n    // 原子型Integer\n    public static void main(String[] args) {\n\n        // 构造方法\n        // public AtomicInteger()：初始化一个默认值为0的原子型Integer\n        // AtomicInteger atomicInteger = new AtomicInteger() ;\n        // System.out.println(atomicInteger);\n\n        // public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n        AtomicInteger atomicInteger = new AtomicInteger(5) ;\n        System.out.println(atomicInteger);\n\n        // 获取值\n        System.out.println(atomicInteger.get());\n\n        // 以原子方式将当前值加1，这里返回的是自增前的值\n        System.out.println(atomicInteger.getAndIncrement());\n        System.out.println(atomicInteger.get());\n\n        // 以原子方式将当前值加1，这里返回的是自增后的值\n        System.out.println(atomicInteger.incrementAndGet());\n\n        // 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果\n        System.out.println(atomicInteger.addAndGet(8));\n\n        // 以原子方式设置为newValue的值，并返回旧值\n        System.out.println(atomicInteger.getAndSet(20));\n        System.out.println(atomicInteger.get());\n\n    }\n\n}\n```\n\n#### 2) 案例改造\n\n使用AtomicInteger对案例进行改造。\n\n```java\npublic class VolatileAtomicThread implements Runnable {\n\n    // 定义一个int类型的变量\n    private AtomicInteger atomicInteger = new AtomicInteger() ;\n\n    @Override\n    public void run() {\n\n        // 对该变量进行++操作，100次\n        for(int x = 0 ; x < 100 ; x++) {\n            int i = atomicInteger.incrementAndGet();\n            System.out.println(\"count =========>>>> \" + i);\n        }\n\n    }\n\n}\n```\n\n控制台输出结果\n\n````java\n...\ncount =========>>>> 9998\ncount =========>>>> 9999\ncount =========>>>> 10000\n````\n\n通过控制台的执行结果，我们可以看到最终得到的结果就是10000，因此也就证明AtomicInteger所提供的方法是原子性操作方法。\n\n## 4.6 AtomicInteger原理\n\n### 4.6.1 原理介绍\n\nAtomicInteger的本质：自旋锁 + CAS算法\n\nCAS的全成是： Compare And Swap(比较再交换); 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-write转换为原子操作，这个原子操作\n\n直接由处理器保证。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当旧预期值A和内存值V相同时，将内存值V修改为B并返回true，否则什么都不做，并返回false。\n\n举例说明：\n\n1. 在内存值V当中，存储着值为10的变量。\n\n![1571817059527](assets/1571817059527.png)  \n\n2. 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值 A = 10 ，要修改的新值 B = 11。\n\n![1571817085047](assets/1571817085047.png) \n\n3. 在线程1要提交更新之前，另一个线程2抢先一步，把内存值V中的变量值率先更新成了11。\n\n![1571817628904](assets/1571817628904.png) \n\n4. 线程1开始提交更新，首先进行A和内存值V的实际值比较（Compare），发现A不等于V的值，提交失败。\n\n![1571818176635](assets/1571818176635.png) \n\n5. 线程1重新获取内存值V作为当前A的值，并重新计算想要修改的新值。此时对线程1来说，A = 11，B = 12。这个重新尝试的过程被称为<font color=\"red\" size=\"4\">**自旋**</font>。\n\n![1571818465276](assets/1571818465276.png) \n\n6. 这一次比较幸运，没有其他线程改变V的值。线程1进行Compare，发现A和V的值是相等的。\n\n![1571818597998](assets/1571818597998.png) \n\n7. 线程1进行SWAP，把内存V的值替换为B，也就是12。\n\n![1571818747880](assets/1571818747880.png) \n\n举例说明：这好比春节的时候抢火车票，下手快的会抢先买到票，而下手慢的可以再次尝试，直到买到票。\n\n### 4.6.2 源码分析\n\n那么接下来我们就来查看一下AtomicInteger类中incrementAndGet方法的源码。\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    \n    // cas算法的实现类\n    private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();\n    \n    // 表示变量值在内存中的偏移量地址，unsafe类就是根据内存偏移量地址获取数据值。\n    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, \"value\");\n    private volatile int value;\n    \n    // 以原子方式将当前值加1，这里返回的是自增后的值\n    public final int incrementAndGet() {\n        \n        /* this表示当前AtomicInteger对象 ，1表示要增加的值 */\n        return U.getAndAddInt(this, VALUE, 1) + 1;\t\t// 调用Unsafe类中的getAndAddInt方法\n        \n    }\n    \n}\n```\n\nUnSafe类\n\n```java\npublic final class Unsafe {\n    \n    // Unsafe类中的getAndAddInt方法\n    public final int getAndAddInt(Object o, long offset, int delta) {\n        \n        int v;\n        \n        // do...while就是自旋操作,当CAS成功以后，循环结束\n        do {\n            // 获取AtomicInteger类中所封装的int类型的值，就相当于旧的预期值A\n            v = getIntVolatile(o, offset); \n            \n            // 调用本类的weakCompareAndSetInt方法实现比较在交换； o: AtomicInteger对象, v: 相当于旧的预期值A, v + delta：新值B\n        } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n        \n        return v;\n    }\n    \n    // Unsafe类中的weakCompareAndSetInt方法\n    public final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) {\n        return compareAndSetInt(o, offset, expected, x);\n    }\n\n    // 本地方法，调用CPU指令实现CAS\n    public final native boolean compareAndSetInt(Object o, long offset, int expected, int x);\n    \n}\n```\n\n## 4.7 CAS与Synchronized\n\nCAS和Synchronized都可以保证多线程环境下共享数据的安全性。那么他们两者有什么区别？\n\n\n\nSynchronized是从悲观的角度出发：\n\n总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线**\n\n**程阻塞，用完后再把资源转让给其它线程**）。因此Synchronized我们也将其称之为悲观锁。jdk中的ReentrantLock也是一种悲观锁。\n\n\n\nCAS是从乐观的角度出发:\n\n总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。CAS这种机制我们也可以将其称之为乐观锁。\n\n\n\n# 5 并发工具类\n\n在JDK的并发包里提供了几个非常有用的并发容器和并发工具类。供我们在多线程开发中进行使用。\n\n## 5.1 ConcurrentHashMap\n\n### 5.1.1 概述以及基本使用\n\n在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n\n\n\n<font color=\"blue\" size=\"3\">**案例1**</font>：演示HashMap线程不安全\n\n实现步骤\n\n1. 创建一个HashMap集合对象\n2. 创建两个线程对象，第一个线程对象向集合中添加元素(1-24),第二个线程对象向集合中添加元素(25-50);\n3. 主线程休眠1秒，以便让其他两个线程将数据填装完毕\n4. 从集合中找出键和值不相同的数据\n\n测试类\n\n```java\npublic class HashMapDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建一个HashMap集合对象\n        HashMap<String , String> hashMap = new HashMap<String , String>() ;\n\n        // 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象\n        Thread t1 = new Thread() {\n\n            @Override\n            public void run() {\n\n                // 第一个线程对象向集合中添加元素(1-24)\n                for(int x = 1 ; x < 25 ; x++) {\n                    hashMap.put(String.valueOf(x) , String.valueOf(x)) ;\n                }\n\n            }\n\n        };\n\n        // 线程t2\n        Thread t2 = new Thread() {\n\n            @Override\n            public void run() {\n\n                // 第二个线程对象向集合中添加元素(25-50)\n                for(int x = 25 ; x < 51 ; x++) {\n                    hashMap.put(String.valueOf(x) , String.valueOf(x)) ;\n                }\n\n            }\n\n        };\n\n        // 启动线程\n        t1.start();\n        t2.start();\n\n        System.out.println(\"----------------------------------------------------------\");\n\n        try {\n\n            // 主线程休眠2s，以便让其他两个线程将数据填装完毕\n            TimeUnit.SECONDS.sleep(2);\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 从集合中找出键和值不相同的数据\n        for(int x = 1 ; x < 51 ; x++) {\n\n            // HashMap中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断\n            if( !String.valueOf(x).equals( hashMap.get(String.valueOf(x)) ) ) {\n                System.out.println(String.valueOf(x) + \":\" + hashMap.get(String.valueOf(x)));\n            }\n\n        }\n\n\n    }\n\n}\n```\n\n控制台输出结果\n\n````java\n----------------------------------------------------------\n5:null\n````\n\n通过控制台的输出结果，我们可以看到在多线程操作HashMap的时候，可能会出现线程安全问题。\n\n> 注1：需要多次运行才可以看到具体的效果; 可以使用循环将代码进行改造，以便让问题方便的暴露出来！\n\n\n\n<font color=\"blue\" size=\"3\">**案例2**</font>：演示Hashtable线程安全\n\n测试类\n\n```java\npublic class HashtableDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建一个Hashtable集合对象\n        Hashtable<String , String> hashtable = new Hashtable<String , String>() ;\n\n        // 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象\n        Thread t1 = new Thread() {\n\n            @Override\n            public void run() {\n\n                // 第一个线程对象向集合中添加元素(1-24)\n                for(int x = 1 ; x < 25 ; x++) {\n                    hashtable.put(String.valueOf(x) , String.valueOf(x)) ;\n                }\n\n            }\n\n        };\n\n        // 线程t2\n        Thread t2 = new Thread() {\n\n            @Override\n            public void run() {\n\n                // 第二个线程对象向集合中添加元素(25-50)\n                for(int x = 25 ; x < 51 ; x++) {\n                    hashtable.put(String.valueOf(x) , String.valueOf(x)) ;\n                }\n\n            }\n\n        };\n\n        // 启动线程\n        t1.start();\n        t2.start();\n\n        System.out.println(\"----------------------------------------------------------\");\n\n        try {\n\n            // 主线程休眠2s，以便让其他两个线程将数据填装完毕\n            TimeUnit.SECONDS.sleep(2);\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 从集合中找出键和值不相同的数据\n        for(int x = 1 ; x < 51 ; x++) {\n\n            // Hashtable中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断\n            if( !String.valueOf(x).equals( hashtable.get(String.valueOf(x)) ) ) {\n                System.out.println(String.valueOf(x) + \":\" + hashtable.get(String.valueOf(x)));\n            }\n\n        }\n        \n    }\n\n}\n```\n\n不论该程序运行多少次，都不会产生数据问题。因此也就证明Hashtable是线程安全的。\n\n\n\n<font color=\"blue\" size=\"3\">**Hashtable保证线程安全的原理**</font>：\n\n查看Hashtable的源码\n\n```java\npublic class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, java.io.Serializable {\n    \n    // Entry数组，一个Entry就相当于一个元素\n    private transient Entry<?,?>[] table;\n    \n    // Entry类的定义\n    private static class Entry<K,V> implements Map.Entry<K,V> {\n        final int hash;\t\t// 当前key的hash码值\n        final K key;\t\t// 键\n        V value;\t\t\t// 值\n        Entry<K,V> next;\t// 下一个节点\n    }\n    \n    // 存储数据\n    public synchronized V put(K key, V value){...}\n    \n    // 获取数据\n    public synchronized V get(Object key){...}\n    \n    // 获取长度\n    public synchronized int size(){...}\n    \n    ...\n    \n}\n```\n\n对应的结构如下图所示\n\n![1571905221097](assets/1571905221097.png) \n\nHashtable保证线程安全性的是使用方法全局锁进行实现的。在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable\n\n的同步方法时，会进入阻塞状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n\n\n\n<font color=\"blue\" size=\"3\">**案例3**</font>：演示ConcurrentHashMap线程安全\n\n测试类\n\n```java\npublic class ConcurrentHashMapDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建一个ConcurrentHashMap集合对象\n        ConcurrentHashMap<String , String> concurrentHashMap = new ConcurrentHashMap<String , String>() ;\n\n        // 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象\n        Thread t1 = new Thread() {\n\n            @Override\n            public void run() {\n\n                // 第一个线程对象向集合中添加元素(1-24)\n                for(int x = 1 ; x < 25 ; x++) {\n                    concurrentHashMap.put(String.valueOf(x) , String.valueOf(x)) ;\n                }\n\n            }\n\n        };\n\n        // 线程t2\n        Thread t2 = new Thread() {\n\n            @Override\n            public void run() {\n\n                // 第二个线程对象向集合中添加元素(25-50)\n                for(int x = 25 ; x < 51 ; x++) {\n                    concurrentHashMap.put(String.valueOf(x) , String.valueOf(x)) ;\n                }\n\n            }\n\n        };\n\n        // 启动线程\n        t1.start();\n        t2.start();\n\n        System.out.println(\"----------------------------------------------------------\");\n\n        try {\n\n            // 主线程休眠2s，以便让其他两个线程将数据填装完毕\n            TimeUnit.SECONDS.sleep(2);\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 从集合中找出键和值不相同的数据\n        for(int x = 1 ; x < 51 ; x++) {\n\n            // concurrentHashMap中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断\n            if( !String.valueOf(x).equals( concurrentHashMap.get(String.valueOf(x)) ) ) {\n                System.out.println(String.valueOf(x) + \":\" + concurrentHashMap.get(String.valueOf(x)));\n            }\n\n        }\n\n    }\n\n}\n```\n\n不论该程序运行多少次，都不会产生数据问题。因此也就证明ConcurrentHashMap是线程安全的。\n\n### 5.1.2 源码分析\n\n由于ConcurrentHashMap在jdk1.7和jdk1.8的时候实现原理不太相同，因此需要分别来讲解一下两个不同版本的实现原理。\n\n#### 1) jdk1.7版本\n\n<font color=\"blue\" size=\"3\">**ConcurrentHashMap中的重要成员变量**</font>\n\n```java\npublic class ConcurrentHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>, Serializable {\n    \n    /**\n     * Segment翻译中文为\"段\" , 段数组对象\n     */\n    final Segment<K,V>[] segments;\n    \n    // Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。\n    static final class Segment<K,V> extends ReentrantLock implements Serializable {\n        \n        transient volatile int count;    \t\t\t// Segment中元素的数量，由volatile修饰，支持内存可见性；\n        transient int modCount;\t\t\t \t\t\t// 对table的大小造成影响的操作的数量（比如put或者remove操作）;\n        transient int threshold;\t\t \t\t\t// 扩容阈值;\n        transient volatile HashEntry<K,V>[] table;  // 链表数组，数组中的每一个元素代表了一个链表的头部;\n        final float loadFactor;\t\t\t \t\t\t// 负载因子 \n        \n    }\n    \n    // Segment中的元素是以HashEntry的形式存放在数组中的，其结构与普通HashMap的HashEntry基本一致，不同的是Segment的HashEntry，其value由\t\t     // volatile修饰，以支持内存可见性，即写操作对其他读线程即时可见。\n    static final class HashEntry<K,V> {\n        final int hash;\t\t\t\t\t// 当前节点key对应的哈希码值\n        final K key;\t\t\t\t\t// 存储键\n        volatile V value;\t\t\t\t// 存储值\n        volatile HashEntry<K,V> next;\t// 下一个节点\n    }\n    \n}\n```\n\n对应的结构如下图所示\n\n![1571880094854](assets/1571880094854.png)  \n\n简单来讲，就是ConcurrentHashMap比HashMap多了一次hash过程，第1次hash定位到Segment，第2次hash定位到HashEntry，然后链表搜索找到指定节点。在进行写操作时，只需锁住写\n\n元素所在的Segment即可(这种锁被称为<font size=\"3\" color=\"red\">**分段锁**</font>)，其他Segment无需加锁，从而产生锁竞争的概率大大减小，提高了并发读写的效率。该种实现方式的缺点是hash过程比普通的HashMap要长\n\n(因为需要进行两次hash操作)。\n\n\n\n<font color=\"blue\" size=\"3\">**ConcurrentHashMap的put方法源码分析**</font>\n\n```java\npublic class ConcurrentHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>, Serializable { \n    \n    public V put(K key, V value) {\n        \n        // 定义一个Segment对象\n        Segment<K,V> s;\n        \n        // 如果value的值为空，那么抛出异常\n        if (value == null) throw new NullPointerException();\n        \n        // hash函数获取key的hashCode，然后做了一些处理\n        int hash = hash(key);\n        \n        // 通过key的hashCode定位segment\n        int j = (hash >>> segmentShift) & segmentMask;\n        \n        // 对定位的Segment进行判断，如果Segment为空，调用ensureSegment进行初始化操作(第一次hash定位)\n        if ((s = (Segment<K,V>)UNSAFE.getObject(segments, (j << SSHIFT) + SBASE)) == null) \n            s = ensureSegment(j);\n        \n        // 调用Segment对象的put方法添加元素\n        return s.put(key, hash, value, false);\n    }\n    \n    // Segment是一种可ReentrantLock，在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。\n    static final class Segment<K,V> extends ReentrantLock implements Serializable {\n        \n        // 添加元素\n        final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            \n            // 尝试对该段进行加锁,如果加锁失败，则调用scanAndLockForPut方法;在该方法中就要进行再次尝试或者进行自旋等待\n            HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                \n                // 获取HashEntry数组对象\n                HashEntry<K,V>[] tab = table;\n                \n                // 根据key的hashCode值计算索引(第二次hash定位)\n                int index = (tab.length - 1) & hash;\n                HashEntry<K,V> first = entryAt(tab, index);\n                for (HashEntry<K,V> e = first;;) \n                    \n                    // 若不为null\n                    if (e != null) {\n                        K k;\n                        \n                        // 判读当前节点的key是否和链表头节点的key相同(依赖于hashCode方法和equals方法) \n                        // 如果相同，值进行更新\n                        if ((k = e.key) == key || (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        \n                        e = e.next;\n                    } else {  // 若头结点为null\n                        \n                        // 将新节点添加到链表中\n                        if (node != null) \n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        \n                        // 如果超过阈值，则进行rehash操作\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n                unlock();\n            }\n        \n            return oldValue;\n        } \t\n        \n    }\n    \n}\n\n```\n\n> 注：源代码进行简单讲解即可(核心：进行了两次哈希定位以及加锁过程)\n\n\n\n#### 2) jdk1.8版本\n\n在JDK1.8中为了进一步优化ConcurrentHashMap的性能，去掉了Segment分段锁的设计。在数据结构方面，则是跟HashMap一样，使用一个哈希表table数组。(数组 + 链表 + 红黑树) \n\n而线程安全方面是结合CAS机制 + 局部锁实现的，减低锁的粒度，提高性能。同时在HashMap的基础上，对哈希表table数组和链表节点的value，next指针等使用volatile来修饰，从而\n\n实现线程可见性。\n\n<font color=\"blue\" size=\"3\">**ConcurrentHashMap中的重要成员变量**</font>\n\n```java\npublic class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {\n    \n    // Node数组\n    transient volatile Node<K,V>[] table;\n    \n    // Node类的定义\n    static class Node<K,V> implements Map.Entry<K,V> { \n        \n        final int hash;\t\t\t\t// 当前key的hashCode值\n        final K key;\t\t\t\t// 键\n        volatile V val;\t\t\t\t// 值\n        volatile Node<K,V> next;\t// 下一个节点\n        \n    }\n    \n    // TreeNode类的定义\n    static final class TreeNode<K,V> extends Node<K,V> {\n        TreeNode<K,V> parent;  // 父节点\n        TreeNode<K,V> left;\t   // 左子节点\n        TreeNode<K,V> right;   // 右子节点\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;\t\t   // 节点的颜色状态\n    }\n    \n}\n```\n\n对应的结构如下图\n\n![1571901607504](assets/1571901607504.png) \n\n\n\n<font color=\"blue\" size=\"3\">**ConcurrentHashMap的put方法源码分析**</font>\n\n```java\npublic class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {\n    \n    // 添加元素\n    public V put(K key, V value) {\n    \treturn putVal(key, value, false);\n\t}\n    \n    // putVal方法定义\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        \n        // key为null直接抛出异常\n        if (key == null || value == null) throw new NullPointerException();\n        \n        // 计算key所对应的hashCode值\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            \n            // 哈希表如果不存在，那么此时初始化哈希表\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n            \n            // 通过hash值计算key在table表中的索引，将其值赋值给变量i,然后根据索引找到对应的Node，如果Node为null,做出处理\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                \n                // 新增链表头结点，cas方式添加到哈希表table\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null))) break;                   \n            }\n            else if ((fh = f.hash) == MOVED)\n                tab = helpTransfer(tab, f);\n            else {\n                V oldVal = null;\n                \n                // f为链表头结点，使用synchronized加锁\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                \n                                // 节点已经存在，更新value即可\n                                if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                \n                                // 该key对应的节点不存在,则新增节点并添加到该链表的末尾\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key, value, null);\n                                    break;\n                                }\n                                \n                            }\n                            \n                        } else if (f instanceof TreeBin) { // 红黑树节点，则往该红黑树更新或添加该节点即可\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                \n                // 判断是否需要将链表转为红黑树\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount);\n        return null;\n    }\n    \n    // CAS算法的核心类\n    private static final sun.misc.Unsafe U;\n    static {\n        try {\n            U = sun.misc.Unsafe.getUnsafe();\n            ...\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n    \n    // 原子获取链表节点\n    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {\n        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);\n    }\n    \n    // CAS更新或新增链表节点\n    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v) {\n        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n    }\n    \n}\n```\n\n\n\n简单总结：\n\n1. 如果当前需要put的key对应的链表在哈希表table中还不存在，即还没添加过该key的hash值对应的链表，则调用casTabAt方法，基于CAS机制来实现添加该链表头结点到哈希表\n\n   table中，避免该线程在添加该链表头结的时候，其他线程也在添加的并发问题；如果CAS失败，则进行自旋，通过继续第2步的操作；\n\n2. 如果需要添加的链表已经存在哈希表table中，则通过tabAt方法，基于volatile机制，获取当前最新的链表头结点f，由于f指向的是ConcurrentHashMap的哈希表table的某条\n\n   链表的头结点，故虽然f是临时变量，由于是引用共享的该链表头结点，所以可以使用synchronized关键字来同步多个线程对该链表的访问。在synchronized(f)同步块里面则是与\n\n   HashMap一样遍历该链表，如果该key对应的链表节点已经存在，则更新，否则在链表的末尾新增该key对应的链表节点。\n\n## 5.2 CountDownLatch\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作以后，再执行当前线程；比如我们在主线程需要开启2个其他线程，当其他的线程执行完毕以后我们再去执行主线程，针对这\n\n个需求我们就可以使用CountDownLatch来进行实现。CountDownLatch中count down是倒着数数的意思；CountDownLatch是通过一个计数器来实现的，每当一个线程完成了自己的\n\n任务后，可以调用countDown()方法让计数器-1，当计数器到达0时，调用CountDownLatch的await()方法的线程阻塞状态解除，继续执行。\n\nCountDownLatch的相关方法\n\n```java\npublic CountDownLatch(int count)\t\t\t\t\t\t// 初始化一个指定计数器的CountDownLatch对象\npublic void await() throws InterruptedException\t\t\t// 让当前线程等待\npublic void countDown()\t\t\t\t\t\t\t\t\t// 计数器进行减1\n```\n\n\n\n案例演示：使用CountDownLatch完成上述需求(我们在主线程需要开启2个其他线程，当其他的线程执行完毕以后我们再去执行主线程)\n\n实现思路：在main方法中创建一个CountDownLatch对象，把这个对象作为作为参数传递给其他的两个任务线程\n\n线程任务类1\n\n```java\npublic class CountDownLatchThread01 implements Runnable {\n\n    // CountDownLatch类型成员变量\n    private CountDownLatch countDownLatch ;\n    public CountDownLatchThread01(CountDownLatch countDownLatch) {      // 构造方法的作用：接收CountDownLatch对象\n        this.countDownLatch = countDownLatch ;\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            Thread.sleep(10000);\n            System.out.println(\"10秒以后执行了CountDownLatchThread01......\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 调用CountDownLatch对象的countDown方法对计数器进行-1操作\n        countDownLatch.countDown();\n\n    }\n\n}\n```\n\n线程任务类2\n\n```java\npublic class CountDownLatchThread02 implements Runnable {\n\n    // CountDownLatch类型成员变量\n    private CountDownLatch countDownLatch ;\n    public CountDownLatchThread02(CountDownLatch countDownLatch) {      // 构造方法的作用：接收CountDownLatch对象\n        this.countDownLatch = countDownLatch ;\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            Thread.sleep(3000);\n            System.out.println(\"3秒以后执行了CountDownLatchThread02......\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 调用CountDownLatch对象的countDown方法对计数器进行-1操作\n        countDownLatch.countDown();\n\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class CountDownLatchDemo01 {\n\n    public static void main(String[] args) {\n\n        //  1. 创建一个CountDownLatch对象\n        CountDownLatch countDownLatch = new CountDownLatch(2) ;                 // CountDownLatch中的计数器的默认值就是2\n\n        //  2. 创建线程任务类对象，并且把这个CountDownLatch对象作为构造方法的参数进行传递\n        CountDownLatchThread01 countDownLatchThread01 = new CountDownLatchThread01(countDownLatch) ;\n\n        //  3. 创建线程任务类对象，并且把这个CountDownLatch对象作为构造方法的参数进行传递\n        CountDownLatchThread02 countDownLatchThread02 = new CountDownLatchThread02(countDownLatch) ;\n\n        //  4. 创建线程对象，并启动线程\n        Thread t1 = new Thread(countDownLatchThread01);\n        Thread t2 = new Thread(countDownLatchThread02);\n        t1.start();\n        t2.start();\n\n        //  5. 在主线程中调用 CountDownLatch中的await让主线程处于阻塞状态\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        //  6. 程序结束的输出\n        System.out.println(\"主线程执行了.... 程序结束了......\");\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\n3秒以后执行了CountDownLatchThread02......\n10秒以后执行了CountDownLatchThread01......\n主线程执行了.... 程序结束了......\n```\n\nCountDownLatchThread02线程先执行完毕，此时计数器-1；CountDownLatchThread01线程执行完毕，此时计数器-1；当计数器的值为0的时候，主线程阻塞状态接触，主线程向下执行。\n\n## 5.3 CyclicBarrier\n\n### 5.3.1 概述以及基本使用\n\nCyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障\n\n才会开门，所有被屏障拦截的线程才会继续运行。\n\n例如：公司召集5名员工开会，等5名员工都到了，会议开始。我们创建5个员工线程，1个开会线程，几乎同时启动，使用CyclicBarrier保证5名员工线程全部执行后，再执行开会线程。\n\n\n\nCyclicBarrier的相关方法\n\n```java\npublic CyclicBarrier(int parties, Runnable barrierAction)   // 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景\npublic int await()\t\t\t\t\t\t\t\t\t\t\t// 每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞\n```\n\n\n\n案例演示：模拟员工开会\n\n实现步骤：\n\n1. 创建一个员工线程类(EmployeeThread),该线程类中需要定义一个CyclicBarrier类型的形式参数\n2. 创建一个开会线程类(MettingThread)\n3. 测试类\n   1. 创建CyclicBarrier对象\n   2. 创建5个EmployeeThread线程对象，把第一步创建的CyclicBarrier对象作为构造方法参数传递过来\n   3. 启动5个员工线程\n\n员工线程类\n\n```java\npublic class EmployeeThread extends Thread {\n\n    // CyclicBarrier类型的成员变量\n    private CyclicBarrier cyclicBarrier ;\n    public EmployeeThread(CyclicBarrier cyclicBarrier) {        // 使用构造方法对CyclicBarrier进行初始化\n        this.cyclicBarrier = cyclicBarrier ;\n    }\n\n    @Override\n    public void run() {\n\n        try {\n\n            // 模拟开会人员的随机到场\n            Thread.sleep((int) (Math.random() * 1000));\n            System.out.println(Thread.currentThread().getName() + \" 到了! \");\n            cyclicBarrier.await();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n```\n\n开会线程类\n\n```java\npublic class MettingThread extends Thread {\n\n    @Override\n    public void run() {\n        System.out.println(\"好了，人都到了，开始开会......\");\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class CyclicBarrierDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建CyclicBarrier对象\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5 , new MettingThread()) ;\n\n        // 创建5个EmployeeThread线程对象，把第一步创建的CyclicBarrier对象作为构造方法参数传递过来\n        EmployeeThread thread1 = new EmployeeThread(cyclicBarrier) ;\n        EmployeeThread thread2 = new EmployeeThread(cyclicBarrier) ;\n        EmployeeThread thread3 = new EmployeeThread(cyclicBarrier) ;\n        EmployeeThread thread4 = new EmployeeThread(cyclicBarrier) ;\n        EmployeeThread thread5 = new EmployeeThread(cyclicBarrier) ;\n\n        // 启动5个员工线程\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n        thread5.start();\n\n    }\n\n}\n```\n\n### 5.3.2 使用场景\n\n使用场景：CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。\n\n比如：现在存在两个文件，这个两个文件中存储的是某一个员工两年的工资信息(一年一个文件)，现需要对这两个文件中的数据进行汇总；使用两个线程读取2个文件中的数据，当两个文\n\n件中的数据都读取完毕以后，进行数据的汇总操作。\n\n\n\n分析：要想在两个线程读取数据完毕以后进行数据的汇总，那么我们就需要定义一个任务类(该类需要实现Runnable接口)；两个线程读取完数据以后再进行数据的汇总，那么我们可以将\n\n​\t 两个线程读取到的数据先存储到一个集合中，而多线程环境下最常见的线程集合类就是ConcurrentHashMap，而这个集合需要被两个线程都可以进行使用，那么我们可以将这个集\n\n​\t 合作为我们任务类的成员变量，然后我们在这个任务类中去定义一个CyclicBarrier对象，然后在定义一个方法(count)，当调用这个count方法的时候需要去开启两个线程对象，\n\n​\t 使用这两个线程对象读取数据，把读取到的数据存储到ConcurrentHashMap对象，当一个线程读取数据完毕以后，调用CyclicBarrier的awit方法(告诉CyclicBarrier我已经\n\n​\t 到达了屏障)，然后在任务类的run方法对ConcurrentHashMap的数据进行汇总操作；\n\n\n\n实现步骤:\n\n1. 定义一个任务类CyclicBarrierThreadUse(实现了Runnable接口)\n2. 定义成员变量：CyclicBarrier ，ConcurrentHashMap\n\n```java\nprivate CyclicBarrier cyclicBarrier = new CyclicBarrier(2 , this) ;\nprivate ConcurrentHashMap<Integer , String> concurrentHashMap = new ConcurrentHashMap<Integer , String>() ;\n```\n\n3. 定义一个方法count方法，在count方法中开启两个线程对象(可以使用匿名内部类的方式实现)\n4. 在run方法中对ConcurrentHashMap中的数据进行汇总\n5. 编写测试类CyclicBarrierThreadUseDemo\n6. 创建CyclicBarrierThreadUse对象，调用count方法\n\n\n\n任务类代代码：\n\n```java\npublic class CyclicBarrierThreadUse implements Runnable {\n\n    // 当前我们两个线程到达了屏障点以后，我们需要立即对数据进行汇总, 因此我们需要使用第二个构造方法\n    // 并且我们当前这个类就是一个任务类，因此我们可以直接传递参数this\n    private CyclicBarrier cyclicBarrier = new CyclicBarrier(2 , this) ;\n    private ConcurrentHashMap<Integer , String> concurrentHashMap = new ConcurrentHashMap<Integer , String>() ;  // 存储两个线程所读取的数据\n\n    public void count() {\n\n        // 定义一个方法count方法，在count方法中开启两个线程对象(可以使用匿名内部类的方式实现)\n        // 线程1\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n\n                // 读取数据\n                BufferedReader bufferedReader = null ;\n                try {\n\n\n                    bufferedReader = new BufferedReader(new FileReader(\"D:\\\\salary\\\\2017-salary.txt\")) ;\n                    String line = null ;\n                    while((line = bufferedReader.readLine()) != null) {\n                        concurrentHashMap.put(Integer.parseInt(line) , \"\") ;            // 小的问题，工资信息不能重复\n                    }\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    if(bufferedReader != null) {\n                        try {\n                            bufferedReader.close();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n\n                // 模拟任务的执行时间\n                try {\n                    TimeUnit.SECONDS.sleep(5) ;\n                    System.out.println(Thread.currentThread().getName() + \"---------------------线程读取数据完毕....\");\n                    cyclicBarrier.await() ;         //通知cyclicBarrier当前线程已经到达了屏障点\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n\n            }\n\n        }).start();\n\n        // 线程2\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n\n                // 读取数据\n                BufferedReader bufferedReader = null ;\n                try {\n\n\n                    bufferedReader = new BufferedReader(new FileReader(\"D:\\\\salary\\\\2019-salary.txt\")) ;\n                    String line = null ;\n                    while((line = bufferedReader.readLine()) != null) {\n                        concurrentHashMap.put(Integer.parseInt(line) , \"\") ;            // 小的问题，工资信息不能重复\n                    }\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    if(bufferedReader != null) {\n                        try {\n                            bufferedReader.close();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n\n                // 模拟任务的执行时间\n                try {\n                    TimeUnit.SECONDS.sleep(10) ;\n                    System.out.println(Thread.currentThread().getName() + \"---------------------线程读取数据完毕....\");\n                    cyclicBarrier.await() ;         //通知cyclicBarrier当前线程已经到达了屏障点\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n\n            }\n\n        }).start();\n\n\n    }\n\n    @Override\n    public void run() {\n\n        // 获取concurrentHashMap中的数据进行汇总\n        Enumeration<Integer> enumeration = concurrentHashMap.keys();        // 获取concurrentHashMap中所有的键\n\n        /**\n         * 这个Enumeration的使用和我们之前所学习过的迭代器类似\n         * boolean hasMoreElements(); 判断集合中是否存在下一个元素\n         * E nextElement();           获取元素\n         */\n        int result = 0 ;\n        while(enumeration.hasMoreElements()) {\n            Integer integer = enumeration.nextElement();\n            result += integer ;\n        }\n\n        // 输出\n        System.out.println(result);\n\n    }\n\n\n}\n```\n\n测试类代码：\n\n```java\npublic class CyclicBarrierThreadUseDemo01 {\n\n    public static void main(String[] args) {\n\t\t\n        // 创建任务类的对象\n        CyclicBarrierThreadUse cyclicBarrierThreadUse = new CyclicBarrierThreadUse();\n        \n        // 调用count方法进行数据汇总\n        cyclicBarrierThreadUse.count();\n\n    }\n\n}\n```\n\n## 5.4 Semaphore\n\nSemaphore字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。\n\n举例：现在有一个十字路口，有多辆汽车需要进经过这个十字路口，但是我们规定同时只能有两辆汽车经过。其他汽车处于等待状态，只要某一个汽车经过了这个十字路口，其他的汽车才可以经\n\n过，但是同时只能有两个汽车经过。如何限定经过这个十字路口车辆数目呢? 我们就可以使用Semaphore。\n\nSemaphore的常用方法\n\n```java\npublic Semaphore(int permits)\t\t\t\t\t\tpermits 表示许可线程的数量\npublic void acquire() throws InterruptedException\t表示获取许可\npublic void release()\t\t\t\t\t\t\t\t表示释放许可\n```\n\n\n\n案例演示：模拟汽车通过十字路口\n\n实现步骤：\n\n1. 创建一个汽车的线程任务类(CarThreadRunnable),在该类中定义一个Semaphore类型的成员变量\n2. 创建测试类\n   1. 创建线程任务类对象\n   2. 创建5个线程对象，并启动。(5个线程对象，相当于5辆汽车)\n\nCarThreadRunnable类\n\n```java\npublic class CarThreadRunnable implements Runnable {\n\n    // 创建一个Semaphore对象,限制只允许2个线程获取到许可证\n    private Semaphore semaphore = new Semaphore(2) ;\n\n    @Override\n    public void run() {                         // 这个run只允许2个线程同时执行\n\n        try {\n\n            // 获取许可证\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName() + \"----->>正在经过十字路口\");\n\n            // 模拟车辆经过十字路口所需要的时间\n            Random random = new Random();\n            int nextInt = random.nextInt(7);\n            TimeUnit.SECONDS.sleep(nextInt);\n\n            System.out.println(Thread.currentThread().getName() + \"----->>驶出十字路口\");\n\n            // 释放许可证\n            semaphore.release();\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class SemaphoreDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建线程任务类对象\n        CarThreadRunnable carThreadRunnable = new CarThreadRunnable() ;\n\n        // 创建5个线程对象，并启动。\n        for(int x = 0 ; x < 5 ; x++) {\n            new Thread(carThreadRunnable).start();\n        }\n\n    }\n\n}\n```\n\n控制台输出结果\n\n```java\nThread-0----->>正在经过十字路口\nThread-1----->>正在经过十字路口\nThread-1----->>驶出十字路口\nThread-2----->>正在经过十字路口\nThread-0----->>驶出十字路口\nThread-3----->>正在经过十字路口\nThread-2----->>驶出十字路口\nThread-4----->>正在经过十字路口\nThread-4----->>驶出十字路口\nThread-3----->>驶出十字路口\n```\n\n通过控制台输出，我们可以看到当某一个汽车\"驶出\"十字路口以后，就会有一个汽车立马驶入。\n\n## 5.5 Exchanger\n\n### 5.5.1 概述以及基本使用\n\nExchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。\n\n举例：比如男女双方结婚的时候，需要进行交换结婚戒指。\n\nExchanger常用方法\n\n```java\npublic Exchanger()\t\t\t\t\t\t\t// 构造方法\npublic V exchange(V x)\t\t\t\t\t\t// 进行交换数据的方法，参数x表示本方数据 ，返回值v表示对方数据\n```\n\n这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，\n\n将本线程生产出来的数据传递给对方。\n\n\n\n案例演示：模拟交互结婚戒指\n\n实现步骤：\n\n1. 创建一个男方的线程类(ManThread),定义一个Exchanger类型的成员变量\n2. 创建一个女方的线程类(WomanThread),定义一个Exchanger类型的成员变量\n3. 测试类\n   1. 创建一个Exchanger对象\n   2. 创建一个ManThread对象，把第一步所创建的Exchanger作为构造方法参数传递过来\n   3. 创建一个WomanThread对象，把第一步所创建的Exchanger作为构造方法参数传递过来\n   4. 启动两个线程\n\nManThread类\n\n```java\npublic class ManThread extends Thread {\n\n    // 定义Exchanger类型的变量\n    private Exchanger<String> exchanger ;\n    private String name ;\n    public ManThread(Exchange<String> exchanger , String name) {\n        super(name);\n        this.name = name ;\n        this.exchanger = exchanger ;\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            String result = exchanger.exchange(\"钻戒\");\n            System.out.println(name + \"---->>把钻戒给媳妇\");\n            System.out.println(name + \"---->>得到媳妇给的\" + result);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n```\n\nWomanThread类\n\n```java\npublic class WomanThread extends Thread {\n\n    // 定义Exchanger类型的变量\n    private Exchanger<String> exchanger ;\n    private String name ;\n    public WomanThread(Exchanger<String> exchanger , String name) {\n        super(name) ;\n        this.name = name ;\n        this.exchanger = exchanger ;\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            String result = exchanger.exchange(\"铝戒\");\n            System.out.println(name + \"---->>把铝戒给老公\");\n            System.out.println(name + \"---->>得到老公给的\" + result);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n测试类\n\n```java\npublic class ExchangerDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建一个Exchanger对象\n        Exchanger<String> exchanger = new Exchanger<String>() ;\n\n        // 创建一个ManThread对象\n        ManThread manThread = new ManThread(exchanger , \"杨过\") ;\n\n        // 创建一个WomanThread对象\n        WomanThread womanThread = new WomanThread(exchanger , \"小龙女\") ;\n\n        // 启动线程\n        manThread.start();\n        womanThread.start();\n\n    }\n\n}\n```\n\n### 5.5.2 使用场景\n\n使用场景：可以做数据校对工作\n\n比如: 现在存在一个文件，该文件中存储的是某一个员工一年的工资信息，现需要将这个员工的工资信息录入到系统中，采用AB岗两人进行录入，录入到两个文件中，系统需要加载这两\n\n个文件，并对两个文件数据进行校对，看看是否录入一致，\n\n实现步骤：\n\n1. 创建一个测试类(ExchangerUseDemo)\n2. 通过匿名内部类的方法创建两个线程对象\n3. 两个线程分别读取文件中的数据，然后将数据存储到各自的集合中\n4. 当每一个线程读取完数据以后，就将数据交换给对方\n5. 然后每个线程使用对方传递过来的数据与自己所录入的数据进行比对\n\nExchangerUseDemo类\n\n```java\npublic class ExchangerUseDemo {\n\n    public static void main(String[] args) {\n\n        // 1. 创建Exchanger对象\n        Exchanger<ArrayList<String>> exchanger = new Exchanger<ArrayList<String>>() ;\n\n        // 2. 通过匿名内部类的方法创建两个线程对象\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n\n\n                try {\n\n                    // 读取文件中的数据，然后将其存储到集合中\n                    ArrayList<String> arrayList = new ArrayList<String>() ;\n                    BufferedReader bufferedReader = new BufferedReader(new FileReader(\"D:\\\\salary\\\\2017-salary.txt\")) ;\n                    String line = null ;\n                    while((line = bufferedReader.readLine()) != null) {\n                        arrayList.add(line) ;\n                    }\n\n                    // arrayList.add(\"90000\") ;\n                    // arrayList.set(0 , \"90000\") ;\n                    arrayList.remove(0) ;\n\n                    // 调用Exchanger中的exchange方法完成数据的交换\n                    ArrayList<String> exchange = exchanger.exchange(arrayList);\n\n                    // 先比对长度\n                    if(arrayList.size() == exchange.size()) {\n\n                        // 然后使用对方线程所传递过来的数据和自己线程所读取到的数据进行比对\n                        for(int x = 0 ; x < arrayList.size() ; x++) {\n\n                            // 本方数据\n                            String benfangElement = arrayList.get(x);\n\n                            // 对方数据\n                            String duifangElement = exchange.get(x);\n\n                            // 比对\n                            if(!benfangElement.equals(duifangElement)) {\n                                System.out.println(\"数据存在问题.....\");\n                            }\n\n                        }\n\n                    }else  {\n                        System.out.println(\"数据存在问题.....\");\n                    }\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n            }\n\n        }).start();\n\n        // 线程2\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n\n\n                try {\n\n                    // 读取文件中的数据，然后将其存储到集合中\n                    ArrayList<String> arrayList = new ArrayList<String>() ;\n                    BufferedReader bufferedReader = new BufferedReader(new FileReader(\"D:\\\\salary\\\\2017-salary.txt\")) ;\n                    String line = null ;\n                    while((line = bufferedReader.readLine()) != null) {\n                        arrayList.add(line) ;\n                    }\n\n                    // 调用Exchanger中的exchange方法完成数据的交换\n                    ArrayList<String> exchange = exchanger.exchange(arrayList);\n\n                    // 先比对长度\n                    if(arrayList.size() == exchange.size()) {\n\n                        // 然后使用对方线程所传递过来的数据和自己线程所读取到的数据进行比对\n                        for(int x = 0 ; x < arrayList.size() ; x++) {\n\n                            // 本方数据\n                            String benfangElement = arrayList.get(x);\n\n                            // 对方数据\n                            String duifangElement = exchange.get(x);\n\n                            // 比对\n                            if(!benfangElement.equals(duifangElement)) {\n                                System.out.println(\"数据存在问题.....\");\n                            }\n\n                        }\n\n                    }else  {\n                        System.out.println(\"数据存在问题.....\");\n                    }\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n            }\n\n        }).start();\n\n    }\n\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"反射和动态代理","url":"/2023/03/28/反射&动态代理/","content":"# 1. 反射\n\n## 1.1 反射的概述：\n\n​\t**专业的解释（了解一下）：**\n\n​       是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\n\n​       对于任意一个对象，都能够调用它的任意属性和方法；\n\n​       这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。\n\n​\t**通俗的理解：（掌握）**\n\n* 利用**反射**创建的对象**可以无视修饰符**调用类里面的内容\n\n* 可以跟**配置文件结合起来使用**，把要创建的对象信息和方法写在配置文件中。\n\n  读取到什么类，就创建什么类的对象\n\n  读取到什么方法，就调用什么方法\n\n  此时当需求变更的时候不需要修改代码，只要修改配置文件即可。\n\n## 1.2 学习反射到底学什么？\n\n反射都是从class字节码文件中获取的内容。\n\n* 如何获取class字节码文件的对象\n* 利用反射如何获取构造方法（创建对象）\n* 利用反射如何获取成员变量（赋值，获取值）\n* 利用反射如何获取成员方法（运行）\n\n## 1.3 获取字节码文件对象的三种方式\n\n* Class这个类里面的静态方法forName（“全类名”）**（最常用）**\n* 通过class属性获取  \n* 通过对象获取字节码文件对象\n\n代码示例：\n\n```java\n//1.Class这个类里面的静态方法forName\n//Class.forName(\"类的全类名\")： 全类名 = 包名 + 类名\nClass clazz1 = Class.forName(\"com.itheima.reflectdemo.Student\");\n//源代码阶段获取 --- 先把Student加载到内存中，再获取字节码文件的对象\n//clazz 就表示Student这个类的字节码文件对象。\n//就是当Student.class这个文件加载到内存之后，产生的字节码文件对象\n\n\n//2.通过class属性获取\n//类名.class\nClass clazz2 = Student.class;\n\n//因为class文件在硬盘中是唯一的，所以，当这个文件加载到内存之后产生的对象也是唯一的\nSystem.out.println(clazz1 == clazz2);//true\n\n\n//3.通过Student对象获取字节码文件对象\nStudent s = new Student();\nClass clazz3 = s.getClass();\nSystem.out.println(clazz1 == clazz2);//true\nSystem.out.println(clazz2 == clazz3);//true\n```\n\n## 1.4 字节码文件和字节码文件对象\n\njava文件：就是我们自己编写的java代码。\n\n字节码文件：就是通过java文件编译之后的class文件（是在硬盘上真实存在的，用眼睛能看到的）\n\n字节码文件对象：当class文件加载到内存之后，虚拟机自动创建出来的对象。\n\n​\t\t\t\t这个对象里面至少包含了：构造方法，成员变量，成员方法。\n\n而我们的反射获取的是什么？字节码文件对象，这个对象在内存中是唯一的。\n\n## 1.5 获取构造方法\n\n规则：\n\n​\tget表示获取\n\n​\tDeclared表示私有\n\n​\t最后的s表示所有，复数形式\n\n​\t如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用\n\n| 方法名                                                       | 说明                              |\n| ------------------------------------------------------------ | --------------------------------- |\n| Constructor<?>[] getConstructors()                           | 获得所有的构造（只能public修饰）  |\n| Constructor<?>[] getDeclaredConstructors()                   | 获得所有的构造（包含private修饰） |\n| Constructor<T> getConstructor(Class<?>... parameterTypes)    | 获取指定构造（只能public修饰）    |\n| Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 获取指定构造（包含private修饰）   |\n\n代码示例：\n\n```java\npublic class ReflectDemo2 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n        //1.获得整体（class字节码文件对象）\n        Class clazz = Class.forName(\"com.itheima.reflectdemo.Student\");\n\n\n        //2.获取构造方法对象\n        //获取所有构造方法（public）\n        Constructor[] constructors1 = clazz.getConstructors();\n        for (Constructor constructor : constructors1) {\n            System.out.println(constructor);\n        }\n\n        System.out.println(\"=======================\");\n\n        //获取所有构造（带私有的）\n        Constructor[] constructors2 = clazz.getDeclaredConstructors();\n\n        for (Constructor constructor : constructors2) {\n            System.out.println(constructor);\n        }\n        System.out.println(\"=======================\");\n\n        //获取指定的空参构造\n        Constructor con1 = clazz.getConstructor();\n        System.out.println(con1);\n\n        Constructor con2 = clazz.getConstructor(String.class,int.class);\n        System.out.println(con2);\n\n        System.out.println(\"=======================\");\n        //获取指定的构造(所有构造都可以获取到，包括public包括private)\n        Constructor con3 = clazz.getDeclaredConstructor();\n        System.out.println(con3);\n        //了解 System.out.println(con3 == con1);\n        //每一次获取构造方法对象的时候，都会新new一个。\n\n        Constructor con4 = clazz.getDeclaredConstructor(String.class);\n        System.out.println(con4);\n    }\n}\n```\n\n## 1.6 获取构造方法并创建对象\n\n涉及到的方法：newInstance\n\n代码示例：\n\n```java\n//首先要有一个javabean类\npublic class Student {\n    private String name;\n\n    private int age;\n\n\n    public Student() {\n\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    private Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"Student{name = \" + name + \", age = \" + age + \"}\";\n    }\n}\n\n\n\n//测试类中的代码：\n//需求1：\n//获取空参，并创建对象\n\n//1.获取整体的字节码文件对象\nClass clazz = Class.forName(\"com.itheima.a02reflectdemo1.Student\");\n//2.获取空参的构造方法\nConstructor con = clazz.getConstructor();\n//3.利用空参构造方法创建对象\nStudent stu = (Student) con.newInstance();\nSystem.out.println(stu);\n\n\nSystem.out.println(\"=============================================\");\n\n\n//测试类中的代码：\n//需求2：\n//获取带参构造，并创建对象\n//1.获取整体的字节码文件对象\nClass clazz = Class.forName(\"com.itheima.a02reflectdemo1.Student\");\n//2.获取有参构造方法\nConstructor con = clazz.getDeclaredConstructor(String.class, int.class);\n//3.临时修改构造方法的访问权限（暴力反射）\ncon.setAccessible(true);\n//4.直接创建对象\nStudent stu = (Student) con.newInstance(\"zhangsan\", 23);\nSystem.out.println(stu);\n```\n\n## 1.7 获取成员变量\n\n规则：\n\n​\tget表示获取\n\n​\tDeclared表示私有\n\n​\t最后的s表示所有，复数形式\n\n​\t如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用\n\n方法名：\n\n| 方法名                              | 说明                                         |\n| ----------------------------------- | -------------------------------------------- |\n| Field[] getFields()                 | 返回所有成员变量对象的数组（只能拿public的） |\n| Field[] getDeclaredFields()         | 返回所有成员变量对象的数组，存在就能拿到     |\n| Field getField(String name)         | 返回单个成员变量对象（只能拿public的）       |\n| Field getDeclaredField(String name) | 返回单个成员变量对象，存在就能拿到           |\n\n代码示例：\n\n```java\npublic class ReflectDemo4 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        //获取成员变量对象\n\n        //1.获取class对象\n        Class clazz = Class.forName(\"com.itheima.reflectdemo.Student\");\n\n        //2.获取成员变量的对象（Field对象)只能获取public修饰的\n        Field[] fields1 = clazz.getFields();\n        for (Field field : fields1) {\n            System.out.println(field);\n        }\n\n        System.out.println(\"===============================\");\n\n        //获取成员变量的对象（public + private）\n        Field[] fields2 = clazz.getDeclaredFields();\n        for (Field field : fields2) {\n            System.out.println(field);\n        }\n\n        System.out.println(\"===============================\");\n        //获得单个成员变量对象\n        //如果获取的属性是不存在的，那么会报异常\n        //Field field3 = clazz.getField(\"aaa\");\n        //System.out.println(field3);//NoSuchFieldException\n\n        Field field4 = clazz.getField(\"gender\");\n        System.out.println(field4);\n\n        System.out.println(\"===============================\");\n        //获取单个成员变量（私有）\n        Field field5 = clazz.getDeclaredField(\"name\");\n        System.out.println(field5);\n\n    }\n}\n\n\n\npublic class Student {\n    private String name;\n\n    private int age;\n\n    public String gender;\n\n    public String address;\n\n\n    public Student() {\n    }\n\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n\n    public Student(String name, int age, String gender, String address) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.address = address;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public String getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return address\n     */\n    public String getAddress() {\n        return address;\n    }\n\n    /**\n     * 设置\n     * @param address\n     */\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String toString() {\n        return \"Student{name = \" + name + \", age = \" + age + \", gender = \" + gender + \", address = \" + address + \"}\";\n    }\n}\n\n```\n\n## 1.8 获取成员变量并获取值和修改值\n\n| 方法                                | 说明   |\n| ----------------------------------- | ------ |\n| void set(Object obj, Object value） | 赋值   |\n| Object get(Object obj)              | 获取值 |\n\n代码示例：\n\n```java\npublic class ReflectDemo5 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        Student s = new Student(\"zhangsan\",23,\"广州\");\n        Student ss = new Student(\"lisi\",24,\"北京\");\n\n        //需求：\n        //利用反射获取成员变量并获取值和修改值\n\n        //1.获取class对象\n        Class clazz = Class.forName(\"com.itheima.reflectdemo.Student\");\n\n        //2.获取name成员变量\n        //field就表示name这个属性的对象\n        Field field = clazz.getDeclaredField(\"name\");\n        //临时修饰他的访问权限\n        field.setAccessible(true);\n\n        //3.设置(修改)name的值\n        //参数一：表示要修改哪个对象的name？\n        //参数二：表示要修改为多少？\n        field.set(s,\"wangwu\");\n\n        //3.获取name的值\n        //表示我要获取这个对象的name的值\n        String result = (String)field.get(s);\n\n        //4.打印结果\n        System.out.println(result);\n\n        System.out.println(s);\n        System.out.println(ss);\n\n    }\n}\n\n\npublic class Student {\n    private String name;\n    private int age;\n    public String gender;\n    public String address;\n\n\n    public Student() {\n    }\n\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n\n    public Student(String name, int age, String gender, String address) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.address = address;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public String getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return address\n     */\n    public String getAddress() {\n        return address;\n    }\n\n    /**\n     * 设置\n     * @param address\n     */\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String toString() {\n        return \"Student{name = \" + name + \", age = \" + age + \", gender = \" + gender + \", address = \" + address + \"}\";\n    }\n}\n\n```\n\n## 1.9 获取成员方法\n\n规则：\n\n​\tget表示获取\n\n​\tDeclared表示私有\n\n​\t最后的s表示所有，复数形式\n\n​\t如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用\n\n| 方法名                                                       | 说明                                         |\n| ------------------------------------------------------------ | -------------------------------------------- |\n| Method[] getMethods()                                        | 返回所有成员方法对象的数组（只能拿public的） |\n| Method[] getDeclaredMethods()                                | 返回所有成员方法对象的数组，存在就能拿到     |\n| Method getMethod(String name, Class<?>... parameterTypes)    | 返回单个成员方法对象（只能拿public的）       |\n| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到           |\n\n代码示例：\n\n```java\npublic class ReflectDemo6 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n        //1.获取class对象\n        Class<?> clazz = Class.forName(\"com.itheima.reflectdemo.Student\");\n\n\n        //2.获取方法\n        //getMethods可以获取父类中public修饰的方法\n        Method[] methods1 = clazz.getMethods();\n        for (Method method : methods1) {\n            System.out.println(method);\n        }\n\n        System.out.println(\"===========================\");\n        //获取所有的方法（包含私有）\n        //但是只能获取自己类中的方法\n        Method[] methods2 = clazz.getDeclaredMethods();\n        for (Method method : methods2) {\n            System.out.println(method);\n        }\n\n        System.out.println(\"===========================\");\n        //获取指定的方法（空参）\n        Method method3 = clazz.getMethod(\"sleep\");\n        System.out.println(method3);\n\n        Method method4 = clazz.getMethod(\"eat\",String.class);\n        System.out.println(method4);\n\n        //获取指定的私有方法\n        Method method5 = clazz.getDeclaredMethod(\"playGame\");\n        System.out.println(method5);\n    }\n}\n\n```\n\n## 1.10 获取成员方法并运行\n\n方法\n\n Object invoke(Object obj, Object... args) ：运行方法\n\n参数一：用obj对象调用该方法\n\n参数二：调用方法的传递的参数（如果没有就不写）\n\n返回值：方法的返回值（如果没有就不写）\n\n代码示例：\n\n```java\npackage com.itheima.a02reflectdemo1;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectDemo6 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //1.获取字节码文件对象\n        Class clazz = Class.forName(\"com.itheima.a02reflectdemo1.Student\");\n\t\t\n        //2.获取一个对象\n        //需要用这个对象去调用方法\n        Student s = new Student();\n        \n        //3.获取一个指定的方法\n        //参数一：方法名\n        //参数二：参数列表，如果没有可以不写\n        Method eatMethod = clazz.getMethod(\"eat\",String.class);\n        \n        //运行\n        //参数一：表示方法的调用对象\n        //参数二：方法在运行时需要的实际参数\n        //注意点：如果方法有返回值，那么需要接收invoke的结果\n        //如果方法没有返回值，则不需要接收\n        String result = (String) eatMethod.invoke(s, \"重庆小面\");\n        System.out.println(result);\n\n    }\n}\n\n\n\npublic class Student {\n    private String name;\n    private int age;\n    public String gender;\n    public String address;\n\n\n    public Student() {\n\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    private Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"Student{name = \" + name + \", age = \" + age + \"}\";\n    }\n\n    private void study(){\n        System.out.println(\"学生在学习\");\n    }\n\n    private void sleep(){\n        System.out.println(\"学生在睡觉\");\n    }\n\n    public String eat(String something){\n        System.out.println(\"学生在吃\" + something);\n        return \"学生已经吃完了，非常happy\";\n    }\n}\n```\n\n## 面试题：\n\n​\t你觉得反射好不好？好，有两个方向\n\n​\t第一个方向：无视修饰符访问类中的内容。但是这种操作在开发中一般不用，都是框架底层来用的。\n\n​\t第二个方向：反射可以跟配置文件结合起来使用，动态的创建对象，动态的调用方法。\n\n## 1.11 练习泛型擦除（掌握概念，了解代码）\n\n理解：（掌握）\n\n​\t集合中的泛型只在java文件中存在，当编译成class文件之后，就没有泛型了。\n\n代码示例：（了解）\n\n```java\npackage com.itheima.reflectdemo;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\n\npublic class ReflectDemo8 {\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //1.创建集合对象\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(123);\n//        list.add(\"aaa\");\n\n        //2.利用反射运行add方法去添加字符串\n        //因为反射使用的是class字节码文件\n\n        //获取class对象\n        Class clazz = list.getClass();\n\n        //获取add方法对象\n        Method method = clazz.getMethod(\"add\", Object.class);\n\n        //运行方法\n        method.invoke(list,\"aaa\");\n\n        //打印集合\n        System.out.println(list);\n    }\n}\n\n```\n\n## 1.12 练习：修改字符串的内容（掌握概念，了解代码）\n\n在这个练习中，我需要你掌握的是字符串不能修改的真正原因。\n\n字符串，在底层是一个byte类型的字节数组，名字叫做value\n\n```java\nprivate final byte[] value;\n```\n\n真正不能被修改的原因：final和private\n\nfinal修饰value表示value记录的地址值不能修改。\n\nprivate修饰value而且没有对外提供getvalue和setvalue的方法。所以，在外界不能获取或修改value记录的地址值。\n\n如果要强行修改可以用反射：\n\n代码示例：（了解）\n\n```java\nString s = \"abc\";\nString ss = \"abc\";\n// private final byte[] value= {97,98,99};\n// 没有对外提供getvalue和setvalue的方法，不能修改value记录的地址值\n// 如果我们利用反射获取了value的地址值。\n// 也是可以修改的，final修饰的value\n// 真正不可变的value数组的地址值，里面的内容利用反射还是可以修改的，比较危险\n\n//1.获取class对象\nClass clazz = s.getClass();\n\n//2.获取value成员变量（private）\nField field = clazz.getDeclaredField(\"value\");\n//但是这种操作非常危险\n//JDK高版本已经屏蔽了这种操作，低版本还是可以的\n//临时修改权限\nfield.setAccessible(true);\n\n//3.获取value记录的地址值\nbyte[] bytes = (byte[]) field.get(s);\nbytes[0] = 100;\n\nSystem.out.println(s);//dbc\nSystem.out.println(ss);//dbc\n```\n\n## 1.13 练习，反射和配置文件结合动态获取的练习（重点）\n\n需求: 利用反射根据文件中的不同类名和方法名，创建不同的对象并调用方法。\n\n分析:\n\n①通过Properties加载配置文件\n\n②得到类名和方法名\n\n③通过类名反射得到Class对象\n\n④通过Class对象创建一个对象\n\n⑤通过Class对象得到方法\n\n⑥调用方法\n\n代码示例：\n\n```java\npublic class ReflectDemo9 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //1.读取配置文件的信息\n        Properties prop = new Properties();\n        FileInputStream fis = new FileInputStream(\"day14-code\\\\prop.properties\");\n        prop.load(fis);\n        fis.close();\n        System.out.println(prop);\n\n        String classname = prop.get(\"classname\") + \"\";\n        String methodname = prop.get(\"methodname\") + \"\";\n\n        //2.获取字节码文件对象\n        Class clazz = Class.forName(classname);\n\n        //3.要先创建这个类的对象\n        Constructor con = clazz.getDeclaredConstructor();\n        con.setAccessible(true);\n        Object o = con.newInstance();\n        System.out.println(o);\n\n        //4.获取方法的对象\n        Method method = clazz.getDeclaredMethod(methodname);\n        method.setAccessible(true);\n\n        //5.运行方法\n        method.invoke(o);\n\n\n    }\n}\n\n配置文件中的信息：\nclassname=com.itheima.a02reflectdemo1.Student\nmethodname=sleep\n```\n\n## 1.14 利用发射保存对象中的信息（重点）\n\n```java\npublic class MyReflectDemo {\n    public static void main(String[] args) throws IllegalAccessException, IOException {\n    /*\n        对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去\n    */\n       Student s = new Student(\"小A\",23,'女',167.5,\"睡觉\");\n       Teacher t = new Teacher(\"播妞\",10000);\n       saveObject(s);\n    }\n\n    //把对象里面所有的成员变量名和值保存到本地文件中\n    public static void saveObject(Object obj) throws IllegalAccessException, IOException {\n        //1.获取字节码文件的对象\n        Class clazz = obj.getClass();\n        //2. 创建IO流\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"myreflect\\\\a.txt\"));\n        //3. 获取所有的成员变量\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            field.setAccessible(true);\n            //获取成员变量的名字\n            String name = field.getName();\n            //获取成员变量的值\n            Object value = field.get(obj);\n            //写出数据\n            bw.write(name + \"=\" + value);\n            bw.newLine();\n        }\n\n        bw.close();\n\n    }\n}\n```\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    private char gender;\n    private double height;\n    private String hobby;\n\n    public Student() {\n    }\n\n    public Student(String name, int age, char gender, double height, String hobby) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.height = height;\n        this.hobby = hobby;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public char getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return height\n     */\n    public double getHeight() {\n        return height;\n    }\n\n    /**\n     * 设置\n     * @param height\n     */\n    public void setHeight(double height) {\n        this.height = height;\n    }\n\n    /**\n     * 获取\n     * @return hobby\n     */\n    public String getHobby() {\n        return hobby;\n    }\n\n    /**\n     * 设置\n     * @param hobby\n     */\n    public void setHobby(String hobby) {\n        this.hobby = hobby;\n    }\n\n    public String toString() {\n        return \"Student{name = \" + name + \", age = \" + age + \", gender = \" + gender + \", height = \" + height + \", hobby = \" + hobby + \"}\";\n    }\n}\n```\n\n```java\npublic class Teacher {\n    private String name;\n    private double salary;\n\n    public Teacher() {\n    }\n\n    public Teacher(String name, double salary) {\n        this.name = name;\n        this.salary = salary;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return salary\n     */\n    public double getSalary() {\n        return salary;\n    }\n\n    /**\n     * 设置\n     * @param salary\n     */\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    public String toString() {\n        return \"Teacher{name = \" + name + \", salary = \" + salary + \"}\";\n    }\n}\n\n```\n\n# 2. 动态代理\n\n## 2.1 好处：\n\n​\t无侵入式的给方法增强功能\n\n## 2.2 动态代理三要素：\n\n1，真正干活的对象\n\n2，代理对象\n\n3，利用代理调用方法\n\n切记一点：代理可以增强或者拦截的方法都在接口中，接口需要写在newProxyInstance的第二个参数里。\n\n## 2.3 代码实现：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n    /*\n        需求：\n            外面的人想要大明星唱一首歌\n             1. 获取代理的对象\n                代理对象 = ProxyUtil.createProxy(大明星的对象);\n             2. 再调用代理的唱歌方法\n                代理对象.唱歌的方法(\"只因你太美\");\n     */\n        //1. 获取代理的对象\n        BigStar bigStar = new BigStar(\"鸡哥\");\n        Star proxy = ProxyUtil.createProxy(bigStar);\n\n        //2. 调用唱歌的方法\n        String result = proxy.sing(\"只因你太美\");\n        System.out.println(result);\n    }\n}\n```\n\n```java\n/*\n*\n* 类的作用：\n*       创建一个代理\n*\n* */\npublic class ProxyUtil {\n    /*\n    *\n    * 方法的作用：\n    *       给一个明星的对象，创建一个代理\n    *\n    *  形参：\n    *       被代理的明星对象\n    *\n    *  返回值：\n    *       给明星创建的代理\n    *\n    *\n    *\n    * 需求：\n    *   外面的人想要大明星唱一首歌\n    *   1. 获取代理的对象\n    *      代理对象 = ProxyUtil.createProxy(大明星的对象);\n    *   2. 再调用代理的唱歌方法\n    *      代理对象.唱歌的方法(\"只因你太美\");\n    * */\n    public static Star createProxy(BigStar bigStar){\n       /* java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：\n\n        public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)\n        参数一：用于指定用哪个类加载器，去加载生成的代理类\n        参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n        参数三：用来指定生成的代理对象要干什么事情*/\n        Star star = (Star) Proxy.newProxyInstance(\n                ProxyUtil.class.getClassLoader(),//参数一：用于指定用哪个类加载器，去加载生成的代理类\n                new Class[]{Star.class},//参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n                //参数三：用来指定生成的代理对象要干什么事情\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        /*\n                        * 参数一：代理的对象\n                        * 参数二：要运行的方法 sing\n                        * 参数三：调用sing方法时，传递的实参\n                        * */\n                        if(\"sing\".equals(method.getName())){\n                            System.out.println(\"准备话筒，收钱\");\n                        }else if(\"dance\".equals(method.getName())){\n                            System.out.println(\"准备场地，收钱\");\n                        }\n                        //去找大明星开始唱歌或者跳舞\n                        //代码的表现形式：调用大明星里面唱歌或者跳舞的方法\n                        return method.invoke(bigStar,args);\n                    }\n                }\n        );\n        return star;\n    }\n}\n```\n\n```java\npublic interface Star {\n    //我们可以把所有想要被代理的方法定义在接口当中\n    //唱歌\n    public abstract String sing(String name);\n    //跳舞\n    public abstract void dance();\n}\n```\n\n```java\npublic class BigStar implements Star {\n    private String name;\n\n\n    public BigStar() {\n    }\n\n    public BigStar(String name) {\n        this.name = name;\n    }\n\n    //唱歌\n    @Override\n    public String sing(String name){\n        System.out.println(this.name + \"正在唱\" + name);\n        return \"谢谢\";\n    }\n\n    //跳舞\n    @Override\n    public void dance(){\n        System.out.println(this.name + \"正在跳舞\");\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String toString() {\n        return \"BigStar{name = \" + name + \"}\";\n    }\n}\n\n```\n\n## 2.4 额外扩展\n\n动态代理，还可以拦截方法\n\n比如：\n\n​\t在这个故事中，经济人作为代理，如果别人让邀请大明星去唱歌，打篮球，经纪人就增强功能。\n\n​\t但是如果别人让大明星去扫厕所，经纪人就要拦截，不会去调用大明星的方法。\n\n```java\n/*\n* 类的作用：\n*       创建一个代理\n* */\npublic class ProxyUtil {\n    public static Star createProxy(BigStar bigStar){\n        public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)\n        Star star = (Star) Proxy.newProxyInstance(\n                ProxyUtil.class.getClassLoader(),\n                new Class[]{Star.class},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        if(\"cleanWC\".equals(method.getName())){\n                            System.out.println(\"拦截，不调用大明星的方法\");\n                            return null;\n                        }\n                        //如果是其他方法，正常执行\n                        return method.invoke(bigStar,args);\n                    }\n                }\n        );\n        return star;\n    }\n}\n```\n\n## 2.5 动态代理的练习\n\n​\t 对add方法进行增强，对remove方法进行拦截，对其他方法不拦截也不增强\n\n```java\npublic class MyProxyDemo1 {\n    public static void main(String[] args) {\n        //动态代码可以增强也可以拦截\n        //1.创建真正干活的人\n        ArrayList<String> list = new ArrayList<>();\n\n        //2.创建代理对象\n        //参数一：类加载器。当前类名.class.getClassLoader()\n        //                 找到是谁，把当前的类，加载到内存中了，我再麻烦他帮我干一件事情，把后面的代理类，也加载到内存\n\n        //参数二：是一个数组，在数组里面写接口的字节码文件对象。\n        //                  如果写了List，那么表示代理，可以代理List接口里面所有的方法，对这些方法可以增强或者拦截\n        //                  但是，一定要写ArrayList真实实现的接口\n        //                  假设在第二个参数中，写了MyInter接口，那么是错误的。\n        //                  因为ArrayList并没有实现这个接口，那么就无法对这个接口里面的方法，进行增强或拦截\n        //参数三：用来创建代理对象的匿名内部类\n        List proxyList = (List) Proxy.newProxyInstance(\n                //参数一：类加载器\n                MyProxyDemo1.class.getClassLoader(),\n                //参数二：是一个数组，表示代理对象能代理的方法范围\n                new Class[]{List.class},\n                //参数三：本质就是代理对象\n                new InvocationHandler() {\n                    @Override\n                    //invoke方法参数的意义\n                    //参数一：表示代理对象，一般不用（了解）\n                    //参数二：就是方法名，我们可以对方法名进行判断，是增强还是拦截\n                    //参数三：就是下面第三步调用方法时，传递的参数。\n                    //举例1：\n                    //list.add(\"阿玮好帅\");\n                    //此时参数二就是add这个方法名\n                    //此时参数三 args[0] 就是 阿玮好帅\n                    //举例2：\n                    //list.set(1, \"aaa\");\n                    //此时参数二就是set这个方法名\n                    //此时参数三  args[0] 就是 1  args[1]\"aaa\"\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        //对add方法做一个增强，统计耗时时间\n                        if (method.getName().equals(\"add\")) {\n                            long start = System.currentTimeMillis();\n                            //调用集合的方法，真正的添加数据\n                            method.invoke(list, args);\n                            long end = System.currentTimeMillis();\n                            System.out.println(\"耗时时间：\" + (end - start));\n                            //需要进行返回，返回值要跟真正增强或者拦截的方法保持一致\n                            return true;\n                        }else if(method.getName().equals(\"remove\") && args[0] instanceof Integer){\n                            System.out.println(\"拦截了按照索引删除的方法\");\n                            return null;\n                        }else if(method.getName().equals(\"remove\")){\n                            System.out.println(\"拦截了按照对象删除的方法\");\n                            return false;\n                        }else{\n                            //如果当前调用的是其他方法,我们既不增强，也不拦截\n                            method.invoke(list,args);\n                            return null;\n                        }\n                    }\n                }\n        );\n\n        //3.调用方法\n        //如果调用者是list，就好比绕过了第二步的代码，直接添加元素\n        //如果调用者是代理对象，此时代理才能帮我们增强或者拦截\n\n        //每次调用方法的时候，都不会直接操作集合\n        //而是先调用代理里面的invoke，在invoke方法中进行判断，可以增强或者拦截\n        proxyList.add(\"aaa\");\n        proxyList.add(\"bbb\");\n        proxyList.add(\"ccc\");\n        proxyList.add(\"ddd\");\n\n        proxyList.remove(0);\n        proxyList.remove(\"aaa\");\n\n\n        //打印集合\n        System.out.println(list);\n    }\n}\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"反射个人笔记","url":"/2023/03/28/反射/","content":"# 反射\n\n## 什么是反射？\n\n反射允许对成员变量，成员方法和构造方法的信息进行编程访问\n\n![](https://pic.imgdb.cn/item/642941efa682492fcc57c6fa.jpg)\n\n## 获取class对象的三种方式\n\n- Class。forName(\"全类名\")；--- 源代码阶段--- 最为常用的\n- 类名.class ---- 加载阶段 --- 一般更多的是当参数传递\n- 对象.getClass(); -- 运行阶段  --- 当我们已经有了这个类的对象时才可以使用\n\n**全类名： 包名 + 类名**\n\n\n\n![](https://pic.imgdb.cn/item/64294275a682492fcc5893bc.jpg)\n\n```java\npackage reflect.day1;\n\npublic class Test01 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class<?> aClass = Class.forName(\"reflect.day1.Student\");\n        System.out.println(aClass);\n        Class<Student> studentClass = Student.class;\n        System.out.println(studentClass);\n        System.out.println(studentClass == aClass);\n        Student student = new Student();\n        Class aClass1 = student.getClass();\n        System.out.println(aClass1);\n        System.out.println(aClass1 == aClass);\n\n    }\n}\n```\n\n## 练习\n\n1.\n\n把对象里面所有的成员变量名和值保存到本地文件中\n\n```java\npackage reflect.day1;\n\nimport java.lang.reflect.Field;\n\npublic class Test02 {\n    public static void main(String[] args) throws IllegalAccessException {\n        Student s = new Student(12, \"aaa\");\n        Teacher teacher = new Teacher(40, \"teacher\");\n        saveObject(teacher);\n    }\n    public static void saveObject(Object obj) throws IllegalAccessException {\n        // 获取字节码文件的对象\n        Class aClass = obj.getClass();\n        // 获取所有的成员变量\n        Field[] field = aClass.getDeclaredFields();\n        for (Field item : field) {\n            item.setAccessible(true);\n            // 获取成员变量的名字\n            String name = item.getName();\n            // 获取成员变量的值\n            Object value = item.get(obj);\n            System.out.println(name+\"=\"+value);\n        }\n\n    }\n}\n```\n\n```java\npackage reflect.day1;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\n\npublic class Test03 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        Properties prop = new Properties();\n        FileInputStream fis = new FileInputStream(\"prop.properties\");\n        prop.load(fis);\n        fis.close();\n        System.out.println(prop);\n\n        // 获取全类名和方法名\n        String classname = (String) prop.get(\"classname\");\n        String method = (String) prop.get(\"method\");\n\n        System.out.println(classname+\"||\"+method);\n\n        // 3、利用反射创建对象并运行方法\n        Class aClass = Class.forName(classname);\n\n        // 获取构造方法\n        Constructor cons = aClass.getDeclaredConstructor();\n        Object o = cons.newInstance();\n        System.out.println(o);\n\n        // 获取成员方法并运行\n        Method methods = aClass.getDeclaredMethod(method);\n        methods.setAccessible(true);\n        methods.invoke(o);\n\n    }\n}\n```\n\n## 反射的作用\n\n1. 获取一个类里面所有的信息，获取到了之后，再执行其他的业务逻辑\n\n2. 结合配置文件，动态的创建对象并调用方法\n\n## 总结\n\n![](https://pic.imgdb.cn/item/6429577da682492fcc7b43fe.jpg)\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"网络编程个人笔记","url":"/2023/03/28/网络编程(个人总结)/","content":"# 网络编程\n\n## 什么是网络编程\n\n在网络通信协议下，不同计算机上运行的程序，进行的数据传输。\n\n![](https://pic.imgdb.cn/item/6423078ca682492fcc3468fc.jpg)\n\n![](https://pic.imgdb.cn/item/6423081aa682492fcc358d1f.jpg)\n\n![](https://pic.imgdb.cn/item/642308a0a682492fcc36b252.jpg)\n\n![](https://pic.imgdb.cn/item/642308caa682492fcc371714.jpg)\n\n## 网络编程三要素\n\n![](https://pic.imgdb.cn/item/6423096ba682492fcc3862f2.jpg)\n\n![](https://pic.imgdb.cn/item/64230997a682492fcc38c2cf.jpg)\n\n![image-20230328233737721](C:\\Users\\19183\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230328233737721.png)\n\n![](https://pic.imgdb.cn/item/64230934a682492fcc3806f4.jpg)\n\n## IP\n\n![](https://pic.imgdb.cn/item/64230b72a682492fcc3dc640.jpg)\n\n![](https://pic.imgdb.cn/item/64230cc1a682492fcc3ff843.jpg)\n\n![](https://pic.imgdb.cn/item/64230cf4a682492fcc40524d.jpg)\n\n![](https://pic.imgdb.cn/item/64230db0a682492fcc419611.jpg)\n\n>  疑问：假设192.168.1.100是我电脑的IP,那么这个IP跟127.0.0.1是一样的吗？\n>\n> 不一样\n>\n> 192.168.1.100是路由器分配的，换个路由器地址可能就会变\n>\n> 127.0.0.1是本机IP，当往外发送数据的时候，网卡发现是本机IP就会将数据返回本机\n\n## InetAddress类的使用\n\n \n\n```java\npackage inet.inetaddress;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Test01 {\n    public static void main(String[] args) throws UnknownHostException {\n        /*\n        * static InetAddress getByName(String host)确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址\n        * String getHostName() 获取此IP地址的主机名\n        * String getHostAddress() 返回文本显示中的IP地址字符串\n         */\n        InetAddress byName = InetAddress.getByName(\"jxt\");\n        System.out.println(byName);\n        String hostName = byName.getHostName();\n        System.out.println(hostName);\n        String hostAddress = byName.getHostAddress();\n        System.out.println(hostAddress);\n    }\n}\n```\n\n# 端口号\n\n![](https://pic.imgdb.cn/item/6423dc36a682492fcc3a326c.jpg)\n\n# 协议\n\n![](https://pic.imgdb.cn/item/6423dcbba682492fcc3b68af.jpg)\n\n## TCP/IP模型\n\n![](https://pic.imgdb.cn/item/6423dd0ea682492fcc3c3741.jpg)\n\n![](https://pic.imgdb.cn/item/6423de14a682492fcc3e749a.jpg)\n\n- UDP可以用在不怕数据丢失的场景中，如：网络会议、在线视频等\n- TCP用在对数据安全有要求的情况中，如：下载数据包，网络邮件等\n\n# UDP通信程序\n\n## (发送数据)\n\n\n\n1. 创建发送端的DatagramSocketi对象\n2. 数据打包(DatagramPacket)\n3. 发送数据\n4. 释放数据\n\n \n\n```java\npackage inet.udp;\n\nimport java.io.IOException;\nimport java.net.*;\n\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        // 发送数据\n\n        // 创建DataGramSocket对象\n        // 细节：\n        // 绑定端口，以后我们就是通过这个端口往外发送\n        // 空参：所有可用端口中，随机一个使用\n        // 有参; 指定一个端口进行绑定\n\n        DatagramSocket ds = new DatagramSocket();\n        String a =\"你好啊\";\n        byte[] bytes = a.getBytes();\n        InetAddress byName = InetAddress.getByName(\"127.0.0.1\");\n        int port = 10086;\n\n        DatagramPacket dp  =new DatagramPacket(bytes, bytes.length,byName,port);\n        ds.send(dp);\n        ds.close();\n    }\n}\n```\n\n## (接受数据)\n\n- 创建接收端的DatagramSocketi对象\n- 接收打包好的数据\n- 解析数据包\n- 释放资源\n\n```java\npackage inet.udp;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        // 细节 ：在接受数据的时候一定要绑定端口\n        // 而且绑定的端口一定要和发送的端口保持一致\n        DatagramSocket ds = new DatagramSocket(10086);\n\n        // 接受数据包\n        byte[] bytes = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(bytes, bytes.length);\n\n        // 该方法是阻塞的\n        // 程序运行到这里时会在这里死等\n        // 等待发送端发送消息\n        System.out.println(\"1111\");\n        ds.receive(dp);\n        System.out.println(\"2222\");\n\n        // 解析数据包\n        byte[] data = dp.getData();\n        InetAddress address = dp.getAddress();\n        int length = dp.getLength();\n        int port = dp.getPort();\n        System.out.println(\"数据是\" + new String(data,0,length));\n        System.out.println(\"地址是\" + Arrays.toString(address.getAddress()));\n        System.out.println(\"长度\" + length + \"端口号\" + port);\n\n        // 释放资源\n        ds.close();\n    }\n}\n```\n\n## 练习\n\n聊天室\n\n```java\npackage inet.udp;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Scanner;\n\npublic class SendMessageDemo1 {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket ds = new DatagramSocket();\n        Scanner sc = new Scanner(System.in);\n        byte[] bytes;\n        InetAddress byName = InetAddress.getByName(\"127.0.0.1\");\n        int port = 10086;\n\n        while (true) {\n            System.out.println(\"请输入\");\n            bytes = sc.next().getBytes();\n            DatagramPacket dp = new DatagramPacket(bytes, 0, bytes.length,byName,port);\n            if (\"886\".equals(new String(bytes))) {\n                ds.close();\n                break;\n            }else {\n                ds.send(dp);\n            }\n        }\n    }\n}\n```\n\n```java\npackage inet.udp;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class ReceiveMessageDemo1 {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket ds = new DatagramSocket(10086);\n        byte[] bytes = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(bytes,0,bytes.length);\n        while (true){\n            ds.receive(dp);\n\n            // 解析数据包\n            byte[] data = dp.getData();\n            System.out.println(\"数据是： \"+new String(data,0,dp.getLength()));\n            System.out.println(\"地址是： \"+dp.getAddress());\n            System.out.println(\"端口是： \"+dp.getPort());\n\n        }\n    }\n}\n```\n\n## UDP通信的三种方式\n\n1. 单播\n\n   > 以前的代码就是单播\n\n2. 组播\n\n   > 组播地址：224.0.0.0~239.255.255.255\n   > 其中224.0.0.0~224.0.0.255为预留的组播地址\n\n3. 广播\n\n   > 广播地址：255.255.255.255\n\n### 组播\n\n```java\npackage inet.udp.spread;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\nimport java.util.Scanner;\n\npublic class multicastSend {\n    public static void main(String[] args) throws IOException {\n        MulticastSocket ms = new MulticastSocket();\n        Scanner sc = new Scanner(System.in);\n        while (true){\n            System.out.println(\"请输入\");\n            byte[] bytes = sc.next().getBytes();\n            InetAddress address = InetAddress.getByName(\"224.0.0.2\");\n            int port = 10086;\n            DatagramPacket dp = new DatagramPacket(bytes, 0, bytes.length, address, port);\n            ms.send(dp);\n        }\n\n\n    }\n}\n```\n\n```java\npackage inet.udp.spread;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\n\npublic class multicastReceive {\n    public static void main(String[] args) throws IOException {\n        MulticastSocket ms = new MulticastSocket(10086);\n        // 将当前本机，添加到224.0.0.1的一组当中\n        InetAddress address = InetAddress.getByName(\"224.0.0.2\");\n        ms.joinGroup(address);\n        byte[] bytes = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(bytes, 0, bytes.length);\n        while (true) {\n            ms.receive(dp);\n            System.out.println(\"数据是；\" + new String(dp.getData(), 0, dp.getLength()));\n            System.out.println(\"来自：\" + dp.getAddress().getHostAddress() + \"端口号：\" + dp.getPort() + \"主机号：\" + dp.getAddress().getHostName());\n        }\n\n\n    }\n}\n```\n\n### 广播\n\n```java\npackage inet.udp.spread;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.Scanner;\n\npublic class loudSpreadSend {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket ds = new DatagramSocket();\n        Scanner sc = new Scanner(System.in);\n        byte[] bytes;\n        InetAddress byName = InetAddress.getByName(\"255.255.255.255\");\n        int port = 10086;\n        while (true) {\n            System.out.println(\"请输入\");\n            bytes = sc.next().getBytes();\n            DatagramPacket dp = new DatagramPacket(bytes, 0, bytes.length, byName, port);\n            if (\"886\".equals(new String(bytes))) {\n                ds.close();\n                break;\n            } else {\n                ds.send(dp);\n            }\n        }\n    }\n}\n```\n\n```java\npackage inet.udp.spread;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class loudSpreadReceive {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket ds = new DatagramSocket(10086);\n        byte[] bytes = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(bytes, 0, bytes.length);\n        while (true) {\n            ds.receive(dp);\n\n            // 解析数据包\n            byte[] data = dp.getData();\n            System.out.println(\"数据是： \" + new String(data, 0, dp.getLength()));\n            System.out.println(\"ip地址是： \" + dp.getAddress().getHostAddress());\n            System.out.println(\"主机名\" + dp.getAddress().getHostName());\n            System.out.println(\"端口是： \" + dp.getPort());\n        }\n    }\n}\n```\n\n# TCP的通信\n\n![](https://pic.imgdb.cn/item/6427bef4a682492fcc3ea36d.jpg)\n\n![](https://pic.imgdb.cn/item/6427bf4da682492fcc3f040d.jpg) \n\n## 练习\n\n```java\npackage inet.tcp;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        // TCP协议发送数据\n\n        // 创建SOCKET对象\n        // 细节：在创建对象的同时会链接服务端\n        // 如果连不上，代码会报错\n\n        Socket socket = new Socket(\"127.0.0.1\",10000);\n        OutputStream os = socket.getOutputStream();\n        os.write(\"aaa\".getBytes());\n        os.close();\n        socket.close();\n    }\n}\n```\n\n```java\npackage inet.tcp;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TestReceive01 {\n    public static void main(String[] args) throws IOException {\n        // TCP接受数据\n\n        // 创建ServerSocket对象\n        ServerSocket ss = new ServerSocket(10000);\n        // 监听客户端的链接\n        Socket socket = ss.accept();\n        // 从连接通道中获取输入流读取数据\n        InputStream inputStream = socket.getInputStream();\n        int b;\n        while ((b = inputStream.read())!= -1){\n            System.out.println((char) b);\n        }\n        inputStream.close();\n        // 断开与客户端的链接\n        socket.close();\n        // 关闭服务器\n        ss.close();\n    }\n}\n```\n\n### 有中文的情况\n\n> 一个中文多个字节，如果用字节流读取只能一个字节一个字节读，造成编码错误，所以应该转换流转成字符流再进行读取\n\n```java\npackage inet.tcp;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        // TCP协议发送数据\n\n        // 创建SOCKET对象\n        // 细节：在创建对象的同时会链接服务端\n        // 如果连不上，代码会报错\n\n        Socket socket = new Socket(\"127.0.0.1\",10000);\n        OutputStream os = socket.getOutputStream();\n        os.write(\"好好好好哦啊\".getBytes());\n        os.close();\n        socket.close();\n    }\n}\n```\n\n```java\npackage inet.tcp;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TestReceive01 {\n    public static void main(String[] args) throws IOException {\n        // TCP接受数据\n\n        // 创建ServerSocket对象\n        ServerSocket ss = new ServerSocket(10000);\n        // 监听客户端的链接\n        Socket socket = ss.accept();\n        // 从连接通道中获取输入流读取数据\n        InputStream inputStream = socket.getInputStream();\n        InputStreamReader isr = new InputStreamReader(inputStream);\n        BufferedReader bfr = new BufferedReader(isr);\n        int b;\n        while ((b = bfr.read())!= -1){\n            System.out.print((char) b);\n        }\n        inputStream.close();\n        // 断开与客户端的链接\n        socket.close();\n        // 关闭服务器\n        ss.close();\n    }\n}\n```\n\n## TCP协议代码细节\n\n![](https://pic.imgdb.cn/item/6427c636a682492fcc49ff11.jpg)\n\n- 建立连接时：  三次握手协议保证连接建立\n- 断开连接时：  四次挥手，利用这个协议断开连接，而且保证连接通道里面的数据已经处理完毕了\n\n## 三次握手\n\n![](https://pic.imgdb.cn/item/6427c759a682492fcc4b54c4.jpg)\n\n### 四次挥手\n\n![](https://pic.imgdb.cn/item/6427c780a682492fcc4b85ff.jpg)\n\n# 综合练习\n\n1.\n\n客户端：多次发送数据\n服务器：接收多次接收数据，并打印\n\n```java\npackage inet.tcp;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class Send02 {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"127.0.0.1\", 10000);\n        Scanner sc = new Scanner(System.in);\n        OutputStream os = socket.getOutputStream();\n        while (true) {\n            System.out.println(\"请输入：\");\n            String val = sc.next();\n\n            if (val.equals(\"886\")) {\n                break;\n            } else {\n                val += \"\\n\\r\";\n                os.write(val.getBytes());\n            }\n\n        }\n        socket.close();\n    }\n}\n```\n\n```java\npackage inet.tcp;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Receive02 {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(10000);\n        Socket socket = ss.accept();\n        InputStream is = socket.getInputStream();\n        BufferedReader bfr = new BufferedReader(new InputStreamReader(is));\n        int b;\n        while ((b = bfr.read())!=-1){\n            System.out.print((char) b);\n        }\n        socket.close();\n        ss.close();\n\n    }\n}\n```\n\n### 练习2\n\n客户端：发送一条数据，接收服务端反馈的消息并打印\n服务器：接收数据并打印，再给客户端反馈消息\n\n> 细节：\n> read方法会从连接通道中读取数据\n> 但是，需要有一个结束标记，此处的循环才会停止\n> 否则，程序就会一直停在read方法这里，等待读取下面的数据\n\n```java\npackage inet.tcp;\n\nimport java.io.*;\nimport java.net.Socket;\n\npublic class Client03 {\n    public static void main(String[] args) throws IOException {\n        Socket socket =new Socket(\"127.0.0.1\",10000);\n        OutputStream os = socket.getOutputStream();\n        os.write(\"见到你很高兴！！！\\n\\r\".getBytes());\n        // 写出一个结束标记\n        socket.shutdownOutput();\n\n        InputStream is = socket.getInputStream();\n        BufferedReader bfd = new BufferedReader(new InputStreamReader(is));\n        int b;\n        while ((b = bfd.read()) != -1) {\n            System.out.print((char) b);\n        }\n\n        socket.close();\n    }\n}\n```\n\n```java\npackage inet.tcp;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server03 {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(10000);\n        Socket socket = ss.accept();\n        InputStream is = socket.getInputStream();\n        BufferedReader bfd = new BufferedReader(new InputStreamReader(is));\n        int b;\n        while ((b = bfd.read()) != -1) {\n            System.out.print((char) b);\n        }\n\n        OutputStream os = socket.getOutputStream();\n        os.write(\"俺也一样！！\\n\\r\".getBytes());\n        // socket.shutdownOutput();\n        socket.close();\n        ss.close();\n    }\n}\n```\n\n \t ### 练习3\n\n客户端：将本地文件上传到服务器。接收服务器的反馈。\n服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n```java\npackage inet.tcp;\n\nimport java.io.*;\nimport java.net.Socket;\n\npublic class Client04 {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"127.0.0.1\", 10000);\n        FileInputStream fip = new FileInputStream(\"src/inet/tcp/clientdir/wallhaven-zym92v_1920x1080.png\");\n        OutputStream os = socket.getOutputStream();\n        BufferedInputStream bis = new BufferedInputStream(fip);\n        int len;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read(bytes))!=-1){\n            os.write(bytes,0,len);\n        }\n        socket.shutdownOutput();\n        bis.close();\n\n        // 接受数据\n        InputStream is = socket.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is);\n        int b;\n        while ((b = isr.read())!=-1){\n            System.out.print((char) b);\n        }\n\n        socket.close();\n    }\n}\n```\n\n```java\npackage inet.tcp;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server04 {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(10000);\n        Socket socket = ss.accept();\n        InputStream is = socket.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(is);\n        FileOutputStream fos = new FileOutputStream(\"src/inet/tcp/serverdir/wallhaven-zym92v_1920x1080.png\");\n        int len;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fos.close();\n        OutputStream os = socket.getOutputStream();\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));\n        bw.write(\"上传成功\");\n        bw.newLine();\n        bw.flush();\n\n        bw.close();\n        socket.close();\n        ss.close();\n\n\n\n    }\n}\n```\n\n### 练习四UUID\n\n```java\npackage inet.tcp;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.UUID;\n\npublic class Server04 {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(10000);\n        Socket socket = ss.accept();\n        InputStream is = socket.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(is);\n        String name = UUID.randomUUID().toString().replace(\"-\", \"\");\n        FileOutputStream fos = new FileOutputStream(\"src/inet/tcp/serverdir/\" + name + \".png\");\n        int len;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fos.close();\n        OutputStream os = socket.getOutputStream();\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));\n        bw.write(\"上传成功\");\n        bw.newLine();\n        bw.flush();\n\n        bw.close();\n        socket.close();\n        ss.close();\n\n\n    }\n}\n```\n\n## 练习5 \n\n多线程向服务器上传文件\n\n！！切记调用flush方法冲刷缓冲区\n\n```java\npackage inet.tcp;\n\nimport java.io.*;\nimport java.net.Socket;\n\npublic class Client05 {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"127.0.0.1\",10086);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"src/inet/tcp/clientdir/kkk.mp4\"));\n        OutputStream os = socket.getOutputStream();\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes))!= -1){\n            os.write(bytes,0,len);\n        }\n        socket.shutdownOutput();\n\n        InputStream is = socket.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is);\n        int b;\n        while ((b = isr.read())!= -1){\n            System.out.print((char) b);\n        }\n        socket.close();\n\n    }\n}\n```\n\n```java\npackage inet.tcp;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server05 {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(10086);\n        while (true){\n            Socket socket = ss.accept();\n            new Thread(new myRunnable05(socket)).start();\n\n        }\n\n    }\n}\n```\n\n```java\npackage inet.tcp;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.UUID;\n\npublic class myRunnable05 implements Runnable {\n    Socket socket;\n\n    public myRunnable05(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        String uuid = UUID.randomUUID().toString().replace(\"-\", \"\");\n        try {\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"src/inet/tcp/serverdir/\" + uuid + \".mp4\"));\n            InputStream is = socket.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            byte[] bytes = new byte[1024];\n            int len;\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n            }\n            bos.flush();\n            OutputStream os = socket.getOutputStream();\n            os.write(\"上传成功\".getBytes());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                if (socket != null) {\n                    socket.close();\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n\n    }\n}\n```\n\n## 练习6\n\n多线程向服务器上传文件（利用线程池）\n\n```java\npackage inet.tcp;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class Server05_02 {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(10086);\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                3,// 核心线程数量\n                16,// 线程池总大小\n                60,//空闲时间\n                TimeUnit.SECONDS,//空闲时间单位\n                new ArrayBlockingQueue<>(2),// 队列\n                Executors.defaultThreadFactory(), // 线程工厂\n                new ThreadPoolExecutor.AbortPolicy() // 阻塞队列\n        );\n        while (true) {\n            Socket socket = ss.accept();\n            // new Thread(new myRunnable05(socket)).start();\n            pool.submit(new myRunnable05(socket));\n        }\n\n    }\n}\n```","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"多线程个人笔记","url":"/2023/03/26/多线程03/","content":"# Lock锁\n\n## 代码实现\n\n```java\npackage thread.day3;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        Thread01 thread01 = new Thread01();\n        Thread01 thread02 = new Thread01();\n        Thread01 thread03 = new Thread01();\n\n        thread01.setName(\"a\");\n        thread02.setName(\"b\");\n        thread03.setName(\"c\");\n\n        thread01.start();\n        thread02.start();\n        thread03.start();\n    }\n}\n```\n\n```java\npackage thread.day3;\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Thread01 extends Thread {\n    static int ticket = 0;\n    static Lock lock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        while (true) {\n            lock.lock();\n            try {\n                if (ticket == 100) {\n                    break;\n                } else {\n                    Thread.sleep(100);\n                    ticket++;\n                    System.out.println(getName() + \"当前票数为\" + ticket + \"张！！！\");\n                }\n\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            } finally {\n                lock.unlock();\n\n            }\n\n        }\n    }\n\n}\n```\n\n## 死锁\n\n死锁是一个可能遇到的书写错误\n\n**在写锁的时候千万不要让两个锁嵌套起来**\n\n# 生产者和消费者(等待唤醒机制)\n\n> 生产者消费者模式是一个十分经典的多线程协作的模式\n>\n> 实现线程轮流实现交替执行的效果 \n\n\n\n\n![](https://pic.imgdb.cn/item/641fec11a682492fcc6f0485.jpg)\n\n\n\n## 消费者等待\n- 消费者：消费数据\n\n  > 1.判断桌子上是否有食物\n  > 2.如果没有就等待\n\n- 生产者：生产数据\n\n  > 1.制作食物\n  > 2.把食物放在桌子上\n  > 3.叫醒等待的消费者开吃\n\n\n![](https://pic.imgdb.cn/item/641fec8ba682492fcc6fbca5.jpg)\n\n![](https://pic.imgdb.cn/item/641fecb9a682492fcc70028a.jpg)\n\n![](https://pic.imgdb.cn/item/641fecf2a682492fcc7053ff.jpg)\n\n![](https://pic.imgdb.cn/item/641fed1ca682492fcc708f8c.jpg)\n\n## 生产者等待\n\n- 消费者：消费数据\n\n  > 1.判断桌子上是否有食物\n  > 2.如果没有就等待\n  >\n  > 3 .如果有就开吃\n  > 4.吃完之后，唤醒厨师继续做\n\n- 生产者：生产数据\n\n  > 1.判断桌子上是否有食物\n  > 2.有：等待\n  > 3.没有：制作食物\n  > 4.把食物放在桌子上\n  > 5.叫醒等待的消费者开吃\n\n## 完整过程\n\n![](https://pic.imgdb.cn/item/641fee8aa682492fcc72c9f5.jpg)\n\n## 常见方法\n\n| 方法名称         | 说明                             |\n| :--------------- | :------------------------------- |\n| void wait()      | 当前线程等待，直到被其他线程唤醒 |\n| void notify()    | 随机唤醒单个线程                 |\n| void notifyAll() | 唤醒所有线程                     |\n\n## 代码实现\n\n```java\npackage thread.day3;\n\npublic class Desk {\n    /*\n    *\n    *  作用：控制生产者和消费者的执行\n    *\n    * */\n    // 是否有面条 1 ：有 ； 0 ；没有\n    public static int foodFlag = 0;\n\n    // 总个数\n    public static int count = 10;\n\n    //锁对象\n    public static Object lock = new Object();\n}\n```\n\n```java\npackage thread.day3;\n\npublic class Foodie extends Thread {\n    /*\n     *\n     * 1.循环\n     * 2.同步代码块\n     * 3.判断共享数据是否到了末尾（到了末尾）\n     * 4,判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）\n     *\n     */\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (Desk.lock) {\n                if (Desk.count == 0) {\n                    break;\n                } else {\n                    // 先判断桌子上是否有面条\n                    if (Desk.foodFlag == 0) {\n                        try {\n                            // 如果没有就等待\n                            Desk.lock.wait(); // 让当前线程跟锁进行绑定\n                        } catch (InterruptedException e) {\n                            throw new RuntimeException(e);\n                        }\n\n                    } else {\n                        // 把吃的总数减一\n                        Desk.count--;\n                        // 如果有就开吃\n                        System.out.println(\"吃货正在吃面条，还能吃\" + Desk.count + \"碗！！\");\n                        // 吃完之后,唤醒厨师继续做\n                        Desk.lock.notifyAll();\n                        // 改变桌子的状态\n                        Desk.foodFlag = 0;\n\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage thread.day3;\n\npublic class Cook extends Thread {\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (Desk.lock) {\n                if (Desk.count == 0) {\n                    break;\n                } else {\n                    // 判断桌子上是否有食物\n                    if (Desk.foodFlag == 1) {\n                        try {\n                            // 如果有就等待\n                            Desk.lock.wait();\n                        } catch (InterruptedException e) {\n                            throw new RuntimeException(e);\n                        }\n                    } else {\n                        // 如果没有就制作食物\n                        System.out.println(\"厨师做了一碗面\");\n                        // 修改桌子上食物的状态\n                        Desk.foodFlag = 1;\n                        // 叫醒等待的消费者开吃\n                        Desk.lock.notifyAll();\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage thread.day3;\n\npublic class Thread02 {\n    // 等待唤醒机制\n    // 实现线程交替执行的代码结果\n    public static void main(String[] args) {\n        Cook cook = new Cook();\n        Foodie food = new Foodie();\n        cook.setName(\"厨师\");\n        food.setName(\"消费者\");\n        cook.start();\n        food.start();\n    }\n\n\n\n}\n```\n\n# 等待唤醒机制（阻塞队列方式实现）\n\n![](https://pic.imgdb.cn/item/641ffc3ea682492fcc8a8d0d.jpg)\n\n![](https://pic.imgdb.cn/item/641ffc94a682492fcc8b0a4c.jpg)\n\n## 代码实现\n\n```java\npackage thread.day3;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class Thread03 {\n    /*\n    *\n    * 需求：利用阻塞队列完成生产者和消费者（等待唤醒机制）的代码\n    *       细节：\n    *           消费者和生产者必须使用同一个队列\n    *\n    *\n     */\n    public static void main(String[] args) {\n        ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(1);\n        Cook2 cook2 = new Cook2(queue);\n        Foodie2 food = new Foodie2(queue);\n        cook2.start();\n        food.start();\n\n    }\n\n}\n```\n\n```java\npackage thread.day3;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class Cook2 extends Thread{\n    ArrayBlockingQueue<String> queue;\n\n    public Cook2(ArrayBlockingQueue<String> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        while (true){\n            try {\n                queue.put(\"做饭\");\n                System.out.println(\"厨师做了一碗面条\");\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n\n\n        }\n    }\n}\n```\n\n```java\npackage thread.day3;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class Foodie2 extends Thread {\n    ArrayBlockingQueue<String> queue;\n\n    public Foodie2( ArrayBlockingQueue<String> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        while (true){\n            try {\n                String take = queue.take();\n                System.out.println(take);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n\n        }\n    }\n}\n```\n\n# 线程的状态\n\n![](https://pic.imgdb.cn/item/642010caa682492fccaecbf0.jpg)\n\n![](https://pic.imgdb.cn/item/642011d3a682492fccb0edc8.jpg)\n\nJVM中并没有定义运行状态\n\n![](https://pic.imgdb.cn/item/64201202a682492fccb15588.jpg)\n\n\n\n# 线程池\n\n![](https://pic.imgdb.cn/item/6422b074a682492fcc938703.jpg)\n\n## 线程池的核心原理\n\n\n\n![](https://pic.imgdb.cn/item/6422b0e1a682492fcc9439ee.jpg)\n\n```java\npackage thread.day4.threadpool;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        //获取线程池对象\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        //提交任务\n        executorService.submit(new Thread01());\n        executorService.submit(new Thread01());\n        executorService.submit(new Thread01());\n        executorService.submit(new Thread01());\n        // 销毁线程池\n         executorService.shutdown();\n    }\n}\n```\n\n```java\npackage thread.day4.threadpool;\n\npublic class Thread01 implements Runnable {\n    static int i = 0;\n    @Override\n    public void run() {\n        while (true){\n            synchronized (Thread01.class){\n                if (i==100)\n                    break;\n                System.out.println(Thread.currentThread().getName() + \"----\" + i);\n                i++;\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n\n    }\n}\n```\n\n# 自定义线程池\n\n![image-20230328202816179](C:\\Users\\19183\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230328202816179.png)\n\n![](https://pic.imgdb.cn/item/6422deb6a682492fcce66405.jpg)\n\n**临时线程会处理在队列之外的任务**\n\n```java\npackage thread.day4.threadpool;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class Test02 {\n\n\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                3, //参数一：核心线程数量,不能小于0\n                6, // 参数二：最大线程数不能小于0，最大数量 >= 核心线程数量\n                60, // 参数三：空闲线程最大存活时间不能小于0\n                TimeUnit.SECONDS, // 参数四：时间单位用TimeUnit指定\n                new ArrayBlockingQueue<>(3), // 参数五：任务队列不能为null\n                Executors.defaultThreadFactory(), // 参数六：创建线程工厂不能为null\n                new ThreadPoolExecutor.AbortPolicy() // 参数七：任务的拒绝策略不能为null\n        );\n        pool.submit(new Thread01());\n        pool.submit(new Thread01());\n        pool.submit(new Thread01());\n        pool.submit(new Thread01());\n        pool.submit(new Thread01());\n        pool.submit(new Thread01());\n        pool.submit(new Thread01());\n        pool.submit(new Thread01());\n\n    }\n}\n```\n\n# 线程池多大合适\n\n```java\npackage thread.day4.threadpool;\n\npublic class Test04 {\n    public static void main(String[] args) {\n        // 获取JVM能获取的最大线程数\n        int i = Runtime.getRuntime().availableProcessors();\n        System.out.println(i);\n    }\n}\n```\n\n![](https://pic.imgdb.cn/item/642304a9a682492fcc2fbb79.jpg)\n\n> cpu计算时间和等待时间可以用  thread dump 测试\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"多线程02","url":"/2023/03/26/多线程02/","content":"## 1. 线程池\n\n### 1.1 线程状态介绍\n\n当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\n\n```java\npublic class Thread {\n    \n    public enum State {\n    \n        /* 新建 */\n        NEW , \n\n        /* 可运行状态 */\n        RUNNABLE , \n\n        /* 阻塞状态 */\n        BLOCKED , \n\n        /* 无限等待状态 */\n        WAITING , \n\n        /* 计时等待 */\n        TIMED_WAITING , \n\n        /* 终止 */\n        TERMINATED;\n    \n\t}\n    \n    // 获取当前线程的状态\n    public State getState() {\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n    \n}\n```\n\n通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n\n| 线程状态          | 具体含义                                     |\n| ------------- | ---------------------------------------- |\n| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |\n| RUNNABLE      | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |\n| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |\n| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |\n| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |\n| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态             |\n\n各个状态的转换，如下图所示：\n\n![1591163781941](.\\img\\1591163781941.png)\n\n### 1.2 线程池-基本原理\n\n**概述 :** \n\n​\t提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n\n线程池存在的意义：\n\n​\t系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n\n​\t统资源的消耗，这样就有点\"舍本逐末\"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n\n​\t会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n\n**线程池的设计思路 :**\n\n1. 准备一个任务容器\n2. 一次性启动多个(2个)消费者线程\n3. 刚开始任务容器是空的，所以线程都在wait\n4. 直到一个外部线程向这个任务容器中扔了一个\"任务\"，就会有一个消费者线程被唤醒\n5. 这个消费者线程取出\"任务\"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来\n\n### 1.3 线程池-Executors默认线程池\n\n概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n\n我们可以使用Executors中所提供的**静态**方法来创建线程池\n\n​\tstatic ExecutorService newCachedThreadPool()   创建一个默认的线程池\n​\tstatic newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n\n//static ExecutorService newCachedThreadPool()   创建一个默认的线程池\n//static newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MyThreadPoolDemo {\n    public static void main(String[] args) throws InterruptedException {\n\n        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        //Executors --- 可以帮助我们创建线程池对象\n        //ExecutorService --- 可以帮助我们控制线程池\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + \"在执行了\");\n        });\n\n        //Thread.sleep(2000);\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + \"在执行了\");\n        });\n\n        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.4 线程池-Executors创建指定上限的线程池\n\n**使用Executors中所提供的静态方法来创建线程池**\n\n​\tstatic ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n//static ExecutorService newFixedThreadPool(int nThreads)\n//创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class MyThreadPoolDemo2 {\n    public static void main(String[] args) {\n        //参数不是初始值而是最大值\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;\n        System.out.println(pool.getPoolSize());//0\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + \"在执行了\");\n        });\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + \"在执行了\");\n        });\n\n        System.out.println(pool.getPoolSize());//2\n//        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.5 线程池-ThreadPoolExecutor\n\n**创建线程池对象 :** \n\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyThreadPoolDemo3 {\n//    参数一：核心线程数量\n//    参数二：最大线程数\n//    参数三：空闲线程最大存活时间（非核心线程存活时间）\n//    参数四：时间单位\n//    参数五：任务队列\n//    参数六：创建线程工厂\n//    参数七：任务的拒绝策略\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());\n        pool.submit(new MyRunnable());\n        pool.submit(new MyRunnable());\n\n        pool.shutdown();\n    }\n}\n```\n\n### 1.6 线程池-参数详解\n\n![1591165506516](.\\img\\1591165506516.png)\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n    \ncorePoolSize：   核心线程的最大值，不能小于0\nmaximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize\nkeepAliveTime：  非核心线程存活时间,不能小于0\nunit：           时间单位\nworkQueue：      任务队列，不能为null\nthreadFactory：  创建线程工厂,不能为null      \nhandler：        任务的拒绝策略,不能为null  \n```\n\n\n\n### 1.7 线程池-非默认任务拒绝策略\n\nRejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\n\n```java\nThreadPoolExecutor.AbortPolicy: \t\t    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。\nThreadPoolExecutor.DiscardPolicy： \t\t   丢弃任务，但是不抛出异常 这是不推荐的做法。\nThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。\nThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。\n```\n\n注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n\n**案例演示1**：演示ThreadPoolExecutor.AbortPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1---->> 执行了任务\npool-1-thread-3---->> 执行了任务\npool-1-thread-2---->> 执行了任务\npool-1-thread-3---->> 执行了任务\n```\n\n控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示2**：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1---->> 执行了任务\npool-1-thread-1---->> 执行了任务\npool-1-thread-3---->> 执行了任务\npool-1-thread-2---->> 执行了任务\n```\n\n控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示3**：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰\n            final int y = x ;\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\" + y);\n            });     \n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-2---->> 执行了任务2\npool-1-thread-1---->> 执行了任务0\npool-1-thread-3---->> 执行了任务3\npool-1-thread-1---->> 执行了任务4\n```\n\n由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n\n\n\n**案例演示4**：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo04 {\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + \"---->> 执行了任务\");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1---->> 执行了任务\npool-1-thread-3---->> 执行了任务\npool-1-thread-2---->> 执行了任务\npool-1-thread-1---->> 执行了任务\nmain---->> 执行了任务\n```\n\n通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n\n## 2. 多线程综合练习\n\n### 练习一：售票\n\n需求：\n\n​\t一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,\n\n​\t请用多线程模拟卖票过程并打印剩余电影票的数量\n\n代码示例：\n\n```java\npublic class MyThread extends Thread {\n\n    //第一种方式实现多线程，测试类中MyThread会创建多次，所以需要加static\n    static int ticket = 1000;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (ticket == 0) {\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    try {\n                        Thread.sleep(3000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    ticket--;\n                    System.out.println(getName() + \"在卖票，还剩下\" + ticket + \"张票!!!\");\n                }\n            }\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n       /*\n            一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,\n            要求:请用多线程模拟卖票过程并打印剩余电影票的数量\n        */\n\n        //创建线程对象\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n\n        //给线程设置名字\n        t1.setName(\"窗口1\");\n        t2.setName(\"窗口2\");\n\n        //开启线程\n        t1.start();\n        t2.start();\n\n    }\n}\n\n```\n\n\n\n### 练习二：赠送礼物\n\n需求：\n\n​\t有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出。\n\n​\t利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.\n\n```java\npublic class MyRunable implements Runnable {\n\n    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static\n    int count = 100;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (count < 10) {\n                    System.out.println(\"礼物还剩下\" + count + \"不再赠送\");\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"在赠送礼物，还剩下\" + count + \"个礼物!!!\");\n                }\n            }\n        }\n    }\n}\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出，\n            利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.\n        */\n\n        //创建参数对象\n        MyRunable mr = new MyRunable();\n\n        //创建线程对象\n        Thread t1 = new Thread(mr,\"窗口1\");\n        Thread t2 = new Thread(mr,\"窗口2\");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n\n\n### 练习三：打印数字\n\n需求：\n\n​\t同时开启两个线程，共同获取1-100之间的所有数字。\n\n​\t将输出所有的奇数。\n\n```java\npublic class MyRunable implements Runnable {\n\n    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static\n    int number = 1;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (number > 100) {\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    if(number % 2 == 1){\n                        System.out.println(Thread.currentThread().getName() + \"打印数字\" + number);\n                    }\n                    number++;\n                }\n            }\n        }\n    }\n}\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n           同时开启两个线程，共同获取1-100之间的所有数字。\n           要求：将输出所有的奇数。\n        */\n\n\n        //创建参数对象\n        MyRunable mr = new MyRunable();\n\n        //创建线程对象\n        Thread t1 = new Thread(mr,\"线程A\");\n        Thread t2 = new Thread(mr,\"线程B\");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n### 练习四：抢红包\n\n需求：\n\n​\t抢红包也用到了多线程。\n\n​\t假设：100块，分成了3个包，现在有5个人去抢。\n\n​\t其中，红包是共享数据。\n\n​\t5个人是5条线程。\n\n​\t打印结果如下：\n\n​\t\t  XXX抢到了XXX元\n\n​\t\t  XXX抢到了XXX元\n\n \t\t XXX抢到了XXX元\n \t\n \t\tXXX没抢到\n \t\n \t\tXXX没抢到\n\n解决方案一：\n\n```java\npublic class MyThread extends Thread{\n\n    //共享数据\n    //100块，分成了3个包\n    static double money = 100;\n    static int count = 3;\n\n    //最小的中奖金额\n    static final double MIN = 0.01;\n\n    @Override\n    public void run() {\n        //同步代码块\n        synchronized (MyThread.class){\n            if(count == 0){\n                //判断，共享数据是否到了末尾（已经到末尾）\n                System.out.println(getName() + \"没有抢到红包！\");\n            }else{\n                //判断，共享数据是否到了末尾（没有到末尾）\n                //定义一个变量，表示中奖的金额\n                double prize = 0;\n                if(count == 1){\n                    //表示此时是最后一个红包\n                    //就无需随机，剩余所有的钱都是中奖金额\n                    prize = money;\n                }else{\n                    //表示第一次，第二次（随机）\n                    Random r = new Random();\n                    //100 元   3个包\n                    //第一个红包：99.98\n                    //100 - (3-1) * 0.01\n                    double bounds = money - (count - 1) * MIN;\n                    prize = r.nextDouble(bounds);\n                    if(prize < MIN){\n                        prize = MIN;\n                    }\n                }\n                //从money当中，去掉当前中奖的金额\n                money = money - prize;\n                //红包的个数-1\n                count--;\n                //本次红包的信息进行打印\n                System.out.println(getName() + \"抢到了\" + prize + \"元\");\n            }\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            微信中的抢红包也用到了多线程。\n            假设：100块，分成了3个包，现在有5个人去抢。\n            其中，红包是共享数据。\n            5个人是5条线程。\n            打印结果如下：\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX没抢到\n            \tXXX没抢到\n        */\n\n        //创建线程的对象\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        MyThread t3 = new MyThread();\n        MyThread t4 = new MyThread();\n        MyThread t5 = new MyThread();\n\n        //给线程设置名字\n        t1.setName(\"小A\");\n        t2.setName(\"小QQ\");\n        t3.setName(\"小哈哈\");\n        t4.setName(\"小诗诗\");\n        t5.setName(\"小丹丹\");\n\n        //启动线程\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n    }\n}\n```\n\n解决方案二：\n\n```java\npublic class MyThread extends Thread{\n\n    //总金额\n    static BigDecimal money = BigDecimal.valueOf(100.0);\n    //个数\n    static int count = 3;\n    //最小抽奖金额\n    static final BigDecimal MIN = BigDecimal.valueOf(0.01);\n\n    @Override\n    public void run() {\n        synchronized (MyThread.class){\n            if(count == 0){\n                System.out.println(getName() + \"没有抢到红包！\");\n            }else{\n                //中奖金额\n                BigDecimal prize;\n                if(count == 1){\n                    prize = money;\n                }else{\n                    //获取抽奖范围\n                    double bounds = money.subtract(BigDecimal.valueOf(count-1).multiply(MIN)).doubleValue();\n                    Random r = new Random();\n                    //抽奖金额\n                    prize = BigDecimal.valueOf(r.nextDouble(bounds));\n                }\n                //设置抽中红包，小数点保留两位，四舍五入\n                prize = prize.setScale(2,RoundingMode.HALF_UP);\n                //在总金额中去掉对应的钱\n                money = money.subtract(prize);\n                //红包少了一个\n                count--;\n                //输出红包信息\n                System.out.println(getName() + \"抽中了\" + prize + \"元\");\n            }\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            微信中的抢红包也用到了多线程。\n            假设：100块，分成了3个包，现在有5个人去抢。\n            其中，红包是共享数据。\n            5个人是5条线程。\n            打印结果如下：\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX没抢到\n            \tXXX没抢到\n        */\n\n\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        MyThread t3 = new MyThread();\n        MyThread t4 = new MyThread();\n        MyThread t5 = new MyThread();\n\n        t1.setName(\"小A\");\n        t2.setName(\"小QQ\");\n        t3.setName(\"小哈哈\");\n        t4.setName(\"小诗诗\");\n        t5.setName(\"小丹丹\");\n\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n    }\n}\n```\n\n### 练习五：抽奖箱\n\n需求：\n\n​\t有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700}; \n\n创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” \n\n随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n\n​               每次抽出一个奖项就打印一个(随机)\n\n​\t\t抽奖箱1 又产生了一个 10 元大奖\n\n  \t\t抽奖箱1 又产生了一个 100 元大奖\n  \t\n  \t\t抽奖箱1 又产生了一个 200 元大奖\n  \t\n  \t\t抽奖箱1 又产生了一个 800 元大奖  \n\n​\t\t抽奖箱2 又产生了一个 700 元大奖  \n\n \t\t .....\n\n```java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        //1.循环\n        //2.同步代码块\n        //3.判断\n        //4.判断\n\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    System.out.println(getName() + \"又产生了一个\" + prize + \"元大奖\");\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n                             每次抽出一个奖项就打印一个(随机)\n            \t抽奖箱1 又产生了一个 10 元大奖\n            \t抽奖箱1 又产生了一个 100 元大奖\n            \t抽奖箱1 又产生了一个 200 元大奖\n            \t抽奖箱1 又产生了一个 800 元大奖\n            \t抽奖箱2 又产生了一个 700 元大奖\n            \t.....\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n        //设置名字\n        t1.setName(\"抽奖箱1\");\n        t2.setName(\"抽奖箱2\");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n\n\n### 练习六：多线程统计并求最大值\n\n需求：\n\n​\t在上一题基础上继续完成如下需求：\n\n​     每次抽的过程中，不打印，抽完时一次性打印(随机)\n\n​     在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n\n​              分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n\n​     在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n\n​              分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n\n解决方案一：\n\n```java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    //线程一\n    static ArrayList<Integer> list1 = new ArrayList<>();\n    //线程二\n    static ArrayList<Integer> list2 = new ArrayList<>();\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    if(\"抽奖箱1\".equals(getName())){\n                        System.out.println(\"抽奖箱1\" + list1);\n                    }else {\n                        System.out.println(\"抽奖箱2\" + list2);\n                    }\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    if(\"抽奖箱1\".equals(getName())){\n                        list1.add(prize);\n                    }else {\n                        list2.add(prize);\n                    }\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n        //设置名字\n        t1.setName(\"抽奖箱1\");\n        t2.setName(\"抽奖箱2\");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n解决方案二：\n\n```java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        ArrayList<Integer> boxList = new ArrayList<>();//1 //2\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    System.out.println(getName() + boxList);\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    boxList.add(prize);\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n\n        //设置名字\n        t1.setName(\"抽奖箱1\");\n        t2.setName(\"抽奖箱2\");\n\n\n        //启动线程\n        t1.start();\n        t2.start();\n\n    }\n}\n```\n\n\n\n### 练习七：多线程之间的比较 \n\n需求：\n\n​\t在上一题基础上继续完成如下需求：\n\n​\t在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300\n\n  \t最高奖项为300元，总计额为932元\n\n​\t在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700\n\n  \t最高奖项为800元，总计额为1835元\n\n​\t在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n\n​\t以上打印效果只是数据模拟,实际代码运行的效果会有差异\n\n```java\npublic class MyCallable implements Callable<Integer> {\n\n    ArrayList<Integer> list;\n\n    public MyCallable(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        ArrayList<Integer> boxList = new ArrayList<>();//1 //2\n        while (true) {\n            synchronized (MyCallable.class) {\n                if (list.size() == 0) {\n                    System.out.println(Thread.currentThread().getName() + boxList);\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    boxList.add(prize);\n                }\n            }\n            Thread.sleep(10);\n        }\n        //把集合中的最大值返回\n        if(boxList.size() == 0){\n            return null;\n        }else{\n            return Collections.max(boxList);\n        }\n    }\n}\n\npackage com.itheima.test7;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class Test {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为    \"抽奖箱1\", \"抽奖箱2\"\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n\n            在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300\n        \t    最高奖项为300元，总计额为932元\n\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700\n            \t最高奖项为800元，总计额为1835元\n\n            在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n            核心逻辑：获取线程抽奖的最大值（看成是线程运行的结果）\n\n\n            以上打印效果只是数据模拟,实际代码运行的效果会有差异\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建多线程要运行的参数对象\n        MyCallable mc = new MyCallable(list);\n\n        //创建多线程运行结果的管理者对象\n        //线程一\n        FutureTask<Integer> ft1 = new FutureTask<>(mc);\n        //线程二\n        FutureTask<Integer> ft2 = new FutureTask<>(mc);\n\n        //创建线程对象\n        Thread t1 = new Thread(ft1);\n        Thread t2 = new Thread(ft2);\n\n        //设置名字\n        t1.setName(\"抽奖箱1\");\n        t2.setName(\"抽奖箱2\");\n\n        //开启线程\n        t1.start();\n        t2.start();\n\n\n        Integer max1 = ft1.get();\n        Integer max2 = ft2.get();\n\n        System.out.println(max1);\n        System.out.println(max2);\n\n        //在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n        if(max1 == null){\n            System.out.println(\"在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为\"+max2+\"元\");\n        }else if(max2 == null){\n            System.out.println(\"在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为\"+max1+\"元\");\n        }else if(max1 > max2){\n            System.out.println(\"在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为\"+max1+\"元\");\n        }else if(max1 < max2){\n            System.out.println(\"在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为\"+max2+\"元\");\n        }else{\n            System.out.println(\"两者的最大奖项是一样的\");\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n## 2. 原子性\n\n### 2.1 volatile-问题\n\n**代码分析 :** \n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName(\"小路同学\");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName(\"小皮同学\");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println(\"结婚基金已经不是十万了\");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n**程序问题 :**  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。\n\n\n\n### 2.2 volatile解决\n\n**以上案例出现的问题 :**\n\n​\t当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 \n\n​\t1，堆内存是唯一的，每一个线程都有自己的线程栈。\n\n​\t2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。\n\n​\t3 ，在线程中，每一次使用是从变量的副本中获取的。\n\n**Volatile关键字 :** 强制线程每次在使用的时候，都会看一下共享区域最新的值\n\n**代码实现 :** **使用volatile关键字解决**\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName(\"小路同学\");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName(\"小皮同学\");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println(\"结婚基金已经不是十万了\");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n\n\n### 2.3 synchronized解决\n\n**synchronized解决 :** \n\n​\t1 ，线程获得锁\n\n​\t2 ，清空变量副本\n\n​\t3 ，拷贝共享变量最新的值到变量副本中\n\n​\t4 ，执行代码\n\n​\t5 ，将修改后变量副本中的值赋值给共享数据\n\n​\t6 ，释放锁\n\n**代码实现 :** \n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName(\"小路同学\");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName(\"小皮同学\");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Money {\n    public static Object lock = new Object();\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(true){\n            synchronized (Money.lock){\n                if(Money.money != 100000){\n                    System.out.println(\"结婚基金已经不是十万了\");\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        synchronized (Money.lock) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Money.money = 90000;\n        }\n    }\n}\n```\n\n\n\n### 2.4 原子性\n\n**概述 :** 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n\n**代码实现 :** \n\n```java\npackage com.itheima.threadatom;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            count++;\n            System.out.println(\"已经送了\" + count + \"个冰淇淋\");\n        }\n    }\n}\n```\n\n**代码总结 :** count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断\n\n\n\n### 2.5 volatile关键字不能保证原子性\n\n解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\n\n```java\npackage com.itheima.threadatom2;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n    private Object lock = new Object();\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            synchronized (lock) {\n                count++;\n                System.out.println(\"已经送了\" + count + \"个冰淇淋\");\n            }\n        }\n    }\n}\n```\n\n\n\n### 2.6 原子性_AtomicInteger\n\n概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\n\nAtomicBoolean： 原子更新布尔类型\n\nAtomicInteger：   原子更新整型\n\nAtomicLong：\t原子更新长整型\n\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\n\n```java\npublic AtomicInteger()：\t   \t\t\t    初始化一个默认值为0的原子型Integer\npublic AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integer\n\nint get():   \t\t\t \t\t\t\t获取值\nint getAndIncrement():      \t\t\t 以原子方式将当前值加1，注意，这里返回的是自增前的值。\nint incrementAndGet():     \t\t\t\t 以原子方式将当前值加1，注意，这里返回的是自增后的值。\nint addAndGet(int data):\t\t\t\t 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。\nint getAndSet(int value):   \t\t\t 以原子方式设置为newValue的值，并返回旧值。\n```\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo1 {\n//    public AtomicInteger()：\t               初始化一个默认值为0的原子型Integer\n//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n    public static void main(String[] args) {\n        AtomicInteger ac = new AtomicInteger();\n        System.out.println(ac);\n\n        AtomicInteger ac2 = new AtomicInteger(10);\n        System.out.println(ac2);\n    }\n\n}\n```\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo2 {\n//    int get():   \t\t \t\t获取值\n//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。\n//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。\n//    int addAndGet(int data):\t 以原子方式将参数与对象中的值相加，并返回结果。\n//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。\n    public static void main(String[] args) {\n//        AtomicInteger ac1 = new AtomicInteger(10);\n//        System.out.println(ac1.get());\n\n//        AtomicInteger ac2 = new AtomicInteger(10);\n//        int andIncrement = ac2.getAndIncrement();\n//        System.out.println(andIncrement);\n//        System.out.println(ac2.get());\n\n//        AtomicInteger ac3 = new AtomicInteger(10);\n//        int i = ac3.incrementAndGet();\n//        System.out.println(i);//自增后的值\n//        System.out.println(ac3.get());\n\n//        AtomicInteger ac4 = new AtomicInteger(10);\n//        int i = ac4.addAndGet(20);\n//        System.out.println(i);\n//        System.out.println(ac4.get());\n\n        AtomicInteger ac5 = new AtomicInteger(100);\n        int andSet = ac5.getAndSet(20);\n        System.out.println(andSet);\n        System.out.println(ac5.get());\n    }\n}\n```\n\n\n\n### 2.7 AtomicInteger-内存解析\n\n**AtomicInteger原理 :** 自旋锁  + CAS 算法\n\n**CAS算法：**\n\n​\t有3个操作数（内存值V， 旧的预期值A，要修改的值B）\n\n​\t当旧的预期值A == 内存值   此时修改成功，将V改为B                 \n\n​\t当旧的预期值A！=内存值   此时修改失败，不做任何操作                 \n\n​\t并重新获取现在的最新值（这个重新获取的动作就是自旋）\n\n### 2.8 AtomicInteger-源码解析\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom4;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.threadatom4;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomThread implements Runnable {\n    //private volatile int count = 0; //送冰淇淋的数量\n    //private Object lock = new Object();\n    AtomicInteger ac = new AtomicInteger(0);\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            //synchronized (lock) {\n//                count++;\n//                ac++;\n            int count = ac.incrementAndGet();\n            System.out.println(\"已经送了\" + count + \"个冰淇淋\");\n           // }\n        }\n    }\n}\n\n```\n\n**源码解析 :** \n\n```java\n\n//先自增，然后获取自增后的结果\npublic final int incrementAndGet() {\n        //+ 1 自增后的结果\n        //this 就表示当前的atomicInteger（值）\n        //1    自增一次\n        return U.getAndAddInt(this, VALUE, 1) + 1;\n}\n\npublic final int getAndAddInt(Object o, long offset, int delta) {\n        //v 旧值\n        int v;\n        //自旋的过程\n        do {\n            //不断的获取旧值\n            v = getIntVolatile(o, offset);\n            //如果这个方法的返回值为false，那么继续自旋\n            //如果这个方法的返回值为true，那么自旋结束\n            //o 表示的就是内存值\n            //v 旧值\n            //v + delta 修改后的值\n        } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n            //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。\n            //                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。\n            //如果修改失败，那么继续自旋。\n        return v;\n}\n```\n\n\n\n### 2.9 悲观锁和乐观锁\n\n**synchronized和CAS的区别 :** \n\n**相同点：**在多线程情况下，都可以保证共享数据的安全性。\n\n**不同点：**synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每                       次操作共享数据之前，都会上锁。（悲观锁）\n\n​\tcas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。\n\n​\t如果别人修改过，那么我再次获取现在最新的值。            \n\n​\t 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）\n\n\n\n## 3. 并发工具类\n\n### 3.1 并发工具类-Hashtable\n\n​\t**Hashtable出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\npublic class MyHashtableDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Hashtable<String, String> hm = new Hashtable<>();\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + \"\", i + \"\");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + \"\", i + \"\");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println(\"----------------------------\");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + \"\"));\n        }//0 1 2 3 .... 50\n\n\n    }\n}\n```\n\n\n\n### 3.2 并发工具类-ConcurrentHashMap基本使用\n\n​\t**ConcurrentHashMap出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n\n**体系结构 :** \n\n![1591168965857](.\\img\\1591168965857.png)\n\n**总结 :** \n\n​\t1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题\n\n​\t2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下\n\n​\t3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.Hashtable;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MyConcurrentHashMapDemo {\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap<>(100);\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + \"\", i + \"\");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + \"\", i + \"\");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println(\"----------------------------\");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + \"\"));\n        }//0 1 2 3 .... 50\n    }\n}\n```\n\n\n\n### 3.3 并发工具类-ConcurrentHashMap1.7原理\n\n![1591169254280](.\\img\\1591169254280.png)\n\n### 3.4 并发工具类-ConcurrentHashMap1.8原理\n\n![1591169338256](.\\img\\1591169338256.png)\n\n**总结 :** \n\n​\t1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表\n\n​\t2，计算当前元素应存入的索引。\n\n​\t3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。\n\n​\t4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。\t\t\n\n​\t5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性\n\n### 3.5 并发工具类-CountDownLatch\n\n**CountDownLatch类 :** \t\t\n\n| 方法                               | 解释               |\n| -------------------------------- | ---------------- |\n| public CountDownLatch(int count) | 参数传递线程数，表示等待线程数量 |\n| public void await()              | 让线程等待            |\n| public void countDown()          | 当前线程执行完毕         |\n\n**使用场景：** 让某一条线程等待其他线程执行完毕之后再执行\n\n**代码实现 :** \n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread1 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread1(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(getName() + \"在吃第\" + i + \"个饺子\");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread2 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread2(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 15; i++) {\n            System.out.println(getName() + \"在吃第\" + i + \"个饺子\");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread3 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread3(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 20; i++) {\n            System.out.println(getName() + \"在吃第\" + i + \"个饺子\");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MotherThread extends Thread {\n    private CountDownLatch countDownLatch;\n    public MotherThread(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.等待\n        try {\n            //当计数器变成0的时候，会自动唤醒这里等待的线程。\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //2.收拾碗筷\n        System.out.println(\"妈妈在收拾碗筷\");\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyCountDownLatchDemo {\n    public static void main(String[] args) {\n        //1.创建CountDownLatch的对象，需要传递给四个线程。\n        //在底层就定义了一个计数器，此时计数器的值就是3\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        //2.创建四个线程对象并开启他们。\n        MotherThread motherThread = new MotherThread(countDownLatch);\n        motherThread.start();\n\n        ChileThread1 t1 = new ChileThread1(countDownLatch);\n        t1.setName(\"小明\");\n\n        ChileThread2 t2 = new ChileThread2(countDownLatch);\n        t2.setName(\"小红\");\n\n        ChileThread3 t3 = new ChileThread3(countDownLatch);\n        t3.setName(\"小刚\");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n**总结 :** \n\n​\t1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。\n\n​\t2. await()：让线程等待，当计数器为0时，会唤醒等待的线程\n\n​\t3. countDown()： 线程执行完毕时调用，会将计数器-1。\n\n### 3.6 并发工具类-Semaphore\n\n**使用场景 :** \n\n​\t可以控制访问特定资源的线程数量。\n\n**实现步骤 :** \n\n​\t1，需要有人管理这个通道\n\n​\t2，当有车进来了，发通行许可证\n\n​\t3，当车出去了，收回通行许可证\n\n​\t4，如果通行许可证发完了，那么其他车辆只能等着\n\n**代码实现 :** \n\n```java\npackage com.itheima.mysemaphore;\n\nimport java.util.concurrent.Semaphore;\n\npublic class MyRunnable implements Runnable {\n    //1.获得管理员对象，\n    private Semaphore semaphore = new Semaphore(2);\n    @Override\n    public void run() {\n        //2.获得通行证\n        try {\n            semaphore.acquire();\n            //3.开始行驶\n            System.out.println(\"获得了通行证开始行驶\");\n            Thread.sleep(2000);\n            System.out.println(\"归还通行证\");\n            //4.归还通行证\n            semaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n```java\npackage com.itheima.mysemaphore;\n\npublic class MySemaphoreDemo {\n    public static void main(String[] args) {\n        MyRunnable mr = new MyRunnable();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(mr).start();\n        }\n    }\n}\n```\n\n\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"多线程练习","url":"/2023/03/23/多线程练习/","content":"# 线程创建\n\n1.\n\n```java\npackage thread.day1;\n\npublic class thread1 extends Thread {\n    @Override\n    public void run(){\n        for (int i = 0; i < 10; i++) {\n            System.out.println(getName()+i);\n        }\n    }\n\n}\n```\n\n```java\npackage thread.day1;\n\npublic class test01 {\n    public static void main(String[] args) {\n        thread1 one = new thread1();\n        thread1 two = new thread1();\n        one.start();\n        two.start();\n\n    }\n}\n```\n\n2.\n\n```java\npackage thread.day1;\n\npublic class thread02 implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n        }\n    }\n}\n```\n\n```java\npackage thread.day1;\n\npublic class test02 {\n    public static void main(String[] args) {\n        thread02 thd = new thread02();\n//        Thread td = new Thread(thd);\n//        Thread td2 = new Thread(thd);\n        Thread td = new Thread(thd,\"a:\");\n        Thread td2 = new Thread(thd,\"b:\");\n        td.start();\n        td2.start();\n    }\n}\n```\n\n3.\n\n```java\npackage thread.day1;\n\nimport java.util.concurrent.Callable;\n\npublic class thread03 implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 1; i <= 100; i++) {\n            sum+=i;\n        }\n        return sum;\n    }\n}\n```\n\n```java\npackage thread.day1;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class test03 {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n\n        thread03 td03 = new thread03();\n        FutureTask<Integer> fk = new FutureTask<>(td03);\n        Thread s = new Thread(fk);\n\n        s.start();\n        Integer val = fk.get();\n        System.out.println(val);\n    }\n\n\n}\n```\n\n4.\n\n```java\npackage thread.day1;\n\npublic class thread04 extends Thread{\n    public thread04() {\n    }\n\n    public thread04(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run(){\n        try {\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        for (int i = 0; i < 100; i++) {\n            System.out.println(getName()+\":\"+i);\n        }\n\n    }\n}\n```\n\n```java\npackage thread.day1;\n\npublic class Test04 {\n    public static void main(String[] args) {\n//        thread04 my1 = new thread04();\n//        thread04 my2 = new thread04();\n//        my1.setName(\"a\");\n//        my2.setName(\"b\");\n//        Thread td = new Thread(my1);\n//        Thread td2 = new Thread(my2);\n        thread04 my1 = new thread04(\"飞机\");\n        thread04 my2 = new thread04(\"坦克\");\n        Thread td = new Thread(my1);\n        //Thread td2 = new Thread(my2);\n        System.out.println(\"start\");\n\n        td.start();\n        System.out.println(\"end!!\");\n        //td2.start();\n    }\n}\n```\n\n5.\n\n```java\npackage thread.day1;\n\npublic class Thread05 implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(Thread.currentThread().getName()+\"\"+i);\n        }\n    }\n}\n```\n\n```java\npackage thread.day1;\n\npublic class Test05 {\n    public static void main(String[] args) {\n        Thread05 thread05 = new Thread05();\n        Thread thread1 = new Thread(thread05);\n        thread1.setName(\"飞机\");\n        thread1.setPriority(10);\n        Thread thread2 = new Thread(thread05);\n        thread2.setName(\"坦克\");\n        thread2.setPriority(1);\n        thread1.start();\n        thread2.start();\n\n    }\n}\n```\n\n6.\n\n```java\npackage thread.day1;\n\nimport java.util.concurrent.Callable;\n\npublic class Thread06 implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0;\n        for (int i = 0; i < 100; i++) {\n            sum+=i;\n            System.out.println(Thread.currentThread().getName()+\"\"+i);\n        }\n        return sum;\n    }\n}\n```\n\n```java\npackage thread.day1;\n\nimport java.util.concurrent.FutureTask;\n\npublic class Test06 {\n    public static void main(String[] args) {\n        thread1 thread05 = new thread1();\n        Thread06 thread06 = new Thread06();\n        FutureTask<Integer> tk = new FutureTask<>(thread06);\n        Thread td = new Thread(tk);\n        thread05.setName(\"女神\");\n        td.setName(\"备胎\");\n        td.setDaemon(true);\n        td.start();\n        thread05.start();\n\n    }\n}\n```\n\n## 同步线程\n\n1. 无同步\n\n```java\npackage thread.day2;\n\npublic class MyThread1 extends Thread {\n    static int ticket = 0;\n    @Override\n    public void run(){\n        while (true) {\n            if (ticket < 100){\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                ticket++;\n                System.out.println(Thread.currentThread().getName()+\"正在卖第\"+ticket+\"张票！！！\");\n            }else {\n                break;\n            }\n        }\n    }\n\n\n}\n```\n\n```java\npackage thread.day2;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        MyThread1 mtd1 = new MyThread1();\n        Thread td = new Thread(mtd1,\"飞机\");\n        Thread td2 = new Thread(mtd1,\"坦克\");\n        Thread td3 = new Thread(mtd1,\"大炮\");\n        td.start();\n        td2.start();\n        td3.start();\n\n    }\n\n}\n```\n\n2. 同步代码块\n\n```java\npackage thread.day2;\n\npublic class MyThread02 extends Thread {\n    static int ticket = 0;\n    // 锁对象必须是唯一的\n    static Object obj = new Object();\n\n    @Override\n    public void run() {\n\n        while (true) {\n            // 锁对象\n            synchronized (obj) {\n                if (ticket < 100) {\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    ticket++;\n                    System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票！！！\");\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage thread.day2;\n\npublic class Test02 {\n    public static void main(String[] args) {\n        MyThread02 mtd1 = new MyThread02();\n        Thread td = new Thread(mtd1,\"飞机\");\n        Thread td2 = new Thread(mtd1,\"坦克\");\n        Thread td3 = new Thread(mtd1,\"大炮\");\n        td.start();\n        td2.start();\n        td3.start();\n\n    }\n}\n```\n\n3. 同步方法\n\n```java\npackage thread.day2;\n\npublic class MyThread3 extends Thread {\n    static int ticket = 0;\n\n    public void run() {\n        while (true) {\n            extracted();\n        }\n    }\n\n    private static synchronized void extracted() {\n\n        // 锁对象\n\n        if (ticket < 100) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            ticket++;\n            System.out.println(Thread.currentThread().getName() + \"正在卖第\" + ticket + \"张票！！！\");\n        }\n\n    }\n}\n```\n\n```java\npackage thread.day2;\n\npublic class Test03 {\n    public static void main(String[] args) {\n        MyThread3 mtd1 = new MyThread3();\n        MyThread3 mtd2 = new MyThread3();\n        MyThread3 mtd3 = new MyThread3();\n        mtd1.setName(\"a\");\n        mtd2.setName(\"b\");\n        mtd3.setName(\"c\");\n        mtd1.start();\n        mtd2.start();\n        mtd3.start();\n    }\n}\n```\n\n## 综合联系\n\n练习1\n\n> 一共有1000张电影票，可以在两个窗口领取，假设每次领取的时间为3000毫秒，\n>\n> 要求：请用多线程模拟卖票过程并打印剩余电影票的数量\n\n```java\npackage thread.day4;\n\npublic class Thread01 extends Thread {\n    static int ticket = 200;\n    static final Object object = new Object();\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (object) {\n                if (ticket == 0) {\n                    break;\n                } else {\n                    try {\n                        sleep(300);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    ticket--;\n                    System.out.println(getName() + \": 当前剩余\" + ticket + \"张票！！！\");\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage thread.day4;\n\npublic class Test01 {\n\n\n    public static void main(String[] args) {\n        Thread01 td = new Thread01();\n        Thread01 td2 = new Thread01();\n        Thread01 td3 = new Thread01();\n        td.setName(\"a\");\n        td3.setName(\"c\");\n        td2.setName(\"b\");\n        td.start();\n        td2.start();\n        td3.start();\n    }\n\n}\n```\n\n练习2\n\n> 有100份礼品，两人同时发送，当剩下的礼品小于10份时不再送出。\n>\n> 利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来\n\n```java\npackage thread.day4;\n\npublic class Test02 {\n    public static void main(String[] args) {\n        Thread02 thread02 = new Thread02();\n        Thread td1 = new Thread(thread02);\n        Thread td2 = new Thread(thread02);\n        Thread td3 = new Thread(thread02);\n        td1.start();\n        td2.start();\n        td3.start();\n\n    }\n}\n```\n\n```java\npackage thread.day4;\n\npublic class Thread02 implements Runnable {\n    int presents = 100;\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (Thread02.class) {\n                if (presents < 10) {\n                    break;\n                } else {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    presents--;\n                    System.out.println(Thread.currentThread().getName() + \"剩余票\" + presents);\n                }\n            }\n        }\n    }\n}\n```\n\n练习3\n\n同时开启两个线程，共同获取1-100之间的所有数字\n\n要求：将输出所有的奇数\n\n```java\npackage thread.day4;\n\npublic class Thread03 implements Runnable {\n    int num = 1;\n\n    @Override\n    public void run() {\n\n        while (true) {\n            synchronized (Thread03.class) {\n                if (num > 100) {\n                    break;\n                } else {\n                    if (num % 2 == 1) {\n                        System.out.println(Thread.currentThread().getName() + \"  :\" + num);\n                    }\n                    num++;\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n\n            }\n        }\n    }\n}\n```\n\n```java\npackage thread.day4;\n\npublic class Test03 {\n    public static void main(String[] args) {\n        Thread03 thread03 = new Thread03();\n        Thread td1 = new Thread(thread03,\"a\");\n        Thread td2 = new Thread(thread03,\"b\");\n        Thread td3 = new Thread(thread03,\"c\");\n        td1.start();\n        td2.start();\n        td3.start();\n\n    }\n}\n```\n\n练习4\n\n抢红包\n\n> 假设100块，分成了3个包，现在有5个人去抢。\n>\n> 其中红包是共享数据。\n>\n> 5个人是5条线程\n>\n> 打印结果如下：\n>\n> ​\txxx抢到了xxx元\n>\n> xxx抢到了xxx元\n>\n> xxx抢到了xxx元\n>\n> xxx没抢到\n>\n> xxx没抢到\n\n```java\npackage thread.day4.redpackage;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        Thread01 thread = new Thread01();\n        Thread td1 = new Thread(thread,\"a\");\n        Thread td2 = new Thread(thread,\"b\");\n        Thread td3 = new Thread(thread,\"c\");\n        Thread td4 = new Thread(thread,\"d\");\n        Thread td5 = new Thread(thread,\"e\");\n        td1.start();\n        td2.start();\n        td3.start();\n        td4.start();\n        td5.start();\n\n    }\n}\n```\n\n```java\npackage thread.day4.redpackage;\n\nimport java.util.Random;\n\npublic class Thread01 extends Thread {\n    double money = 100;\n    // 定义次数\n    int count = 3;\n    // 定义最小金额\n    static final double MIN = 0.01;\n\n    @Override\n    public void run() {\n        // 只抢一次，不需要用循环\n        synchronized (Thread01.class) {\n            if (count == 0) {\n                // 判断共享数据是否已经到了末尾\n                System.out.println(Thread.currentThread().getName() + \"没有抢到红包\");\n            } else {\n                if (count == 1) {\n                    // 如果此时是最后一个红包，就无需随机，所有的钱都是中奖金额\n                    System.out.println(Thread.currentThread().getName() + \"抢到了\" + money);\n                    count--;\n                } else {\n                    Random r = new Random();\n                    // 获取中奖金额，最大值为money - (count - 1) * MIN ，最小值为MIN\n                    double price = r.nextDouble(money - (count - 1) * MIN);\n                    if (price < MIN) {\n                        price = MIN;\n                    }\n                    // 剩余的钱\n                    money -= price;\n                    // 剩余红包数量\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"抢到了\" + price);\n                }\n            }\n        }\n    }\n}\n```\n\n练习5\n\n>有一个抽奖池，该抽奖池中存放了奖励的金额，该抽奖池中的奖项为\n>{10,5,20,50,100,200,500,800,2,80,300,700};\n>创建两个抽奖箱（线程）设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n>随机从抽奖池中获取奖项元素并打印在控台上，格式如下：\n>\n>每次抽出一个奖项就打印一个（随机）\n>抽奖箱1又产生了一个10元大奖\n>抽奖箱1又产生了一个100元大奖\n>抽奖箱1又产生了一个200元大奖\n>抽奖箱1又产生了一个800元大奖\n>抽奖箱2又产生了一个700元大奖\n>\n>...\n\n```java\npackage thread.day4.luckyDraw;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n        Thread01 thread01 = new Thread01(list);\n        Thread01 thread02 = new Thread01(list);\n        thread01.setName(\"a\");\n        thread02.setName(\"b\");\n        thread01.start();\n        thread02.start();\n\n    }\n}\n```\n\n```java\npackage thread.day4.luckyDraw;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Thread01 extends Thread {\n    ArrayList<Integer> list;\n\n    public Thread01(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (Thread01.class) {\n                if (list.isEmpty()) {\n                    break;\n                } else {\n                    // 抽奖\n                    Collections.shuffle(list);\n                    Integer price = list.remove(0);\n                    System.out.println(getName()+\" :抽到的奖金为\" + price);\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\n```\n\n练习6\n\n```java\npackage thread.day4.luckydraw2;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n        Thread01 thread01 = new Thread01(list);\n        Thread01 thread02 = new Thread01(list);\n        thread01.setName(\"a\");\n        thread02.setName(\"b\");\n        thread01.start();\n        thread02.start();\n\n    }\n}\n```\n\n```java\npackage thread.day4.luckydraw2;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Thread01 extends Thread {\n    ArrayList<Integer> list;\n\n    public Thread01(ArrayList<Integer> list) {\n        this.list = list;\n    }\n    // 线程一\n\n    // 线程二\n\n\n    @Override\n    public void run() {\n        ArrayList<Integer> list1 = new ArrayList<>();\n        while (true) {\n            synchronized (thread.day4.luckyDraw.Thread01.class) {\n                if (list.isEmpty()) {\n                    System.out.println(getName() + \" \" + list1);\n                    break;\n                } else {\n                    // 抽奖\n                    Collections.shuffle(list);\n                    Integer price = list.remove(0);\n                    // System.out.println(getName()+\" :抽到的奖金为\" + price);\n                    if (\"a\".equals(getName())) {\n                        list1.add(price);\n                    } else {\n                        list1.add(price);\n                    }\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\n```\n\n练习7\n\n```java\npackage thread.day4.luckydraw2;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class Test03 {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n        Thread03 thread01 = new Thread03(list);\n        // 多线程运行结果的管理者对象\n        FutureTask<Integer> ft = new FutureTask<>(thread01);\n        FutureTask<Integer> ft2 = new FutureTask<>(thread01);\n        Thread td1 = new Thread(ft);\n        Thread td2 = new Thread(ft2);\n        td1.setName(\"a\");\n        td2.setName(\"b\");\n        td1.start();\n        td2.start();\n        System.out.println(ft.get());\n        System.out.println(ft2.get());\n\n    }\n\n}\n```\n\n```java\npackage thread.day4.luckydraw2;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.concurrent.Callable;\n\npublic class Thread03 implements Callable<Integer> {\n    ArrayList<Integer> list;\n\n    public Thread03(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        ArrayList<Integer> list1 = new ArrayList<>();\n        while (true) {\n            synchronized (thread.day4.luckyDraw.Thread01.class) {\n                if (list.isEmpty()) {\n                    System.out.println(Thread.currentThread().getName() + \" \" + list1);\n                    break;\n                } else {\n                    // 抽奖\n                    Collections.shuffle(list);\n                    Integer price = list.remove(0);\n                    // System.out.println(getName()+\" :抽到的奖金为\" + price);\n                    if (\"a\".equals(Thread.currentThread().getName())) {\n                        list1.add(price);\n                    } else {\n                        list1.add(price);\n                    }\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        if (list1.size() == 0) {\n            return null;\n        } else {\n            return Collections.max(list1);\n        }\n\n    }\n}\n```\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"多线程01","url":"/2023/03/22/多线程01/","content":"# 多线程的四步套路\n\n1.循环\n\n2.同步代码块\n\n3.判断共享数据是否到了末尾（到了末尾）\n\n4.判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）\n\n# 多线程\n\n\n\n## 1.实现多线程\n\n### 1.1简单了解多线程【理解】\n\n是指从软件或者硬件上实现多个线程并发执行的技术。\n具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。\n\n![01_简单了解多线程](.\\img\\01_简单了解多线程.png)\n\n### 1.2并发和并行【理解】\n\n+ 并行：在同一时刻，有多个指令在多个CPU上同时执行。\n\n  \n\n+ 并发：在同一时刻，有多个指令在单个CPU上交替执行。\n\n\n![](https://pic.imgdb.cn/item/641c20aaa682492fcca6928f.jpg)\n\n### 1.3进程和线程【理解】\n\n- 进程：是正在运行的程序\n\n  独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n  动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的\n  并发性：任何进程都可以同其他进程一起并发执行\n\n- 线程：是进程中的单个顺序控制流，是一条执行路径\n\n  ​\t单线程：一个进程如果只有一条执行路径，则称为单线程程序\n\n  ​\t多线程：一个进程如果有多条执行路径，则称为多线程程序\n\n  ​\t![04_多线程示例](.\\img\\04_多线程示例.png)\n\n### 1.4实现多线程方式一：继承Thread类【应用】\n\n![image-20230323175134681](C:\\Users\\19183\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230323175134681.png)\n\n- 方法介绍\n\n  | 方法名          | 说明                         |\n  | ------------ | -------------------------- |\n  | void run()   | 在线程开启后，此方法将被调用执行           |\n  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |\n\n- 实现步骤\n  - 定义一个类MyThread继承Thread类\n  - 在MyThread类中重写run()方法\n  - 创建MyThread类的对象\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n  //        my1.run();\n  //        my2.run();\n\n          //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法\n          my1.start();\n          my2.start();\n      }\n  }\n  ```\n\n- 两个小问题\n\n  - 为什么要重写run()方法？\n\n    因为run()是用来封装被线程执行的代码\n\n  - run()方法和start()方法的区别？\n\n    run()：封装线程执行的代码，直接调用，相当于普通方法的调用\n\n    start()：启动线程；然后由JVM调用此线程的run()方法\n\n### 1.5实现多线程方式二：实现Runnable接口【应用】\n\n- Thread构造方法\n\n  | 方法名                                  | 说明             |\n  | ------------------------------------ | -------------- |\n  | Thread(Runnable target)              | 分配一个新的Thread对象 |\n  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |\n\n- 实现步骤\n\n  - 定义一个类MyRunnable实现Runnable接口\n  - 在MyRunnable类中重写run()方法\n  - 创建MyRunnable类的对象\n  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(Thread.currentThread().getName()+\":\"+i);\n          }\n      }\n  }\n  public class MyRunnableDemo {\n      public static void main(String[] args) {\n          //创建MyRunnable类的对象\n          MyRunnable my = new MyRunnable();\n  \n          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n          //Thread(Runnable target)\n  //        Thread t1 = new Thread(my);\n  //        Thread t2 = new Thread(my);\n          //Thread(Runnable target, String name)\n          Thread t1 = new Thread(my,\"坦克\");\n          Thread t2 = new Thread(my,\"飞机\");\n  \n          //启动线程\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.6实现多线程方式三: 实现Callable接口【应用】\n\n+ 方法介绍\n\n  | 方法名                              | 说明                                  |\n  | -------------------------------- | ----------------------------------- |\n  | V call()                         | 计算结果，如果无法计算结果，则抛出一个异常               |\n  | FutureTask(Callable<V> callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable |\n  | V get()                          | 如有必要，等待计算完成，然后获取其结果                 |\n\n+ 实现步骤\n\n  + 定义一个类MyCallable实现Callable接口\n  + 在MyCallable类中重写call()方法\n  + 创建MyCallable类的对象\n  + 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数\n  + 创建Thread类的对象，把FutureTask对象作为构造方法的参数\n  + 启动线程\n  + 再调用get方法，就可以获取线程结束之后的结果。\n\n+ 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(\"跟女孩表白\" + i);\n          }\n          //返回值就表示线程运行完毕之后的结果\n          return \"答应\";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws ExecutionException, InterruptedException {\n          //线程开启之后需要执行里面的call方法\n          MyCallable mc = new MyCallable();\n\n          //Thread t1 = new Thread(mc);\n\n          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          //创建线程对象\n          Thread t1 = new Thread(ft);\n\n          String s = ft.get();\n          //开启线程\n          t1.start();\n\n          //String s = ft.get();\n          System.out.println(s);\n      }\n  }\n  ```\n\n+ 三种实现方式的对比\n  + 实现Runnable、Callable接口\n    + 好处: 扩展性强，实现该接口的同时还可以继承其他的类\n    + 缺点: 编程相对复杂，不能直接使用Thread类中的方法\n  + 继承Thread类\n    + 好处: 编程比较简单，可以直接使用Thread类中的方法\n    + 缺点: 可以扩展性较差，不能再继承其他的类\n\n当JVM虚拟机启动之后，会自动的启动多条线程\n其中有一条线程就叫做main线程\n他的作用就是去调用man方法，并执行里面的代码\n在以前，我们写的所有的代码，其实都是运行在main线程当中\n\n### 1.7设置和获取线程名称【应用】\n\n- 方法介绍\n\n  | 方法名                        | 说明                 |\n  | -------------------------- | ------------------ |\n  | void  setName(String name) | 将此线程的名称更改为等于参数name |\n  | String  getName()          | 返回此线程的名称           |\n  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用  |\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      public MyThread() {}\n      public MyThread(String name) {\n          super(name);\n      }\n  \n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName()+\":\"+i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n  \n          //void setName(String name)：将此线程的名称更改为等于参数 name\n          my1.setName(\"高铁\");\n          my2.setName(\"飞机\");\n  \n          //Thread(String name)\n          MyThread my1 = new MyThread(\"高铁\");\n          MyThread my2 = new MyThread(\"飞机\");\n  \n          my1.start();\n          my2.start();\n  \n          //static Thread currentThread() 返回对当前正在执行的线程对象的引用\n          System.out.println(Thread.currentThread().getName());\n      }\n  }\n  ```\n\n### 1.8线程休眠【应用】\n\n+ 相关方法\n\n  | 方法名                            | 说明                       |\n  | ------------------------------ | ------------------------ |\n  | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |\n\n+ 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n  \n              System.out.println(Thread.currentThread().getName() + \"---\" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws InterruptedException {\n          /*System.out.println(\"睡觉前\");\n          Thread.sleep(3000);\n          System.out.println(\"睡醒了\");*/\n  \n          MyRunnable mr = new MyRunnable();\n  \n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n  \n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.9线程优先级【应用】\n\n- 线程调度\n\n  - 两种调度方式\n    - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片\n    - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些\n\n  - Java使用的是抢占式调度模型\n\n  - 随机性\n\n    假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的\n\n    ![05_多线程示例图](.\\img\\05_多线程示例图.png)\n\n- 优先级相关方法\n\n  | 方法名                                     | 说明                                |\n  | --------------------------------------- | --------------------------------- |\n  | final int getPriority()                 | 返回此线程的优先级                         |\n  | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |\n\n- 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(Thread.currentThread().getName() + \"---\" + i);\n          }\n          return \"线程执行完毕了\";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //优先级: 1 - 10 默认值:5\n          MyCallable mc = new MyCallable();\n  \n          FutureTask<String> ft = new FutureTask<>(mc);\n  \n          Thread t1 = new Thread(ft);\n          t1.setName(\"飞机\");\n          t1.setPriority(10);\n          //System.out.println(t1.getPriority());//5\n          t1.start();\n  \n          MyCallable mc2 = new MyCallable();\n  \n          FutureTask<String> ft2 = new FutureTask<>(mc2);\n  \n          Thread t2 = new Thread(ft2);\n          t2.setName(\"坦克\");\n          t2.setPriority(1);\n          //System.out.println(t2.getPriority());//5\n          t2.start();\n      }\n  }\n  ```\n\n### 1.10守护线程【应用】\n\n- 相关方法\n\n  | 方法名                        | 说明                                   |\n  | -------------------------- | ------------------------------------ |\n  | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |\n\n- 代码演示\n\n  ```java\n  public class MyThread1 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 10; i++) {\n              System.out.println(getName() + \"---\" + i);\n          }\n      }\n  }\n  public class MyThread2 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName() + \"---\" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          MyThread1 t1 = new MyThread1();\n          MyThread2 t2 = new MyThread2();\n  \n          t1.setName(\"女神\");\n          t2.setName(\"备胎\");\n  \n          //把第二个线程设置为守护线程\n          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.\n          t2.setDaemon(true);\n  \n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n## 线程的生命周期\n\n![](https://pic.imgdb.cn/item/641c236ca682492fccabc973.jpg)\n\n有执行资格：有资格去抢CPU的执行权\n\n没有执行权：现在没有抢到，不能执行代码\n\n## 2.线程同步\n\n![](https://pic.imgdb.cn/item/641c2b60a682492fccba91a5.jpg) \n\n![](https://pic.imgdb.cn/item/641c61cea682492fcc251eff.jpg)\n\n> 如果是两把不同的锁则没有意义\n\n![](https://pic.imgdb.cn/item/641c6244a682492fcc260fee.jpg)\n\n> 所以锁必须是唯一的\n>\n> 一般设置类字节码文件\n>\n> ` synchronized (类名.class)`\n>\n> 如` synchronized (MyThread.class){...}` \n\n\n\n### 2.1卖票【应用】\n\n- 案例需求\n\n  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票\n\n- 实现步骤\n\n  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;\n\n  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下\n\n  - 判断票数大于0，就卖票，并告知是哪个窗口卖的\n  - 卖了票之后，总票数要减1\n  - 票卖没了，线程停止\n  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下\n  - 创建SellTicket类的对象\n  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n  - 启动线程\n\n- 代码实现\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      //在SellTicket类中重写run()方法实现卖票，代码步骤如下\n      @Override\n      public void run() {\n          while (true) {\n              if(ticket <= 0){\n                      //卖完了\n                      break;\n                  }else{\n                      try {\n                          Thread.sleep(100);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticket + \"张票\");\n                  }\n          }\n      }\n  }\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          //创建SellTicket类的对象\n          SellTicket st = new SellTicket();\n  \n          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n          Thread t1 = new Thread(st,\"窗口1\");\n          Thread t2 = new Thread(st,\"窗口2\");\n          Thread t3 = new Thread(st,\"窗口3\");\n  \n          //启动线程\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n\n### 2.2卖票案例的问题【理解】\n\n- 卖票出现了问题\n\n  - 相同的票出现了多次\n\n  - 出现了负数的票\n\n- 问题产生原因\n\n  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题\n\n\n### 2.3同步代码块解决数据安全问题【应用】\n\n- 安全问题出现的条件\n\n  - 是多线程环境\n\n  - 有共享数据\n\n  - 有多条语句操作共享数据\n\n- 如何解决多线程安全问题呢?\n\n  - 基本思想：让程序没有安全问题的环境\n\n- 怎么实现呢?\n\n  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n\n  - Java提供了同步代码块的方式来解决\n\n- 同步代码块格式：\n\n  ```java\n  synchronized(任意对象) { \n  \t多条语句操作共享数据的代码 \n  }\n  ```\n\n  synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁\n\n- 同步的好处和弊端  \n\n  - 好处：解决了多线程的数据安全问题\n\n  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率\n\n- **锁对象必须是唯一的**\n\n- 代码演示\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      private Object obj = new Object();\n  \n      @Override\n      public void run() {\n          while (true) {\n              synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁\n                  //t1进来后，就会把这段代码给锁起来\n                  if (tickets > 0) {\n                      try {\n                          Thread.sleep(100);\n                          //t1休息100毫秒\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      //窗口1正在出售第100张票\n                      System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n                      tickets--; //tickets = 99;\n                  }\n              }\n              //t1出来了，这段代码的锁就被释放了\n          }\n      }\n  }\n  \n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          SellTicket st = new SellTicket();\n  \n          Thread t1 = new Thread(st, \"窗口1\");\n          Thread t2 = new Thread(st, \"窗口2\");\n          Thread t3 = new Thread(st, \"窗口3\");\n  \n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.4同步方法解决数据安全问题【应用】\n\n![](https://pic.imgdb.cn/item/641c653ea682492fcc2ccf3f.jpg)\n\n- 同步方法的格式\n\n  同步方法：就是把synchronized关键字加到方法上\n\n  ```java\n  修饰符 synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步方法的锁对象是什么呢?\n\n  ​\tthis\n\n- 静态同步方法\n\n  同步静态方法：就是把synchronized关键字加到静态方法上\n\n  ```java\n  修饰符 static synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步静态方法的锁对象是什么呢?\n\n  ​\t类名.class\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      private static int ticketCount = 100;\n  \n      @Override\n      public void run() {\n          while(true){\n              if(\"窗口一\".equals(Thread.currentThread().getName())){\n                  //同步方法\n                  boolean result = synchronizedMthod();\n                  if(result){\n                      break;\n                  }\n              }\n  \n              if(\"窗口二\".equals(Thread.currentThread().getName())){\n                  //同步代码块\n                  synchronized (MyRunnable.class){\n                      if(ticketCount == 0){\n                         break;\n                      }else{\n                          try {\n                              Thread.sleep(10);\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                          ticketCount--;\n                          System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticketCount + \"张票\");\n                      }\n                  }\n              }\n  \n          }\n      }\n  \n      private static synchronized boolean synchronizedMthod() {\n          if(ticketCount == 0){\n              return true;\n          }else{\n              try {\n                  Thread.sleep(10);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              ticketCount--;\n              System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticketCount + \"张票\");\n              return false;\n          }\n      }\n  }\n  ```\n\n\n  public class Demo {\n      public static void main(String[] args) {\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n    \n          t1.setName(\"窗口一\");\n          t2.setName(\"窗口二\");\n    \n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n\n### 2.5Lock锁【应用】\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\n\n- ReentrantLock构造方法\n\n  | 方法名             | 说明                   |\n  | --------------- | -------------------- |\n  | ReentrantLock() | 创建一个ReentrantLock的实例 |\n\n- 加锁解锁方法\n\n  | 方法名           | 说明   |\n  | ------------- | ---- |\n  | void lock()   | 获得锁  |\n  | void unlock() | 释放锁  |\n\n- 代码演示\n\n  ```java\n  public class Ticket implements Runnable {\n      //票的数量\n      private int ticket = 100;\n      private Object obj = new Object();\n      private ReentrantLock lock = new ReentrantLock();\n\n      @Override\n      public void run() {\n          while (true) {\n              //synchronized (obj){//多个线程必须使用同一把锁.\n              try {\n                  lock.lock();\n                  if (ticket <= 0) {\n                      //卖完了\n                      break;\n                  } else {\n                      Thread.sleep(100);\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticket + \"张票\");\n                  }\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              } finally {\n                  lock.unlock();\n              }\n              // }\n          }\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          Ticket ticket = new Ticket();\n\n          Thread t1 = new Thread(ticket);\n          Thread t2 = new Thread(ticket);\n          Thread t3 = new Thread(ticket);\n\n          t1.setName(\"窗口一\");\n          t2.setName(\"窗口二\");\n          t3.setName(\"窗口三\");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.6死锁【理解】\n\n+ 概述\n\n  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行\n\n+ 什么情况下会产生死锁\n\n  1. 资源有限\n  2. 同步嵌套\n\n+ 代码演示\n\n  ```java\n  public class Demo {\n      public static void main(String[] args) {\n          Object objA = new Object();\n          Object objB = new Object();\n  \n          new Thread(()->{\n              while(true){\n                  synchronized (objA){\n                      //线程一\n                      synchronized (objB){\n                          System.out.println(\"小康同学正在走路\");\n                      }\n                  }\n              }\n          }).start();\n  \n          new Thread(()->{\n              while(true){\n                  synchronized (objB){\n                      //线程二\n                      synchronized (objA){\n                          System.out.println(\"小薇同学正在走路\");\n                      }\n                  }\n              }\n          }).start();\n      }\n  }\n  ```\n\n## 3.生产者消费者\n\n### 3.1生产者和消费者模式概述【应用】\n\n- 概述\n\n  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。\n\n  所谓生产者消费者问题，实际上主要是包含了两类线程：\n\n  ​\t一类是生产者线程用于生产数据\n\n  ​\t一类是消费者线程用于消费数据\n\n  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库\n\n  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为\n\n  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为\n\n- Object类的等待和唤醒方法\n\n  | 方法名              | 说明                                       |\n  | ---------------- | ---------------------------------------- |\n  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |\n  | void notify()    | 唤醒正在等待对象监视器的单个线程                         |\n  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |\n\n### 3.2生产者和消费者案例【应用】\n\n- 案例需求\n\n  + 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子\n\n      3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果没有包子,就进入等待状态,如果有包子,就消费包子\n\n      3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建生产者线程和消费者线程对象\n\n      分别开启两个线程\n\n- 代码实现\n\n  ```java\n  public class Desk {\n  \n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      public static boolean flag = false;\n  \n      //汉堡包的总数量\n      public static int count = 10;\n  \n      //锁对象\n      public static final Object lock = new Object();\n  }\n  \n  public class Cooker extends Thread {\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n      @Override\n      public void run() {\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(!Desk.flag){\n                          //生产\n                          System.out.println(\"厨师正在生产汉堡包\");\n                          Desk.flag = true;\n                          Desk.lock.notifyAll();\n                      }else{\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n  \n  public class Foodie extends Thread {\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n  \n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(Desk.flag){\n                          //有\n                          System.out.println(\"吃货在吃汉堡包\");\n                          Desk.flag = false;\n                          Desk.lock.notifyAll();\n                          Desk.count--;\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n  \n      }\n  }\n  \n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n  \n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n  \n          Foodie f = new Foodie();\n          Cooker c = new Cooker();\n  \n          f.start();\n          c.start();\n  \n      }\n  }\n  ```\n\n### 3.3生产者和消费者案例优化【应用】\n\n+ 需求\n\n  + 将Desk类中的变量,采用面向对象的方式封装起来\n  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用\n  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象\n  + 开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Desk {\n  \n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      //public static boolean flag = false;\n      private boolean flag;\n  \n      //汉堡包的总数量\n      //public static int count = 10;\n      //以后我们在使用这种必须有默认值的变量\n     // private int count = 10;\n      private int count;\n  \n      //锁对象\n      //public static final Object lock = new Object();\n      private final Object lock = new Object();\n  \n      public Desk() {\n          this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了\n      }\n  \n      public Desk(boolean flag, int count) {\n          this.flag = flag;\n          this.count = count;\n      }\n  \n      public boolean isFlag() {\n          return flag;\n      }\n  \n      public void setFlag(boolean flag) {\n          this.flag = flag;\n      }\n  \n      public int getCount() {\n          return count;\n      }\n  \n      public void setCount(int count) {\n          this.count = count;\n      }\n  \n      public Object getLock() {\n          return lock;\n      }\n  \n      @Override\n      public String toString() {\n          return \"Desk{\" +\n                  \"flag=\" + flag +\n                  \", count=\" + count +\n                  \", lock=\" + lock +\n                  '}';\n      }\n  }\n  \n  public class Cooker extends Thread {\n  \n      private Desk desk;\n  \n      public Cooker(Desk desk) {\n          this.desk = desk;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n  \n      @Override\n      public void run() {\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println(\"验证一下是否执行了\");\n                      if(!desk.isFlag()){\n                          //生产\n                          System.out.println(\"厨师正在生产汉堡包\");\n                          desk.setFlag(true);\n                          desk.getLock().notifyAll();\n                      }else{\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n  \n  public class Foodie extends Thread {\n      private Desk desk;\n  \n      public Foodie(Desk desk) {\n          this.desk = desk;\n      }\n  \n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n  \n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println(\"验证一下是否执行了\");\n                      if(desk.isFlag()){\n                          //有\n                          System.out.println(\"吃货在吃汉堡包\");\n                          desk.setFlag(false);\n                          desk.getLock().notifyAll();\n                          desk.setCount(desk.getCount() - 1);\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n  \n      }\n  }\n  \n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n  \n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n  \n          Desk desk = new Desk();\n  \n          Foodie f = new Foodie(desk);\n          Cooker c = new Cooker(desk);\n  \n          f.start();\n          c.start();\n  \n      }\n  }\n  ```\n\n### 3.4阻塞队列基本使用【理解】\n\n+ 阻塞队列继承结构\n\n  ![06_阻塞队列继承结构](.\\img\\06_阻塞队列继承结构.png)\n\n\n+ 常见BlockingQueue:\n\n   ArrayBlockingQueue: 底层是数组,有界\n\n   LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值\n\n+ BlockingQueue的核心方法:\n\n   put(anObject): 将参数放入队列,如果放不进去会阻塞\n\n   take(): 取出第一个数据,取不到会阻塞\n\n+ 代码示例\n\n  ```java\n  public class Demo02 {\n      public static void main(String[] args) throws Exception {\n          // 创建阻塞队列的对象,容量为 1\n          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);\n  \n          // 存储元素\n          arrayBlockingQueue.put(\"汉堡包\");\n  \n          // 取元素\n          System.out.println(arrayBlockingQueue.take());\n          System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞\n  \n          System.out.println(\"程序结束了\");\n      }\n  }\n  ```\n\n### 3.5阻塞队列实现等待唤醒机制【理解】\n\n+ 案例需求\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.构造方法中接收一个阻塞队列对象\n\n      2.在run方法中循环向阻塞队列中添加包子\n\n      3.打印添加结果\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n       1.构造方法中接收一个阻塞队列对象\n\n       2.在run方法中循环获取阻塞队列中的包子\n\n       3.打印获取结果\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建阻塞队列对象\n\n      创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象\n\n      分别开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Cooker extends Thread {\n  \n      private ArrayBlockingQueue<String> bd;\n  \n      public Cooker(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n  \n      @Override\n      public void run() {\n          while (true) {\n              try {\n                  bd.put(\"汉堡包\");\n                  System.out.println(\"厨师放入一个汉堡包\");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  }\n  \n  public class Foodie extends Thread {\n      private ArrayBlockingQueue<String> bd;\n  \n      public Foodie(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n  \n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n  \n          //套路:\n          //1. while(true)死循环\n          //2. synchronized 锁,锁对象要唯一\n          //3. 判断,共享数据是否结束. 结束\n          //4. 判断,共享数据是否结束. 没有结束\n          while (true) {\n              try {\n                  String take = bd.take();\n                  System.out.println(\"吃货将\" + take + \"拿出来吃了\");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n  \n      }\n  }\n  \n  public class Demo {\n      public static void main(String[] args) {\n          ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);\n  \n          Foodie f = new Foodie(bd);\n          Cooker c = new Cooker(bd);\n  \n          f.start();\n          c.start();\n      }\n  }\n  ```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"IOUtils（数据相关）","url":"/2023/03/18/commons-io整理的文档/","content":"# 1，IOUtils（数据相关）\n\n### 拷贝方法：\n\ncopy方法有多个重载方法，满足不同的输入输出流\n\nIOUtils.copy(InputStream input, OutputStream output)\n\nIOUtils.copy(InputStream input, OutputStream output, int bufferSize)//可指定缓冲区大小\n\nIOUtils.copy(InputStream input, Writer output, String inputEncoding)//可指定输入流的编码表\n\nIOUtils.copy(Reader input, Writer output)\n\nIOUtils.copy(Reader input, OutputStream output, String outputEncoding)//可指定输出流的编码表\n\n\n\n### 拷贝大文件的方法：\n\n// 这个方法适合拷贝较大的数据流，比如2G以上\n\nIOUtils.copyLarge(Reader input, Writer output) // 默认会用1024*4的buffer来读取\n\nIOUtils.copyLarge(Reader input, Writer output, char[] buffer)//可指定缓冲区大小\n\n \n\n### 将输入流转换成字符串\n\nIOUtils.toString(Reader input)\n\nIOUtils.toString(byte[] input, String encoding)\n\nIOUtils.toString(InputStream input, Charset encoding)\n\nIOUtils.toString(InputStream input, String encoding)\n\nIOUtils.toString(URI uri, String encoding)\n\nIOUtils.toString(URL url, String encoding)\n\n \n\n### 将输入流转换成字符数组\n\nIOUtils.toByteArray(InputStream input)\n\nIOUtils.toByteArray(InputStream input, int size)\n\nIOUtils.toByteArray(URI uri)\n\nIOUtils.toByteArray(URL url)\n\nIOUtils.toByteArray(URLConnection urlConn)\n\nIOUtils.toByteArray(Reader input, String encoding)\n\n \n\n### 字符串读写\n\nIOUtils.readLines(Reader input)\n\nIOUtils.readLines(InputStream input, Charset encoding)\n\nIOUtils.readLines(InputStream input, String encoding)\n\nIOUtils.writeLines(Collection<?> lines, String lineEnding, Writer writer)\n\nIOUtils.writeLines(Collection<?> lines, String lineEnding, OutputStream output, Charset encoding)\n\nIOUtils.writeLines(Collection<?> lines, String lineEnding, OutputStream output, String encoding)\n\n\n\n\n\n### 从一个流中读取内容\n\nIOUtils.read(InputStream input, byte[] buffer)\n\nIOUtils.read(InputStream input, byte[] buffer, int offset, int length) IOUtils.read(Reader input, char[] buffer)\n\nIOUtils.read(Reader input, char[] buffer, int offset, int length)\n\n\n\n\n\n### 把数据写入到输出流中\n\nIOUtils.write(byte[] data, OutputStream output)\n\nIOUtils.write(byte[] data, Writer output, Charset encoding)\n\nIOUtils.write(byte[] data, Writer output, String encoding)\n\nIOUtils.write(char[] data, Writer output)\n\nIOUtils.write(char[] data, OutputStream output, Charset encoding)\n\nIOUtils.write(char[] data, OutputStream output, String encoding)\n\nIOUtils.write(String data, Writer output)\n\nIOUtils.write(CharSequence data, Writer output)\n\n \n\n### 从一个流中读取内容，如果读取的长度不够，就会抛出异常\n\nIOUtils.readFully(InputStream input, int length)\n\nIOUtils.readFully(InputStream input, byte[] buffer)\n\nIOUtils.readFully(InputStream input, byte[] buffer, int offset, int length) IOUtils.readFully(Reader input, char[] buffer)\n\nIOUtils.readFully(Reader input, char[] buffer, int offset, int length)\n\n\n\n### 比较\n\nIOUtils.contentEquals(InputStream input1, InputStream input2) // 比较两个流是否相等\n\nIOUtils.contentEquals(Reader input1, Reader input2)\n\nIOUtils.contentEqualsIgnoreEOL(Reader input1, Reader input2) // 比较两个流，忽略换行符\n\n \n\n### 其他方法\n\nIOUtils.skip(InputStream input, long toSkip) // 跳过指定长度的流\n\nIOUtils.skip(Reader input, long toSkip)\n\nIOUtils.skipFully(InputStream input, long toSkip) // 如果忽略的长度大于现有的长度，就会抛出异常\n\nIOUtils.skipFully(Reader input, long toSkip)\n\n \n\n# 2，FileUtils（文件/文件夹相关）\n\n### 复制文件夹\n\nFileUtils.copyDirectory(File srcDir, File destDir) // 复制文件夹（文件夹里面的文件内容也会复制）\n\nFileUtils.copyDirectory(File srcDir, File destDir, FileFilter filter) // 复制文件夹，带有文件过滤功能\n\nFileUtils.copyDirectoryToDirectory(File srcDir, File destDir) // 以子目录的形式将文件夹复制到到另一个文件夹下\n\n \n\n### 复制文件\n\nFileUtils.copyFile(File srcFile, File destFile) // 复制文件\n\nFileUtils.copyFile(File input, OutputStream output) // 复制文件到输出流\n\nFileUtils.copyFileToDirectory(File srcFile, File destDir) // 复制文件到一个指定的目录\n\nFileUtils.copyInputStreamToFile(InputStream source, File destination) // 把输入流里面的内容复制到指定文件\n\nFileUtils.copyURLToFile(URL source, File destination) // 把URL 里面内容复制到文件(可以下载文件)\n\nFileUtils.copyURLToFile(URL source, File destination, int connectionTimeout, int readTimeout)\n\n \n\n### 把字符串写入文件\n\nFileUtils.writeStringToFile(File file, String data, String encoding)\n\nFileUtils.writeStringToFile(File file, String data, String encoding, boolean append)\n\n### 把字节数组写入文件\n\nFileUtils.writeByteArrayToFile(File file, byte[] data)\n\nFileUtils.writeByteArrayToFile(File file, byte[] data, boolean append) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len, boolean append)\n\n\n\n### 把集合里面的内容写入文件\n\n// encoding：文件编码，lineEnding：每行以什么结尾\n\nFileUtils.writeLines(File file, Collection<?> lines)\n\nFileUtils.writeLines(File file, Collection<?> lines, boolean append)\n\nFileUtils.writeLines(File file, Collection<?> lines, String lineEnding)\n\nFileUtils.writeLines(File file, Collection<?> lines, String lineEnding, boolean append)\n\nFileUtils.writeLines(File file, String encoding, Collection<?> lines)\n\nFileUtils.writeLines(File file, String encoding, Collection<?> lines, boolean append)\n\nFileUtils.writeLines(File file, String encoding, Collection<?> lines, String lineEnding)\n\nFileUtils.writeLines(File file, String encoding, Collection<?> lines, String lineEnding, boolean append)\n\n\n\n### 往文件里面写内容\n\nFileUtils.write(File file, CharSequence data, Charset encoding)\n\nFileUtils.write(File file, CharSequence data, Charset encoding, boolean append)\n\nFileUtils.write(File file, CharSequence data, String encoding)\n\nFileUtils.write(File file, CharSequence data, String encoding, boolean append)\n\n \n\n### 文件移动\n\nFileUtils.moveDirectory(File srcDir, File destDir) // 文件夹在内的所有文件都将移动FileUtils.moveDirectoryToDirectory(File src, File destDir, boolean createDestDir) // 以子文件夹的形式移动到另外一个文件下\n\nFileUtils.moveFile(File srcFile, File destFile) // 移动文件\n\nFileUtils.moveFileToDirectory(File srcFile, File destDir, boolean createDestDir) // 以子文件的形式移动到另外一个文件夹下\n\nFileUtils.moveToDirectory(File src, File destDir, boolean createDestDir) // 移动文件或者目录到指定的文件夹内\n\n \n\n### 清空和删除文件夹\n\nFileUtils.deleteDirectory(File directory) // 删除文件夹，包括文件夹和文件夹里面所有的文件\n\nFileUtils.cleanDirectory(File directory) // 清空文件夹里面的所有的内容\n\nFileUtils.forceDelete(File file) // 删除，会抛出异常\n\nFileUtils.deleteQuietly(File file) // 删除，不会抛出异常\n\n \n\n### 创建文件夹\n\nFileUtils.forceMkdir(File directory) // 创建文件夹(可创建多级)\n\nFileUtils.forceMkdirParent(File file) // 创建文件的父级目录\n\n \n\n### 获取文件输入/输出流\n\nFileUtils.openInputStream(File file)\n\nFileUtils.openOutputStream(File file)\n\n### 读取文件\n\nFileUtils.readFileToByteArray(File file) // 把文件读取到字节数组\n\nFileUtils.readFileToString(File file, Charset encoding) // 把文件读取成字符串\n\nFileUtils.readFileToString(File file, String encoding)\n\nFileUtils.readLines(File file, Charset encoding) // 把文件读取成字符串集合\n\nFileUtils.readLines(File file, String encoding)\n\n \n\n### 测试两个文件的修改时间\n\nFileUtils.isFileNewer(File file, Date date)\n\nFileUtils.isFileNewer(File file, File reference)\n\nFileUtils.isFileNewer(File file, long timeMillis)\n\nFileUtils.isFileOlder(File file, Date date)\n\nFileUtils.isFileOlder(File file, File reference)\n\nFileUtils.isFileOlder(File file, long timeMillis)\n\n \n\n \n\n### 文件/文件夹的迭代\n\nFileUtils.iterateFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)\n\nFileUtils.iterateFiles(File directory, String[] extensions, boolean recursive)\n\nFileUtils.iterateFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)\n\nFileUtils.lineIterator(File file)\n\nFileUtils.lineIterator(File file, String encoding)\n\n \n\nFileUtils.listFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)\n\nFileUtils.listFiles(File directory, String[] extensions, boolean recursive)\n\nFileUtils.listFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)\n\n \n\n### 其他\n\nFileUtils.isSymlink(File file) // 判断是否是符号链接\n\nFileUtils.directoryContains(File directory, File child) // 判断文件夹内是否包含某个文件或者文件夹\n\n FileUtils.sizeOf(File file) // 获取文件或者文件夹的大小\n\nFileUtils.getTempDirectory()// 获取临时目录文件\n\nFileUtils.getTempDirectoryPath()// 获取临时目录路径\n\nFileUtils.getUserDirectory()// 获取用户目录文件\n\nFileUtils.getUserDirectoryPath()// 获取用户目录路径\n\nFileUtils.touch(File file) // 创建文件\n\nFileUtils.contentEquals(File file1, File file2) // 比较两个文件内容是否相同\n\n\n# FilenameUtils（文件名/后缀名相关）\n\nFilenameUtils.concat(String basePath, String fullFilenameToAdd) // 合并目录和文件名为文件全路径\n\nFilenameUtils.getBaseName(String filename) // 去除目录和后缀后的文件名\n\nFilenameUtils.getExtension(String filename) // 获取文件的后缀\n\nFilenameUtils.getFullPath(String filename) // 获取文件的目录\n\nFilenameUtils.getName(String filename) // 获取文件名\n\nFilenameUtils.getPath(String filename) // 去除盘符后的路径\n\nFilenameUtils.getPrefix(String filename) // 盘符\n\nFilenameUtils.indexOfExtension(String filename) // 获取最后一个.的位置\n\nFilenameUtils.indexOfLastSeparator(String filename) // 获取最后一个/的位置\n\nFilenameUtils.normalize(String filename) // 获取当前系统格式化路径\n\nFilenameUtils.removeExtension(String filename) // 移除文件的扩展名\n\nFilenameUtils.separatorsToSystem(String path) // 转换分隔符为当前系统分隔符\n\nFilenameUtils.separatorsToUnix(String path) // 转换分隔符为linux系统分隔符\n\nFilenameUtils.separatorsToWindows(String path) // 转换分隔符为windows系统分隔符\n\nFilenameUtils.equals(String filename1, String filename2) // 判断文件路径是否相同，非格式化\n\nFilenameUtils.equalsNormalized(String filename1, String filename2) // 判断文件路径是否相同，格式化\n\nFilenameUtils.directoryContains(String canonicalParent, String canonicalChild) // 判断目录下是否包含指定文件或目录\n\nFilenameUtils.isExtension(String filename, String extension) // 判断文件扩展名是否包含在指定集合(数组、字符串)中\n\nFilenameUtils.wildcardMatch(String filename, String wildcardMatcher) // 判断文件扩展名是否和指定规则匹配\t\n\n\n\n```java\npackage io_test.hutool;\n\nimport cn.hutool.core.io.FileUtil;\n\nimport java.io.File;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Test01 {\n    public static void main(String[] args) {\n        // 创建file对象\n        File file = FileUtil.file(\"D://\",\"bbb\",\"a.txt\");\n        System.out.println(file);\n        // 创建文件夹\n        FileUtil.touch(file);\n        // 写入\n        ArrayList<String> list = new ArrayList<>();\n        list.add(\"aaa\");\n        Collections.addAll(list,\"aa\",\"bc\");\n        FileUtil.writeLines(list,file, StandardCharsets.UTF_8);\n        // 读取\n        List<String> strings = FileUtil.readLines(file, Charset.forName(\"UTF-8\"));\n        System.out.println(strings);\n\n\n    }\n}\n\n```\n\n","tags":["Java","Java总结"],"categories":["程序猿","Java基础"]},{"title":"IO序列化与反序列化流","url":"/2023/03/16/IO序列化流/","content":"# IO序列化流/对象操作输出流\n\n## 序列化流属于字节流---可以把Java中的对象写到本地文件中\n\n> Serializable接口里面是没有抽象方法，标记型接口\n> 一旦实现了这个接口，那么就表示当前的Student类可以被序列化\n> 理解：\n> 一个物品的合格证 \n\n```java\npackage day_31_IO;\n\nimport java.io.Serializable;\n\npublic class student implements Serializable {\n    /*\n    Serializable接口里面是没有抽象方法，标记型接口\n    一旦实现了这个接口，那么就表示当前的Student类可以被序列化\n    理解：\n    一个物品的合格证\n     */\n    private String name;\n    private int age;\n\n    public student() {\n    }\n\n    public student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"student{name = \" + name + \", age = \" + age + \"}\";\n    }\n}\n```\n\n```java\npackage day_31_IO;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\n\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        student student = new student();\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"src/day_31_IO/a.txt\"));\n        oos.writeObject(student);\n        oos.close();\n    }\n}\n```\n\n# 反序列化流/对象操作输入流\n\n> 可以把序列化到本地文件中的对象，读取到程序中来\n\n```java\npackage day_31_IO;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\n\npublic class Test02 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"src/day_31_IO/a.txt\"));\n        student o = (student) ois.readObject();\n        System.out.println(o);\n        ois.close();\n    }\n}\n```\n\n# 序列化流和反序列化流的细节\n\n1. 使用序列化流将对象写到文件时，需要让avabean:类实现Serializable接口。\n   否则，会出现NotSerializableException异常\n2. 序列化流写到文件中的数据是不能修改的，一旦修改就无法再次读回来了\n3. 序列化对象后，修改了Javabean类，再次反序列化，会不会有问题？\n   会出问题，会抛出Inva1 idClassException.异常\n   解决方案：给avabean:类添加serialVersionUID（序列号、版本号)\n4. 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？\n   解决方案：给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程\n\n\n\n```java\npackage day_31_IO;\n\nimport java.io.Serial;\nimport java.io.Serializable;\n\n/**\n * @author 19183\n */\npublic class Student implements Serializable {\n    @Serial\n    private static final long serialVersionUID = -564522693665319422L;\n    private String name;\n    private transient int age;\n\n\n    public Student(){\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"Student{name = \" + name + \", age = \" + age + \"}\";\n    }\n}\n\n```\n\n```java\npackage day_31_IO;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author 19183\n */\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        Student student = new Student(\"ss\",23);\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"src/day_31_IO/a.txt\"));\n        oos.writeObject(student);\n        oos.close();\n    }\n}\n```\n\n```java\npackage day_31_IO;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\n\n/**\n * @author 19183\n */\npublic class Test02 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"src/day_31_IO/a.txt\"));\n        Student o = (Student) ois.readObject();\n        System.out.println(o);\n        ois.close();\n    }\n}\n```\n\n# 读写多个对象\n\n```java\npackage day_31_IO;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\n\npublic class Test03 {\n    public static void main(String[] args) throws IOException {\n        Student s1 = new Student(\"dd\",23);\n        Student s2 = new Student(\"ee\",24);\n        Student s3 = new Student(\"ff\",25);\n        ArrayList<Student>list = new ArrayList<>();\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"src/day_31_IO/a.txt\"));\n        oos.writeObject(list);\n        oos.close();\n    }\n}\n\n```\n\n```java\npackage day_31_IO;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.util.ArrayList;\n\npublic class Test04 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"src/day_31_IO/a.txt\"));\n        ArrayList<Student> o = (ArrayList<Student>) ois.readObject();\n        for (Student student : o) {\n            System.out.println(student);\n        }\n    }\n}\n```\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"IO打印流","url":"/2023/03/16/IO打印流/","content":"# 打印流\n## 分类\n\n打印流一般是指：PrintStream,PrintWriter两个类\n\n## 字节打印流\n\n![](https://pic.imgdb.cn/item/6412d6e0ebf10e5d53d5edf3.jpg)\n\n![](https://pic.imgdb.cn/item/6412d77aebf10e5d53d8798d.jpg)\n\n### 特点\n\n1. 打印流只操作文件目的地，不操作数据源\n2. 特有的写出方法可以实现，数据原样写出\n   例如：打印：97\n   文件中：97\n   A\n   打印：true\n   文件中：true\n3. 持特有的写出方法，可以实现自动刷新，自动换行\n   打印一次数据=写出+换行+刷新\n\n```java\npackage day_31_IO.printstream;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\n\npublic class Test01 {\n    public static void main(String[] args) throws FileNotFoundException {\n        PrintStream ps = new PrintStream(new FileOutputStream(\"src/day_31_IO/printstream/a.txt\"));\n        ps.println(97);// 写出+自动刷新+ 自动换行  //97\n        ps.println(true);// 写出+自动刷新+ 自动换行  //true\n        ps.print(\"666\");\n        ps.printf(\"%s 爱上了%s \",\"阿珍0\",\"阿强\"); //阿珍爱上了啊强\n        ps.close();\n    }\n}\n```\n\n## 字符打印流\n\n![](https://pic.imgdb.cn/item/6412dc12ebf10e5d53e63175.jpg)\n\n```java\npackage day_31_IO.printstream;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        PrintWriter printWriter = new PrintWriter(new FileWriter(\"src/day_31_IO/printstream/a.txt\"),true);\n        printWriter.println(\"aaa\");\n        printWriter.print(\"bbb\");\n        printWriter.printf(\"%s dad is %d\",\"me\",27);\n        printWriter.close();\n    }\n}\n\n```\n\n## 打印流应用场景\n\n```java\npackage day_31_IO.printstream;\n\nimport java.io.PrintStream;\n\npublic class Test03 {\n    public static void main(String[] args) {\n        //获取打印流的对象，此打印流在虚拟机启动的时候，由虚拟机创建，默认指向控制台\n        //特殊的打印流，系统中的标准输出流，是不能关闭，在系统中是唯一的。\n        PrintStream out = System.out;\n        // 调用打印流中的方法println\n        // 写出数据，自动换行，自动刷新\n        out.println(\"aaa\");\n        out.close();\n        out.println(\"bbb\");\n        out.println(\"ccc\");\n        System.out.println(999);\n    }\n}\n\n```\n\n## 总结\n\n打印流有几种？各有什么特点？\n\n- 有字节打印流和字符打印流两种\n- x package day_31_IO;​import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.util.ArrayList;​public class Test04 {    public static void main(String[] args) throws IOException, ClassNotFoundException {        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"src/day_31_IO/a.txt\"));        ArrayList<Student> o = (ArrayList<Student>) ois.readObject();        for (Student student : o) {            System.out.println(student);        }    }}java\n- 字节打印流：默认自动刷新，特有的println自动换行\n- 字符打印流：自动刷新需要开启，特有的println自动换行","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"IO转换流","url":"/2023/03/15/转换流/","content":"## 转换流\n\n![](https://pic.imgdb.cn/item/6411ca0cebf10e5d53c27c9b.jpg)\n\n![](https://pic.imgdb.cn/item/6411cd78ebf10e5d53cb009c.jpg)\n\n![image-20230315215258051](C:\\Users\\19183\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230315215258051.png)\n\n![](https://pic.imgdb.cn/item/6411d614ebf10e5d53dc3dfd.jpg)\n\n# 练习\n\n## 练习一\n\n```java\npackage day_30_covertIO;\n\nimport java.io.*;\n\n/**\n * @author 19183\n */\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        InputStreamReader rd = new InputStreamReader(new FileInputStream(\"src/day_30_covertIO/a.txt\"), \"GBK\");\n        OutputStreamWriter ow = new OutputStreamWriter(new FileOutputStream(\"src/day_30_covertIO/b.txt\"),\"gbk\");\n        int len;\n        while (((len = rd.read())) != -1) {\n            ow.write((char) len);\n\n        }\n        ow.close();\n        rd.close();\n\n    }\n}\n\n```\n\n## 练习二\n\n```java\npackage day_30_covertIO;\n\nimport java.io.*;\n\n/**\n * @author 19183\n */\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        /*\n        利用字节流读取文件中的数据，每次读一整行，而且不能出现乱码\n        1.字节流在读取中文的时候，是会出现乱码的，但是字符流可以搞定\n        2.字节流里面是没有读一整行的方法的，只有字符缓冲流才能搞定\n         */\n        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(\"src/day_30_covertIO/c.txt\"));\n        BufferedReader rd = new BufferedReader(inputStreamReader);\n        String a = null;\n        while ((a = rd.readLine())!= null){\n            System.out.println(a);\n        }\n        rd.close();\n    }\n}\n\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"IO流--高级流","url":"/2023/03/14/IO流advanced/","content":"# IO流--缓冲流\n\n![](https://pic.imgdb.cn/item/64104674ebf10e5d5326e988.jpg)\n\n## 字节缓冲流\n\n> 原理：底层自带了长度为8192的缓冲区提高性能\n\n![](https://pic.imgdb.cn/item/64104739ebf10e5d53280ded.jpg)\n\n![](https://pic.imgdb.cn/item/64107019ebf10e5d536fe002.jpg)\n\n![](https://pic.imgdb.cn/item/641074e2ebf10e5d53784f14.jpg)","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"IO流练习","url":"/2023/03/14/IO流练习/","content":"## 文件夹拷贝\n\n```java\npackage day_28_io_test;\n\nimport java.io.*;\n\n/**\n * @author 19183\n */\npublic class Test01 {\n    public static void copyDir(File src, File dest) throws IOException {\n        dest.mkdirs();\n        // 递归\n        File[] file = src.listFiles();\n        // 遍历数组\n        assert file != null;\n        for (File item : file) {\n            if (item.isFile()) {\n                // 判断文件拷贝\n                FileInputStream fis = new FileInputStream(item);\n                FileOutputStream fom = new FileOutputStream(new File(dest, item.getName()));\n                byte[] bytes = new byte[1024];\n                int len;  // 数组中存了多少元素\n                while ((len = fis.read(bytes)) != -1) {\n                    fom.write(bytes, 0, len);\n                }\n                fom.close();\n                fis.close();\n            } else {\n                // 判断文件夹，递归\n                copyDir(item, new File(dest, item.getName()));\n\n            }\n        }\n\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        File src = new File(\"D:\\\\aaa\\\\src\");\n        File dest = new File(\"D:\\\\aaa\\\\dest\");\n\n        // 调用方法开始拷贝\n        copyDir(src, dest);\n\n    }\n}\n\n```\n\n## 文件加密解密\n\n```java\npackage day_28_io_test;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\n/**\n * @author 19183\n */\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        /*\n        为了保证文件的安全性，就需要对原始文件进行加密存储，再使用的时候再对其进行解密处理。\n        加密原理：\n        对原始文件中的每一个字节数据进行更改，然后将更改以后的数据存储到新的文件中。\n        解密原理：\n        读取加密之后的文件，按照加密的规则反向操作，变成原始文件。\n        ^:异或\n        两边相同：fa1se\n        两边不同：true\n\n        100: 1100100\n        10:  1010\n\n        1100100\n      ^ 0001010\n      ------------\n        1101110\n        十进制 ：110\n\n\n\n         */\n        // System.out.println(100^10);  //110\n        /*\n        1101110\n      ^ 0001010\n      ------------\n        1100100\n\n        十进制：100\n         */\n        // System.out.println(110^10);  //100\n        FileInputStream fim = new FileInputStream(\"D:\\\\aaa\\\\src\\\\e.jpg\");\n        FileOutputStream fom = new FileOutputStream(\"D:\\\\aaa\\\\src\\\\redu.jpg\");\n        int b;\n        while ((b = fim.read())!=-1){\n            fom.write(b^10);\n        }\n        fom.close();\n        fim.close();\n\n    }\n}\n\n```\n\n## 文件数据排序\n\n### 方法一\n\n```java\npackage day_28_io_test;\n\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic class Test03 {\n    public static void main(String[] args) throws IOException {\n        /*\n        文本文件中有以下的数据：\n        2-1-9-4-7-8\n        将文件中的数据进行排序，变成以下的数据：\n        1-2-4-7-8-9\n         */\n        // 读取数据\n        FileInputStream fim = new FileInputStream(\"src/day_28_io_test/a.txt\");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while ((ch = fim.read()) != -1) {\n\n            sb.append((char) ch);\n        }\n        fim.close();\n        System.out.println(sb);\n        String[] val = sb.toString().split(\"-\");\n        ArrayList<Integer> list = new ArrayList<>();\n        for (String s : val) {\n            int i = Integer.parseInt(s);\n            list.add(i);\n        }\n        list.sort(Comparator.comparingInt(o -> o));\n\n        FileWriter fw = new FileWriter(\"src/day_28_io_test/a.txt\", true);\n        for (int i = 0; i < list.size(); i++) {\n            if (i==0){\n                fw.write(\"\\r\\n\");\n            }\n            if (i == list.size() - 1) {\n                fw.write(list.get(i) + \"\");\n            } else {\n                fw.write(list.get(i) + \"-\");\n            }\n        }\n        fw.close();\n\n    }\n}\n\n```\n\n### 方法二\n\n```java\npackage day_28_io_test;\n\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * @author 19183\n */\npublic class Test04 {\n    public static void main(String[] args) throws IOException {\n         /*\n        文本文件中有以下的数据：\n        2-1-9-4-7-8\n        将文件中的数据进行排序，变成以下的数据：\n        1-2-4-7-8-9\n         */\n        // 读取数据\n        FileInputStream fim = new FileInputStream(\"src/day_28_io_test/b.txt\");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while ((ch = fim.read()) != -1) {\n\n            sb.append((char) ch);\n        }\n        fim.close();\n        System.out.println(sb);\n        Integer[] arr = Arrays.stream(sb.toString().split(\"-\"))\n                .map(Integer::parseInt)\n                .sorted()\n                .toArray(Integer[]::new);\n        System.out.println(Arrays.toString(arr));\n\n        FileWriter fw = new FileWriter(\"src/day_28_io_test/b.txt\",true);\n        fw.write(\"\\r\\n\");\n        String replace = Arrays.toString(arr).replace(\", \", \"-\");\n\n        String substring = replace.substring(1, replace.length() - 1);\n        fw.write(substring);\n        fw.close();\n    }\n}\n\n```\n\n## 一次读取多个字节\n\n```java\npackage day_28_io_test;\n\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/**\n * @author 19183\n */\npublic class Test04 {\n    public static void main(String[] args) throws IOException {\n         /*\n        文本文件中有以下的数据：\n        2-1-9-4-7-8\n        将文件中的数据进行排序，变成以下的数据：\n        1-2-4-7-8-9\n         */\n        // 读取数据\n        FileInputStream fim = new FileInputStream(\"src/day_28_io_test/b.txt\");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while ((ch = fim.read()) != -1) {\n\n            sb.append((char) ch);\n        }\n        fim.close();\n        System.out.println(sb);\n        Integer[] arr = Arrays.stream(sb.toString().split(\"-\"))\n                .map(Integer::parseInt)\n                .sorted()\n                .toArray(Integer[]::new);\n        System.out.println(Arrays.toString(arr));\n\n        FileWriter fw = new FileWriter(\"src/day_28_io_test/b.txt\",true);\n        fw.write(\"\\r\\n\");\n        String replace = Arrays.toString(arr).replace(\", \", \"-\");\n\n        String substring = replace.substring(1, replace.length() - 1);\n        fw.write(substring);\n        fw.close();\n    }\n}\n\n```\n\n## 字节流写入\n\n```java\npackage day_27_io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class ByteStreamDemo2 {\n    public static void main(String[] args) throws IOException {\n        /*\n        void write(int b)   一次写一个字节数据\n        void write(byte[]b) 一次写一个 字节数组 数据\n        void write(byte[]b,int off,int len) 一次写一个 字节数组 的部分数据\n         */\n\n        // 创建对象\n        FileOutputStream fos1 = new FileOutputStream(\"src/day_27_IO/a.txt\");\n        byte[] b = {97,98,99,100};\n//        fos1.write(b); //a\n        fos1.write(b,1,3);\n        fos1.close();\n\n    }\n}\n\n```\n\n## 换行，续写\n\n```java\npackage day_27_io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class ByteStreamDemo3 {\n    public static void main(String[] args) throws IOException {\n\n        /*\n        换行写：\n            再次写出一个换行符就可以了\n            windows: /r/n\n            Linux:/n\n            Mac:/r\n        细节：\n            在windows操作系统当中，java对回车换行进行了优化。\n            虽然完整的是\\r\\n,但是我们写其中一个\\r或者\\n,\n            java也可以实现换行，因为java在底层会补全。\n\n            建议：\n            不要省略，还是写全了。\n\n            续写：\n            如果想要续写，打开续写开关即可\n            开关位置：创建对象的第二个参数\n            默认fa1se:表示关闭续写，此时创建对象会清空文件\n            手动传递tue:表示打开续写，此时创建对象不会清空文件\n         */\n        // append : 续写开关\n        FileOutputStream fos2 = new FileOutputStream(\"src/day_27_IO/a.txt\",true);\n        String s = \"wozuishuai\";\n        fos2.write(s.getBytes());\n        String s2 = \"\\r\\n\";\n        fos2.write(s2.getBytes());\n        String s3 = \"666\";\n        fos2.write(s3.getBytes());\n    }\n}\n\n```\n\n## 缓冲流\n\n```java\npackage day_29_advanced_io;\n\nimport java.io.*;\n\n/**\n * @author 19183\n */\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        /*\n        需求：\n        利用字节缓冲流拷贝文件\n        字节缓冲输入流的构造方法：\n        public BufferedInputstream(Inputstream is)\n        字节缓冲输出流的构造方法：\n        public Bufferedoutputstream(Outputstream os)\n         */\n        // 创建缓冲流的对象\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"src/day_29_advanced_io/a.txt\"));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"src/day_29_advanced_io/b.txt\"));\n        int b;\n        while ((b= bis.read())!=-1){\n            bos.write(b);\n        }\n        bos.close();\n        bis.close();\n    }\n\n}\n\n```\n\n### 练习2\n\n```java\npackage day_29_advanced_io;\n\nimport java.io.*;\n\n/**\n * @author 19183\n */\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"src/day_29_advanced_io/c.txt\"));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"src/day_29_advanced_io/d.txt\"));\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes))!=-1){\n            bos.write(bytes,0,len);\n        }\n        bos.close();\n        bis.close();\n    }\n}\n\n```\n\n### 练习3\n\n```java\npackage day_29_advanced_io;\n\nimport java.io.*;\n\n/**\n * @author 19183\n */\npublic class Test03 {\n    public static void main(String[] args) throws IOException {\n        /*\n        字符缓冲输入流：\n        构造方法：\n        public BufferedReader(Reader r)\n        特有方法：\n        public String readLine()\n        读一整行\n         */\n        BufferedReader bfd = new BufferedReader(new FileReader(\"src/day_29_advanced_io/a.txt\"));\n        BufferedWriter bfw = new BufferedWriter(new FileWriter(\"src/day_29_advanced_io/f.txt\"));\n        /*\n         readLine方法在读取的时候，一次读一整行，遇到回车换行结束\n         但是他不会把回车换行读到内存当中\n         */\n        String line;\n        while ((line = bfd.readLine()) != null) {\n            System.out.println(line);\n            bfw.write(line);\n            bfw.newLine();\n        }\n        bfw.close();\n        bfd.close();\n\n    }\n}\n\n```\n\n### 练习四\n\n```java\npackage day_29_advanced_io;\n\nimport java.io.*;\nimport java.util.ArrayList;\n\n/**\n * @author 19183\n */\npublic class Test04 {\n    public static void main(String[] args) throws IOException {\n        /*\n        3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。\n8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。\n4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。\n2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。\n1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n9.今当远离，临表涕零，不知所言。\n6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。\n7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。\n5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。\n         \n         进行正确排序\n         */\n        BufferedReader bfd = new BufferedReader(new FileReader(\"src/day_29_advanced_io/csb.txt\"));\n        String line;\n        ArrayList<String> list = new ArrayList<>();\n        while ((line = bfd.readLine()) != null) {\n            list.add(line);\n        }\n        list.sort((o1, o2) -> {\n            int i1 = Integer.parseInt(o1.split(\"\\\\.\")[0]);\n            int i2 = Integer.parseInt(o2.split(\"\\\\.\")[0]);\n            return i1 - i2;\n        });\n        bfd.close();\n        BufferedWriter bfw = new BufferedWriter(new FileWriter(\"src/day_29_advanced_io/csbX.txt\"));\n        for (String s : list) {\n            bfw.write(s);\n            bfw.newLine();\n        }\n        bfw.close();\n    }\n}\n\n```\n\n### 练习五\n\n```java\npackage day_29_advanced_io;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.util.TreeMap;\n\npublic class Test05 {\n    public static void main(String[] args) {\n        BufferedReader br new BufferedReader(new FileReader(fileName:\"myio\\\\csb.txt\"));\n        String line;\n        TreeMap<Integer,String> tm new TreeMap<>();\n        while((line br.readLine())!=null){\n            String[]arr line.split(regex:\"\\.\")\n//0:序号1：内容\n            tm.put(Integer.parseInt(arr[]),arr[1]);\n            br.close();\n            \n            //2.写出数据\nBufferedWriter bw new BufferedWriter(new Filewriter(fileName:\"myio\\\\result2.txt\"));\nSet<Map.Entry<Integer,String>>entries tm.entrySet();\nfor (Map.Entry<Integer,String>entry entries){\nString value entry.getValue();\nbw.write(value);\nI\nbw.newLine();\n)\nbw.close();\n    }\n}\n\n```\n\n### 练习六\n\n```java\npackage day_29_advanced_io;\n\nimport java.io.*;\n\n/**\n * @author 19183\n */\npublic class Test05 {\n    public static void main(String[] args) throws IOException {\n        /*\n        实现一个验证程序运行次数的小程序，要求如下：\n        1.当程序运行超过3次时给出提示：本软件只能免费使用3次，欢迎您注册会员后继续使用~\n        2.程序运行演示如下：\n        第一次运行控制台输出：欢迎使用本软件，第1次使用免费~\n        第二次运行控制台输出：欢迎使用本软件，第2次使用免费~\n        第三次运行控制台输出：欢迎使用本软件，第3次使用免费~\n        第四次及之后运行控制台输出：本软件只能免费使用3次，欢迎您注册会员后继续使用~\n         */\n        BufferedReader bfd = new BufferedReader(new FileReader(\"src/day_29_advanced_io/count.txt\"));\n\n        String s = bfd.readLine();\n        int count = Integer.parseInt(s);\n        count++;\n        BufferedWriter bfw = new BufferedWriter(new FileWriter(\"src/day_29_advanced_io/count.txt\"));\n        bfw.write(count+\"\");\n        if (count <= 3) {\n            System.out.println(\"你是第\" + count + \"次运行软件\");\n        } else {\n            System.out.println(\"请付费使用\");\n        }\n        bfw.close();\n        bfd.close();\n\n\n    }\n}\n\n```\n\n# 综合练习\n\n```java\npackage io_test.test;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Test1_01 {\n    public static void main(String[] args) throws IOException {\n        String familyNameNet = \"https://hanyu.baidu.com/shici/detail?pid=0b2f26d4c0ddb3ee693fdb1137ee1b0d&from=kg0\";\n        String boyNameNet = \"http://www.haoming8.cn/baobao/10881.html\";\n        String gir1NameNet = \"http://www.haoming8.cn/baobao/7641.html\";\n        String val1 = getConnection(familyNameNet);\n        // String val2 = getConnection(boyNameNet);\n        // String val3 = getConnection(gir1NameNet);\n        ArrayList<String> data = getData(val1,\"(.{4})(，|。)\",1);\n        System.out.println(data);\n\n\n    }\n    public static ArrayList<String> getData(String src ,String regex,int index){\n        ArrayList<String> list = new ArrayList<>();\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(src);\n        while (matcher.find()){\n            String group = matcher.group(index);\n            list.add(group);\n\n        }\n        return list;\n\n    }\n\n    public static String getConnection(String url) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        URL url1 = new URL(url);\n        URLConnection urlConnection = url1.openConnection();\n        InputStreamReader ipr = new InputStreamReader(urlConnection.getInputStream());\n        int b;\n        while ((b = ipr.read()) != -1) {\n            sb.append((char) b);\n        }\n        ipr.close();\n        return sb.toString();\n\n    }\n}\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"IO流(其他流)","url":"/2023/03/14/IO流（其他流）(1)/","content":"# 1. 缓冲流\n\n昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。\n\n## 1.1 概述\n\n缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：\n\n* **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` \n* **字符缓冲流**：`BufferedReader`，`BufferedWriter`\n\n缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n\n## 1.2 字节缓冲流\n\n### 构造方法\n\n* `public BufferedInputStream(InputStream in)` ：创建一个 新的缓冲输入流。 \n* `public BufferedOutputStream(OutputStream out)`： 创建一个新的缓冲输出流。\n\n构造举例，代码如下：\n\n```java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n```\n\n### 效率测试\n\n查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。\n\n1. 基本流，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      \tlong start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n        \tFileInputStream fis = new FileInputStream(\"jdk9.exe\");\n        \tFileOutputStream fos = new FileOutputStream(\"copy.exe\")\n        ){\n        \t// 读写数据\n            int b;\n            while ((b = fis.read()) != -1) {\n                fos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"普通流复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n\n十几分钟过去了...\n```\n\n2. 缓冲流，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      \tlong start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n        \tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\"));\n\t     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\"));\n        ){\n        // 读写数据\n            int b;\n            while ((b = bis.read()) != -1) {\n                bos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n\n缓冲流复制时间:8016 毫秒\n```\n如何更快呢？\n\n使用数组的方式，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n      \t// 记录开始时间\n        long start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\"));\n\t\t BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\"));\n        ){\n          \t// 读写数据\n            int len;\n            byte[] bytes = new byte[8*1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0 , len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n缓冲流使用数组复制时间:666 毫秒\n```\n\n## 1.3 字符缓冲流\n\n### 构造方法\n\n* `public BufferedReader(Reader in)` ：创建一个 新的缓冲输入流。 \n* `public BufferedWriter(Writer out)`： 创建一个新的缓冲输出流。\n\n构造举例，代码如下：\n\n```java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n```\n\n### 特有方法\n\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n\n* BufferedReader：`public String readLine()`: 读一行文字。 \n* BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。 \n\n`readLine`方法演示，代码如下：\n\n```java\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException {\n      \t // 创建流对象\n        BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));\n\t\t// 定义字符串,保存读取的一行文字\n        String line  = null;\n      \t// 循环读取,读取到最后返回null\n        while ((line = br.readLine())!=null) {\n            System.out.print(line);\n            System.out.println(\"------\");\n        }\n\t\t// 释放资源\n        br.close();\n    }\n}\n```\n\n`newLine`方法演示，代码如下：\n\n  ```java\npublic class BufferedWriterDemo throws IOException {\n    public static void main(String[] args) throws IOException  {\n      \t// 创建流对象\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\"));\n      \t// 写出数据\n        bw.write(\"黑马\");\n      \t// 写出换行\n        bw.newLine();\n        bw.write(\"程序\");\n        bw.newLine();\n        bw.write(\"员\");\n        bw.newLine();\n\t\t// 释放资源\n        bw.close();\n    }\n}\n输出效果:\n黑马\n程序\n员\n  ```\n\n## 1.4 练习:文本排序\n\n请将文本信息恢复顺序。\n\n```\n3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。\n8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。\n4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。\n2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。\n1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n9.今当远离，临表涕零，不知所言。\n6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。\n7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。\n5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。\n```\n\n### 案例分析\n\n1. 逐行读取文本信息。\n2. 把读取到的文本存储到集合中\n3. 对集合中的文本进行排序\n4. 遍历集合，按顺序，写出文本信息。\n\n### 案例实现\n\n```java\npublic class Demo05Test {\n    public static void main(String[] args) throws IOException {\n        //1.创建ArrayList集合,泛型使用String\n        ArrayList<String> list = new ArrayList<>();\n        //2.创建BufferedReader对象,构造方法中传递FileReader对象\n        BufferedReader br = new BufferedReader(new FileReader(\"10_IO\\\\in.txt\"));\n        //3.创建BufferedWriter对象,构造方法中传递FileWriter对象\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"10_IO\\\\out.txt\"));\n        //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本\n        String line;\n        while((line = br.readLine())!=null){\n            //5.把读取到的文本存储到ArrayList集合中\n            list.add(line);\n        }\n        //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序\n        Collections.sort(list, new Comparator<String>() {\n            /*\n                o1-o2:升序\n                o2-o1:降序\n             */\n            @Override\n            public int compare(String o1, String o2) {\n                //依次比较集合中两个元素的首字母,升序排序\n                return o1.charAt(0)-o2.charAt(0);\n            }\n        });\n        //7.遍历ArrayList集合,获取每一个元素\n        for (String s : list) {\n            //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中)\n            bw.write(s);\n            //9.写换行\n            bw.newLine();\n        }\n        //10.释放资源\n        bw.close();\n        br.close();\n    }\n}\n```\n\n\n\n# 2. 转换流\n\n## 2.1 字符编码和字符集\n\n### 字符编码\n\n计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为**编码** 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为**解码** 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n\n编码:字符(能看懂的)--字节(看不懂的)\n\n解码:字节(看不懂的)-->字符(能看懂的)\n\n* **字符编码`Character Encoding`** : 就是一套自然语言的字符与二进制数之间的对应规则。\n\n  编码表:生活中文字和计算机中二进制的对应规则\n\n### 字符集\n\n* **字符集 `Charset`**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。![](img/1_charset.jpg)\n\n可见，当指定了**编码**，它所对应的**字符集**自然就指定了，所以**编码**才是我们最终要关心的。\n\n* **ASCII字符集** ：\n  * ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n  * 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n* **ISO-8859-1字符集**：\n  * 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\n  * ISO-8859-1使用单字节编码，兼容ASCII编码。\n* **GBxxx字符集**：\n  * GB就是国标的意思，是为了显示中文而设计的一套字符集。\n  * **GB2312**：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。\n  * **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\n  * **GB18030**：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n* **Unicode字符集** ：\n  * Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n  * 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\n  * UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n    1. 128个US-ASCII字符，只需一个字节编码。\n    2. 拉丁文等字符，需要二个字节编码。 \n    3. 大部分常用字（含中文），使用三个字节编码。\n    4. 其他极少使用的Unicode辅助字符，使用四字节编码。\n\n## 2.2 编码引出的问题\n\n在IDEA中，使用`FileReader` 读取项目中的文本文件。由于IDEA的设置，都是默认的`UTF-8`编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n```java\npublic class ReaderDemo {\n    public static void main(String[] args) throws IOException {\n        FileReader fileReader = new FileReader(\"E:\\\\File_GBK.txt\");\n        int read;\n        while ((read = fileReader.read()) != -1) {\n            System.out.print((char)read);\n        }\n        fileReader.close();\n    }\n}\n输出结果：\n���\n```\n\n那么如何读取GBK编码的文件呢？ \n\n## 2.3 InputStreamReader类  \n\n转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n### 构造方法\n\n* `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 \n* `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n构造举例，代码如下： \n\n```java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n```\n\n### 指定编码读取\n\n```java\npublic class ReaderDemo2 {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径,文件为gbk编码\n        String FileName = \"E:\\\\file_gbk.txt\";\n      \t// 创建流对象,默认UTF8编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n      \t// 创建流对象,指定GBK编码\n        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n\t\t// 定义变量,保存字符\n        int read;\n      \t// 使用默认编码字符流读取,乱码\n        while ((read = isr.read()) != -1) {\n            System.out.print((char)read); // ��Һ�\n        }\n        isr.close();\n      \n      \t// 使用指定编码字符流读取,正常解析\n        while ((read = isr2.read()) != -1) {\n            System.out.print((char)read);// 大家好\n        }\n        isr2.close();\n    }\n}\n```\n\n## 2.4 OutputStreamWriter类\n\n转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n### 构造方法\n\n- `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 \n- `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n构造举例，代码如下： \n\n```java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n```\n\n### 指定编码写出\n\n```java\npublic class OutputDemo {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径\n        String FileName = \"E:\\\\out.txt\";\n      \t// 创建流对象,默认UTF8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n        // 写出数据\n      \tosw.write(\"你好\"); // 保存为6个字节\n        osw.close();\n      \t\n\t\t// 定义文件路径\n\t\tString FileName2 = \"E:\\\\out2.txt\";\n     \t// 创建流对象,指定GBK编码\n        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n        // 写出数据\n      \tosw2.write(\"你好\");// 保存为4个字节\n        osw2.close();\n    }\n}\n```\n\n### 转换流理解图解\n\n**转换流是字节与字符间的桥梁！**![](img/2_zhuanhuan.jpg)\n\n## 2.5 练习：转换文件编码\n\n将GBK编码的文本文件，转换为UTF-8编码的文本文件。\n\n### 案例分析\n\n1. 指定GBK编码的转换流，读取文本文件。\n2. 使用UTF-8编码的转换流，写出文本文件。\n\n### 案例实现\n\n```java\npublic class TransDemo {\n   public static void main(String[] args) {      \n    \t// 1.定义文件路径\n     \tString srcFile = \"file_gbk.txt\";\n        String destFile = \"file_utf8.txt\";\n\t\t// 2.创建流对象\n    \t// 2.1 转换输入流,指定GBK编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , \"GBK\");\n    \t// 2.2 转换输出流,默认utf8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));\n\t\t// 3.读写数据\n    \t// 3.1 定义数组\n        char[] cbuf = new char[1024];\n    \t// 3.2 定义长度\n        int len;\n    \t// 3.3 循环读取\n        while ((len = isr.read(cbuf))!=-1) {\n            // 循环写出\n          \tosw.write(cbuf,0,len);\n        }\n    \t// 4.释放资源\n        osw.close();\n        isr.close();\n  \t}\n}\n```\n\n# 3. 序列化\n\n## 3.1 概述\n\nJava 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该`对象的数据`、`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中**持久保存**了一个对象的信息。 \n\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。`对象的数据`、`对象的类型`和`对象中存储的数据`信息，都可以用来在内存中创建对象。看图理解序列化： ![](img/3_xuliehua.jpg)\n\n## 3.2 ObjectOutputStream类\n\n`java.io.ObjectOutputStream ` 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n\n### 构造方法\n\n* `public ObjectOutputStream(OutputStream out) `： 创建一个指定OutputStream的ObjectOutputStream。\n\n构造举例，代码如下：  \n\n```java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n### 序列化操作\n\n1. 一个对象要想序列化，必须满足两个条件:\n\n* 该类必须实现`java.io.Serializable ` 接口，`Serializable` 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException` 。\n* 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient` 关键字修饰。\n\n```java\npublic class Employee implements java.io.Serializable {\n    public String name;\n    public String address;\n    public transient int age; // transient瞬态修饰成员,不会被序列化\n    public void addressCheck() {\n      \tSystem.out.println(\"Address  check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n2.写出对象方法\n\n* `public final void writeObject (Object obj)` : 将指定的对象写出。\n\n```java\npublic class SerializeDemo{\n   \tpublic static void main(String [] args)   {\n    \tEmployee e = new Employee();\n    \te.name = \"zhangsan\";\n    \te.address = \"beiqinglu\";\n    \te.age = 20; \n    \ttry {\n      \t\t// 创建序列化流对象\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n        \t// 写出对象\n        \tout.writeObject(e);\n        \t// 释放资源\n        \tout.close();\n        \tfileOut.close();\n        \tSystem.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n        } catch(IOException i)   {\n            i.printStackTrace();\n        }\n   \t}\n}\n输出结果：\nSerialized data is saved\n```\n\n## 3.3 ObjectInputStream类\n\nObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n\n### 构造方法\n\n* `public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。\n\n### 反序列化操作1\n\n如果能找到一个对象的class文件，我们可以进行反序列化操作，调用`ObjectInputStream`读取对象的方法：\n\n- `public final Object readObject ()` : 读取一个对象。\n\n```java\npublic class DeserializeDemo {\n   public static void main(String [] args)   {\n        Employee e = null;\n        try {\t\t\n             // 创建反序列化流\n             FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n             ObjectInputStream in = new ObjectInputStream(fileIn);\n             // 读取一个对象\n             e = (Employee) in.readObject();\n             // 释放资源\n             in.close();\n             fileIn.close();\n        }catch(IOException i) {\n             // 捕获其他异常\n             i.printStackTrace();\n             return;\n        }catch(ClassNotFoundException c)  {\n        \t// 捕获类找不到异常\n             System.out.println(\"Employee class not found\");\n             c.printStackTrace();\n             return;\n        }\n        // 无异常,直接打印输出\n        System.out.println(\"Name: \" + e.name);\t// zhangsan\n        System.out.println(\"Address: \" + e.address); // beiqinglu\n        System.out.println(\"age: \" + e.age); // 0\n    }\n}\n```\n\n**对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 `ClassNotFoundException` 异常。**  \n\n### **反序列化操作2**\n\n**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。**发生这个异常的原因如下：\n\n* 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n* 该类包含未知数据类型 \n* 该类没有可访问的无参数构造方法 \n\n`Serializable` 接口给需要序列化的类，提供了一个序列版本号。`serialVersionUID` 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n```java\npublic class Employee implements java.io.Serializable {\n     // 加入序列版本号\n     private static final long serialVersionUID = 1L;\n     public String name;\n     public String address;\n     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n     public int eid; \n\n     public void addressCheck() {\n         System.out.println(\"Address  check : \" + name + \" -- \" + address);\n     }\n}\n```\n\n\n\n## 3.4 练习：序列化集合\n\n1. 将存有多个自定义对象的集合序列化操作，保存到`list.txt`文件中。\n2. 反序列化`list.txt` ，并遍历集合，打印对象信息。\n\n### 案例分析\n\n1. 把若干学生对象 ，保存到集合中。\n2. 把集合序列化。\n3. 反序列化读取时，只需要读取一次，转换为集合类型。\n4. 遍历集合，可以打印所有的学生信息\n\n### 案例实现\n\n```java\npublic class SerTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 创建 学生对象\n\t\tStudent student = new Student(\"老王\", \"laow\");\n\t\tStudent student2 = new Student(\"老张\", \"laoz\");\n\t\tStudent student3 = new Student(\"老李\", \"laol\");\n\n\t\tArrayList<Student> arrayList = new ArrayList<>();\n\t\tarrayList.add(student);\n\t\tarrayList.add(student2);\n\t\tarrayList.add(student3);\n\t\t// 序列化操作\n\t\t// serializ(arrayList);\n\t\t\n\t\t// 反序列化  \n\t\tObjectInputStream ois  = new ObjectInputStream(new FileInputStream(\"list.txt\"));\n\t\t// 读取对象,强转为ArrayList类型\n\t\tArrayList<Student> list  = (ArrayList<Student>)ois.readObject();\n\t\t\n      \tfor (int i = 0; i < list.size(); i++ ){\n          \tStudent s = list.get(i);\n        \tSystem.out.println(s.getName()+\"--\"+ s.getPwd());\n      \t}\n\t}\n\n\tprivate static void serializ(ArrayList<Student> arrayList) throws Exception {\n\t\t// 创建 序列化流 \n\t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"list.txt\"));\n\t\t// 写出对象\n\t\toos.writeObject(arrayList);\n\t\t// 释放资源\n\t\toos.close();\n\t}\n}\n```\n\n\n#  4. 打印流\n\n## 4.1 概述\n\n平时我们在控制台打印输出，是调用`print`方法和`println`方法完成的，这两个方法都来自于`java.io.PrintStream`类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n\n## 4.2 PrintStream类\n\n### 构造方法\n\n* `public PrintStream(String fileName)  `： 使用指定的文件名创建一个新的打印流。\n\n构造举例，代码如下：  \n\n```java\nPrintStream ps = new PrintStream(\"ps.txt\")；\n```\n\n### 改变打印流向\n\n`System.out`就是`PrintStream`类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个\"小把戏\"，改变它的流向。\n\n```java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n\t\t// 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n      \n\t\t// 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream(\"ps.txt\");\n      \t\n      \t// 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n      \t// 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}\n```\n\n# 5. 压缩流和解压缩流\n\n压缩流：\n\n​\t负责压缩文件或者文件夹\n\n解压缩流：\n\n​\t负责把压缩包中的文件和文件夹解压出来\n\n```java\n/*\n*   解压缩流\n*\n* */\npublic class ZipStreamDemo1 {\n    public static void main(String[] args) throws IOException {\n\n        //1.创建一个File表示要解压的压缩包\n        File src = new File(\"D:\\\\aaa.zip\");\n        //2.创建一个File表示解压的目的地\n        File dest = new File(\"D:\\\\\");\n\n        //调用方法\n        unzip(src,dest);\n\n    }\n\n    //定义一个方法用来解压\n    public static void unzip(File src,File dest) throws IOException {\n        //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中\n        //创建一个解压缩流用来读取压缩包中的数据\n        ZipInputStream zip = new ZipInputStream(new FileInputStream(src));\n        //要先获取到压缩包里面的每一个zipentry对象\n        //表示当前在压缩包中获取到的文件或者文件夹\n        ZipEntry entry;\n        while((entry = zip.getNextEntry()) != null){\n            System.out.println(entry);\n            if(entry.isDirectory()){\n                //文件夹：需要在目的地dest处创建一个同样的文件夹\n                File file = new File(dest,entry.toString());\n                file.mkdirs();\n            }else{\n                //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放）\n                FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString()));\n                int b;\n                while((b = zip.read()) != -1){\n                    //写到目的地\n                    fos.write(b);\n                }\n                fos.close();\n                //表示在压缩包中的一个文件处理完毕了。\n                zip.closeEntry();\n            }\n        }\n        zip.close();\n    }\n}\n```\n\n```java\npublic class ZipStreamDemo2 {\n    public static void main(String[] args) throws IOException {\n        /*\n         *   压缩流\n         *      需求：\n         *          把D:\\\\a.txt打包成一个压缩包\n         * */\n        //1.创建File对象表示要压缩的文件\n        File src = new File(\"D:\\\\a.txt\");\n        //2.创建File对象表示压缩包的位置\n        File dest = new File(\"D:\\\\\");\n        //3.调用方法用来压缩\n        toZip(src,dest);\n    }\n\n    /*\n    *   作用：压缩\n    *   参数一：表示要压缩的文件\n    *   参数二：表示压缩包的位置\n    * */\n    public static void toZip(File src,File dest) throws IOException {\n        //1.创建压缩流关联压缩包\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,\"a.zip\")));\n        //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹\n        //参数：压缩包里面的路径\n        ZipEntry entry = new ZipEntry(\"aaa\\\\bbb\\\\a.txt\");\n        //3.把ZipEntry对象放到压缩包当中\n        zos.putNextEntry(entry);\n        //4.把src文件中的数据写到压缩包当中\n        FileInputStream fis = new FileInputStream(src);\n        int b;\n        while((b = fis.read()) != -1){\n            zos.write(b);\n        }\n        zos.closeEntry();\n        zos.close();\n    }\n}\n```\n\n```java\npublic class ZipStreamDemo3 {\n    public static void main(String[] args) throws IOException {\n        /*\n         *   压缩流\n         *      需求：\n         *          把D:\\\\aaa文件夹压缩成一个压缩包\n         * */\n        //1.创建File对象表示要压缩的文件夹\n        File src = new File(\"D:\\\\aaa\");\n        //2.创建File对象表示压缩包放在哪里（压缩包的父级路径）\n        File destParent = src.getParentFile();//D:\\\\\n        //3.创建File对象表示压缩包的路径\n        File dest = new File(destParent,src.getName() + \".zip\");\n        //4.创建压缩流关联压缩包\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest));\n        //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中\n        toZip(src,zos,src.getName());//aaa\n        //6.释放资源\n        zos.close();\n    }\n\n    /*\n    *   作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中\n    *   参数一：数据源\n    *   参数二：压缩流\n    *   参数三：压缩包内部的路径\n    * */\n    public static void toZip(File src,ZipOutputStream zos,String name) throws IOException {\n        //1.进入src文件夹\n        File[] files = src.listFiles();\n        //2.遍历数组\n        for (File file : files) {\n            if(file.isFile()){\n                //3.判断-文件，变成ZipEntry对象，放入到压缩包当中\n                ZipEntry entry = new ZipEntry(name + \"\\\\\" + file.getName());//aaa\\\\no1\\\\a.txt\n                zos.putNextEntry(entry);\n                //读取文件中的数据，写到压缩包\n                FileInputStream fis = new FileInputStream(file);\n                int b;\n                while((b = fis.read()) != -1){\n                    zos.write(b);\n                }\n                fis.close();\n                zos.closeEntry();\n            }else{\n                //4.判断-文件夹，递归\n                toZip(file,zos,name + \"\\\\\" + file.getName());\n                //     no1            aaa   \\\\   no1\n            }\n        }\n    }\n}\n```\n\n# 6. 工具包（Commons-io）\n\n介绍：\n\n​\tCommons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API\n\n比如：\n\n​\tStringUtils   字符串工具类\n\n​\tNumberUtils   数字工具类 \n\n​\tArrayUtils   数组工具类  \n\n​\tRandomUtils   随机数工具类\n\n​\tDateUtils   日期工具类 \n\n​\tStopWatch   秒表工具类 \n\n​\tClassUtils   反射工具类  \n\n​\tSystemUtils   系统工具类  \n\n​\tMapUtils   集合工具类\n\n​\tBeanutils   bean工具类\n\n​\tCommons-io io的工具类\n\n​\t等等.....\n\n其中：Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。\n\n作用：提高IO流的开发效率。\n\n使用方式：\n\n1，新建lib文件夹\n\n2，把第三方jar包粘贴到文件夹中\n\n3，右键点击add as a library\n\n代码示例：\n\n```java\npublic class CommonsIODemo1 {\n    public static void main(String[] args) throws IOException {\n        /*\n          FileUtils类\n                static void copyFile(File srcFile, File destFile)                   复制文件\n                static void copyDirectory(File srcDir, File destDir)                复制文件夹\n                static void copyDirectoryToDirectory(File srcDir, File destDir)     复制文件夹\n                static void deleteDirectory(File directory)                         删除文件夹\n                static void cleanDirectory(File directory)                          清空文件夹\n                static String readFileToString(File file, Charset encoding)         读取文件中的数据变成成字符串\n                static void write(File file, CharSequence data, String encoding)    写出数据\n\n            IOUtils类\n                public static int copy(InputStream input, OutputStream output)      复制文件\n                public static int copyLarge(Reader input, Writer output)            复制大文件\n                public static String readLines(Reader input)                        读取数据\n                public static void write(String data, OutputStream output)          写出数据\n         */\n\n\n        /* File src = new File(\"myio\\\\a.txt\");\n        File dest = new File(\"myio\\\\copy.txt\");\n        FileUtils.copyFile(src,dest);*/\n\n\n        /*File src = new File(\"D:\\\\aaa\");\n        File dest = new File(\"D:\\\\bbb\");\n        FileUtils.copyDirectoryToDirectory(src,dest);*/\n\n        /*File src = new File(\"D:\\\\bbb\");\n        FileUtils.cleanDirectory(src);*/\n\n\n\n    }\n}\n\n```\n\n# 7. 工具包（hutool）\n\n介绍：\n\n​\tCommons是国人开发的开源工具包，里面有很多帮助我们提高开发效率的API\n\n比如：\n\n​\tDateUtil  日期时间工具类 \n\n​\tTimeInterval  计时器工具类 \n\n​\tStrUtil  字符串工具类\n\n​\tHexUtil   16进制工具类\n\n​\tHashUtil   Hash算法类\n\n​\tObjectUtil  对象工具类\n\n​\tReflectUtil   反射工具类\n\n​\tTypeUtil  泛型类型工具类\n\n​\tPageUtil  分页工具类\n\n​\tNumberUtil  数字工具类\n\n使用方式：\n\n1，新建lib文件夹\n\n2，把第三方jar包粘贴到文件夹中\n\n3，右键点击add as a library\n\n代码示例：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n    /*\n        FileUtil类:\n                file：根据参数创建一个file对象\n                touch：根据参数创建文件\n\n                writeLines：把集合中的数据写出到文件中，覆盖模式。\n                appendLines：把集合中的数据写出到文件中，续写模式。\n                readLines：指定字符编码，把文件中的数据，读到集合中。\n                readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中\n\n                copy：拷贝文件或者文件夹\n    */\n\n\n       /* File file1 = FileUtil.file(\"D:\\\\\", \"aaa\", \"bbb\", \"a.txt\");\n        System.out.println(file1);//D:\\aaa\\bbb\\a.txt\n\n        File touch = FileUtil.touch(file1);\n        System.out.println(touch);\n\n\n        ArrayList<String> list = new ArrayList<>();\n        list.add(\"aaa\");\n        list.add(\"aaa\");\n        list.add(\"aaa\");\n\n        File file2 = FileUtil.writeLines(list, \"D:\\\\a.txt\", \"UTF-8\");\n        System.out.println(file2);*/\n\n      /*  ArrayList<String> list = new ArrayList<>();\n        list.add(\"aaa\");\n        list.add(\"aaa\");\n        list.add(\"aaa\");\n        File file3 = FileUtil.appendLines(list, \"D:\\\\a.txt\", \"UTF-8\");\n        System.out.println(file3);*/\n        List<String> list = FileUtil.readLines(\"D:\\\\a.txt\", \"UTF-8\");\n        System.out.println(list);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Java","Java总结"],"categories":["程序猿","Java基础"]},{"title":"IO流--IO概述","url":"/2023/03/14/IO流（字节流&字符流）/","content":"# 1. IO概述\n\n## 1.1 什么是IO\n\n生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了`ctrl+s` ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。\n\n我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为`输入input` 和`输出output` ，即流向内存是输入流，流出内存的输出流。\n\nJava中I/O操作主要是指使用`java.io`包下的内容，进行输入、输出操作。**输入**也叫做**读取**数据，**输出**也叫做作**写出**数据。\n\n## 1.2 IO的分类\n\n根据数据的流向分为：**输入流**和**输出流**。\n\n* **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 \n* **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。\n\n格局数据的类型分为：**字节流**和**字符流**。\n\n* **字节流** ：以字节为单位，读写数据的流。\n* **字符流** ：以字符为单位，读写数据的流。\n\n## 1.3 IO的流向说明图解\n\n![](img/1_io.jpg)\n\n## 1.4 顶级父类们\n\n|         |          **输入流**           |             输出流             |\n| :-----: | :------------------------: | :-------------------------: |\n| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |\n| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |\n\n# 2. 字节流\n\n## 2.1 一切皆为字节\n\n一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n\n## 2.2 字节输出流【OutputStream】\n\n`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  \n* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  \n* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  \n* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  \n* `public abstract void write(int b)` ：将指定的字节输出流。\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 2.3 FileOutputStream类\n\n`OutputStream`有很多子类，我们从最简单的一个子类开始。\n\n`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。\n\n### 构造方法\n\n* `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 \n* `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  \n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。\n\n* 构造举例，代码如下：\n\n```java\npublic class FileOutputStreamConstructor throws IOException {\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileOutputStream fos = new FileOutputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"b.txt\");\n    }\n}\n```\n\n### 写出字节数据\n\n1. **写出字节**：`write(int b)` 方法，每次可以写出一个字节数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      \t// 写出数据\n      \tfos.write(97); // 写出第1个字节\n      \tfos.write(98); // 写出第2个字节\n      \tfos.write(99); // 写出第3个字节\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\nabc\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **写出字节数组**：`write(byte[] b)`，每次可以写出数组中的数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = \"黑马程序员\".getBytes();\n      \t// 写出字节数组数据\n      \tfos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\n黑马程序员\n```\n\n3. **写出指定长度字节数组**：`write(byte[] b, int off, int len)` ,每次写出从off索引开始，len个字节，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = \"abcde\".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\ncd\n```\n\n### 数据追加续写\n\n经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？\n\n- `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  \n- `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。  \n\n这两个构造方法，参数中都需要传入一个boolean类型的值，`true` 表示追加数据，`false` 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\"，true);     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = \"abcde\".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n文件操作前：cd\n文件操作后：cdabcde\n```\n\n### 写出换行\n\nWindows系统里，换行符号是`\\r\\n` 。把\n\n以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");  \n      \t// 定义字节数组\n      \tbyte[] words = {97,98,99,100,101};\n      \t// 遍历数组\n        for (int i = 0; i < words.length; i++) {\n          \t// 写出一个字节\n            fos.write(words[i]);\n          \t// 写出一个换行, 换行符号转成数组写出\n            fos.write(\"\\r\\n\".getBytes());\n        }\n      \t// 关闭资源\n        fos.close();\n    }\n}\n\n输出结果：\na\nb\nc\nd\ne\n```\n\n> * 回车符`\\r`和换行符`\\n` ：\n>   * 回车符：回到一行的开头（return）。\n>   * 换行符：下一行（newline）。\n> * 系统中的换行：\n>   * Windows系统里，每行结尾是 `回车+换行` ，即`\\r\\n`；\n>   * Unix系统里，每行结尾只有 `换行` ，即`\\n`；\n>   * Mac系统里，每行结尾是 `回车` ，即`\\r`。从 Mac OS X开始与Linux统一。\n\n## 2.4 字节输入流【InputStream】\n\n`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    \n- `public abstract int read()`： 从输入流读取数据的下一个字节。 \n- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 2.5 FileInputStream类\n\n`java.io.FileInputStream `类是文件输入流，从文件中读取字节。\n\n### 构造方法\n\n* `FileInputStream(File file)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 \n* `FileInputStream(String name)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  \n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出`FileNotFoundException` 。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileInputStreamConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileInputStream fos = new FileInputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileInputStream fos = new FileInputStream(\"b.txt\");\n    }\n}\n```\n\n### 读取字节数据\n\n1. **读取字节**：`read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream(\"read.txt\");\n      \t// 读取数据，返回一个字节\n        int read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n      \t// 读取到末尾,返回-1\n       \tread = fis.read();\n        System.out.println( read);\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n-1\n```\n\n循环改进读取方式，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream(\"read.txt\");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fis.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n```\n\n> 小贴士：\n>\n> 1. 虽然读取了一个字节，但是会自动提升为int类型。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **使用字节数组读取**：`read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组变成字符串打印\n            System.out.println(new String(b));\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ned\n```\n\n错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，上次读取的数据没有被完全替换，所以要通过`len` ，获取有效的字节，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ne\n```\n\n> 小贴士：\n>\n> 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\n\n## 2.6 字节流练习：图片复制\n\n### 复制原理图解\n\n![](img/2_copy.jpg)\n\n### 案例实现\n\n复制图片文件，代码使用演示：\n\n```java\npublic class Copy {\n    public static void main(String[] args) throws IOException {\n        // 1.创建流对象\n        // 1.1 指定数据源\n        FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\");\n        // 1.2 指定目的地\n        FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\");\n\n        // 2.读写数据\n        // 2.1 定义数组\n        byte[] b = new byte[1024];\n        // 2.2 定义长度\n        int len;\n        // 2.3 循环读取\n        while ((len = fis.read(b))!=-1) {\n            // 2.4 写出数据\n            fos.write(b, 0 , len);\n        }\n\n        // 3.关闭资源\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n> 小贴士：\n>\n> 流的关闭原则：先开后关，后开先关。\n\n# 3. 字符流\n\n当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\n\n## 3.1 字符输入流【Reader】\n\n`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    \n- `public int read()`： 从输入流读取一个字符。 \n- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\n## 3.2 FileReader类  \n\n`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n> 小贴士：\n>\n> 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。\n>\n>    idea中UTF-8\n>\n> 2. 字节缓冲区：一个字节数组，用来临时存储字节数据。\n\n### 构造方法\n\n- `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   \n- `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileReaderConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileReader fr = new FileReader(file);\n      \n        // 使用文件名称创建流对象\n        FileReader fr = new FileReader(\"b.txt\");\n    }\n}\n```\n\n### 读取字符数据\n\n1. **读取字符**：`read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`，循环读取，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader(\"read.txt\");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fr.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑\n马\n程\n序\n员\n```\n\n> 小贴士：虽然读取了一个字符，但是会自动提升为int类型。\n>\n\n2. **使用字符数组读取**：`read(char[] cbuf)`，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader(\"read.txt\");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n         char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf));\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑马\n程序\n员序\n```\n\n获取有效的字符改进，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader(\"read.txt\");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n        char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf,0,len));\n        }\n    \t// 关闭资源\n        fr.close();\n    }\n}\n\n输出结果：\n黑马\n程序\n员\n```\n\n## 3.3 字符输出流【Writer】\n\n`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n- `void write(int c)` 写入单个字符。\n- `void write(char[] cbuf) `写入字符数组。 \n- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 \n- `void write(String str) `写入字符串。 \n- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\n- `void flush() `刷新该流的缓冲。  \n- `void close()` 关闭此流，但要先刷新它。 \n\n## 3.4 FileWriter类\n\n`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n### 构造方法\n\n- `FileWriter(File file)`： 创建一个新的 FileWriter，给定要读取的File对象。   \n- `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileWriterConstructor {\n    public static void main(String[] args) throws IOException {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileWriter fw = new FileWriter(file);\n      \n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"b.txt\");\n    }\n}\n```\n\n### 基本写出数据\n\n**写出字符**：`write(int b)` 方法，每次可以写出一个字符数据，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 写出数据\n      \tfw.write(97); // 写出第1个字符\n      \tfw.write('b'); // 写出第2个字符\n      \tfw.write('C'); // 写出第3个字符\n      \tfw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。\n      \n      \t/*\n        【注意】关闭资源时,与FileOutputStream不同。\n      \t 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n        */\n        // fw.close();\n    }\n}\n输出结果：\nabC田\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。\n> 2. 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。\n\n### 关闭和刷新\n\n因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。\n\n* `flush` ：刷新缓冲区，流对象可以继续使用。\n* `close `:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n\n代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");\n        // 写出数据，通过flush\n        fw.write('刷'); // 写出第1个字符\n        fw.flush();\n        fw.write('新'); // 继续写出第2个字符，写出成功\n        fw.flush();\n      \n      \t// 写出数据，通过close\n        fw.write('关'); // 写出第1个字符\n        fw.close();\n        fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed\n        fw.close();\n    }\n}\n```\n\n> 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。\n\n### 写出其他数据\n\n1. **写出字符数组** ：`write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 字符串转换为字节数组\n      \tchar[] chars = \"黑马程序员\".toCharArray();\n      \n      \t// 写出字符数组\n      \tfw.write(chars); // 黑马程序员\n        \n\t\t// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。\n        fw.write(b,2,2); // 程序\n      \n      \t// 关闭资源\n        fos.close();\n    }\n}\n```\n\n2. **写出字符串**：`write(String str)` 和 `write(String str, int off, int len)` ，每次可以写出字符串中的数据，更为方便，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 字符串\n      \tString msg = \"黑马程序员\";\n      \n      \t// 写出字符数组\n      \tfw.write(msg); //黑马程序员\n      \n\t\t// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。\n        fw.write(msg,2,2);\t// 程序\n      \t\n        // 关闭资源\n        fos.close();\n    }\n}\n```\n\n3. **续写和换行**：操作类似于FileOutputStream。\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象，可以续写数据\n        FileWriter fw = new FileWriter(\"fw.txt\"，true);     \n      \t// 写出字符串\n        fw.write(\"黑马\");\n      \t// 写出换行\n      \tfw.write(\"\\r\\n\");\n      \t// 写出字符串\n  \t\tfw.write(\"程序员\");\n      \t// 关闭资源\n        fw.close();\n    }\n}\n输出结果:\n黑马\n程序员\n```\n\n> 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。\n>\n> 当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流\n\n# 4. IO异常的处理\n\n### JDK7前处理\n\n之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用`try...catch...finally` 代码块，处理异常部分，代码使用演示：\n\n```java  \npublic class HandleException1 {\n    public static void main(String[] args) {\n      \t// 声明变量\n        FileWriter fw = null;\n        try {\n            //创建流对象\n            fw = new FileWriter(\"fw.txt\");\n            // 写出数据\n            fw.write(\"黑马程序员\"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    fw.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### JDK7的处理(扩展知识点了解内容)\n\n还可以使用JDK7优化后的`try-with-resource` 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。\n\n格式：\n\n```java\ntry (创建流对象语句，如果多个,使用';'隔开) {\n\t// 读写数据\n} catch (IOException e) {\n\te.printStackTrace();\n}\n```\n\n代码使用演示：\n\n```java\npublic class HandleException2 {\n    public static void main(String[] args) {\n      \t// 创建流对象\n        try ( FileWriter fw = new FileWriter(\"fw.txt\"); ) {\n            // 写出数据\n            fw.write(\"黑马程序员\"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### JDK9的改进(扩展知识点了解内容)\n\nJDK9中`try-with-resource` 的改进，对于**引入对象**的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。\n\n改进前格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource(\"resource1\");\n// 普通对象\nResource resource2 = new Resource(\"resource2\");\n// 引入方式：创建新的变量保存\ntry (Resource r1 = resource1;\n     Resource r2 = resource2) {\n     // 使用对象\n}\n```\n\n改进后格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource(\"resource1\");\n// 普通对象\nResource resource2 = new Resource(\"resource2\");\n\n// 引入方式：直接引入\ntry (resource1; resource2) {\n     // 使用对象\n}\n```\n\n改进后，代码使用演示：\n\n```java\npublic class TryDemo {\n    public static void main(String[] args) throws IOException {\n       \t// 创建流对象\n        final  FileReader fr  = new FileReader(\"in.txt\");\n        FileWriter fw = new FileWriter(\"out.txt\");\n       \t// 引入到try中\n        try (fr; fw) {\n          \t// 定义变量\n            int b;\n          \t// 读取数据\n          \twhile ((b = fr.read())!=-1) {\n            \t// 写出数据\n            \tfw.write(b);\n          \t}\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 5. 综合练习\n\n## 练习1：拷贝文件夹\n\n```java\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        //拷贝一个文件夹，考虑子文件夹\n\n        //1.创建对象表示数据源\n        File src = new File(\"D:\\\\aaa\\\\src\");\n        //2.创建对象表示目的地\n        File dest = new File(\"D:\\\\aaa\\\\dest\");\n\n        //3.调用方法开始拷贝\n        copydir(src,dest);\n\n\n\n    }\n\n    /*\n    * 作用：拷贝文件夹\n    * 参数一：数据源\n    * 参数二：目的地\n    *\n    * */\n    private static void copydir(File src, File dest) throws IOException {\n        dest.mkdirs();\n        //递归\n        //1.进入数据源\n        File[] files = src.listFiles();\n        //2.遍历数组\n        for (File file : files) {\n            if(file.isFile()){\n                //3.判断文件，拷贝\n                FileInputStream fis = new FileInputStream(file);\n                FileOutputStream fos = new FileOutputStream(new File(dest,file.getName()));\n                byte[] bytes = new byte[1024];\n                int len;\n                while((len = fis.read(bytes)) != -1){\n                    fos.write(bytes,0,len);\n                }\n                fos.close();\n                fis.close();\n            }else {\n                //4.判断文件夹，递归\n                copydir(file, new File(dest,file.getName()));\n            }\n        }\n    }\n}\n\n```\n\n## 练习2：文件加密\n\n```java\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        /*\n            为了保证文件的安全性，就需要对原始文件进行加密存储，再使用的时候再对其进行解密处理。\n            加密原理：\n                对原始文件中的每一个字节数据进行更改，然后将更改以后的数据存储到新的文件中。\n            解密原理：\n                读取加密之后的文件，按照加密的规则反向操作，变成原始文件。\n\n             ^ : 异或\n                 两边相同：false\n                 两边不同：true\n\n                 0：false\n                 1：true\n\n               100:1100100\n               10: 1010\n\n               1100100\n             ^ 0001010\n             __________\n               1101110\n             ^ 0001010\n             __________\n               1100100\n\n        */\n    }\n\n    public static void encryptionAndReduction(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while ((b = fis.read()) != -1) {\n            fos.write(b ^ 2);\n        }\n        //4.释放资源\n        fos.close();\n        fis.close();\n    }\n\n\n}\n\n```\n\n## 练习3：数字排序\n\n文本文件中有以下的数据：\n                2-1-9-4-7-8\n 将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n\n实现方式一：\n\n```java\npublic class Test03 {\n    public static void main(String[] args) throws IOException {\n        /*\n            文本文件中有以下的数据：\n                2-1-9-4-7-8\n            将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n        */\n\n\n        //1.读取数据\n        FileReader fr = new FileReader(\"myio\\\\a.txt\");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while((ch = fr.read()) != -1){\n            sb.append((char)ch);\n        }\n        fr.close();\n        System.out.println(sb);\n        //2.排序\n        String str = sb.toString();\n        String[] arrStr = str.split(\"-\");//2-1-9-4-7-8\n\n        ArrayList<Integer> list = new ArrayList<>();\n        for (String s : arrStr) {\n            int i = Integer.parseInt(s);\n            list.add(i);\n        }\n        Collections.sort(list);\n        System.out.println(list);\n        //3.写出\n        FileWriter fw = new FileWriter(\"myio\\\\a.txt\");\n        for (int i = 0; i < list.size(); i++) {\n            if(i == list.size() - 1){\n                fw.write(list.get(i) + \"\");\n            }else{\n                fw.write(list.get(i) + \"-\");\n            }\n        }\n        fw.close();\n    }\n}\n```\n\n实现方式二：\n\n```java\npublic class Test04 {\n    public static void main(String[] args) throws IOException {\n        /*\n            文本文件中有以下的数据：\n                2-1-9-4-7-8\n            将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n\n           细节1：\n                文件中的数据不要换行\n\n            细节2:\n                bom头\n        */\n        //1.读取数据\n        FileReader fr = new FileReader(\"myio\\\\a.txt\");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while((ch = fr.read()) != -1){\n            sb.append((char)ch);\n        }\n        fr.close();\n        System.out.println(sb);\n        //2.排序\n        Integer[] arr = Arrays.stream(sb.toString()\n                                      .split(\"-\"))\n            .map(Integer::parseInt)\n            .sorted()\n            .toArray(Integer[]::new);\n        //3.写出\n        FileWriter fw = new FileWriter(\"myio\\\\a.txt\");\n        String s = Arrays.toString(arr).replace(\", \",\"-\");\n        String result = s.substring(1, s.length() - 1);\n        fw.write(result);\n        fw.close();\n    }\n}\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"字符流","url":"/2023/03/09/FileReader/","content":"# FileReader\n## reader\n> 2.读取数据read()\n> 字符流的底层也是字节流，默认也是一个字节一个字节的读取的。\n> 如果遇到中文就会一次读取多个，GBK一次读两个字节，UTF-8一次读三个字节\n>\n> read()细节：\n> 1.read():默认也是一个字节一个字节的读取的，如果遇到中文就会一次读取多个\n> 2.在读取之后，方法的底层还会进行解码并转成十进制。\n> 最终把这个十进制作为返回值\n> 这个十进制的数据也表示在字符集上的数字\n> 英文：文件里面二进制数据81168881\n> read方法进行读取，解码并转成十进制97\n> 中文：文件里面的二进制数据111081101811080110801001\n> read方法进行读取，解码并转成十进制27721\n> 我想看到中文汉字，就是把这些十进制数据，再进行强转就可以了\n\n## 字符流\n\n- 字符流的底层其实就是字节流\n- 字符流 = 字节流 + 字符集\n\n## 特点\n\n- 输入流：一次读一个字节，遇到中文时，一次读多个字节\n- 输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中\n\n## 使用场景\n\n- 对于纯文本文件进行读写操作","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"字符集详解","url":"/2023/03/09/字符集详解/","content":"# 字符集详解\n## GBK\n1. 在计算机中，任意数据都是以二进制的形式来存储的\n2. 计算机中最小的存储单元是一个字节\n3. ASCII字符集中，一个英文占一个字节\n4. 简体中文版Windows,默认使用GBK字符集\n5. GBK字符集完全兼容ASCII字符集\n   - 一个英文占一个字节，二进制第一位是0\n   - 一个中文占两个字节，二进制高位字节的第一位是1\n\n## Unicode\n\n1. Unicode字符集的UTF-8编码格式\n   - 一个英文占一个字节，二进制第一位是0，转成十进制是正数\n   - 一个中文占三个字节，二进制第一位是1，第一个字节转成十进制是负数\n\n## 如何不产生乱码？\n\n1. 不要用字节流读取文本文件\n2. 编码解码时使用同一个码表，同一个编码方式\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"IO流--基本流","url":"/2023/03/09/IO流/","content":"# IO流--基本流\n\n## F&Q\n\n1.  ### 什么是IO流？\n\n   + 存储和读取数据的解决方案\n     l:input\n     O:output\n     流：像水流一样传输数据\n\n2.  ### IO流的作用？\n\n   + 用于读写数据（本地文件，网络）\n\n3. ### IO流按照流向可以分类哪两种流？\n\n   + 输出流：程序 -> 文件\n     输入流：文件 -> 程序\n\n4. ### IO流按照操作文件的类型可以分类哪两种流？\n\n   - 字节流：可以操作所有类型的文件\n   - 字符流：只能操作纯文本文件\n\n5. ### 什么是纯文本文件？\n\n   - 用windows系统自带的记事本打开并且能读懂的文件\n   - 如： txt文件，md文件，xml文件，lrc文件等\n\n![](https://pic.imgdb.cn/item/64104674ebf10e5d5326e988.jpg)\n\n ## 字节输出流的细节：\n\n1.  创建字节输出流对象\n\n   > 细节1：参数是字符串表示的路径或者是Fi1e对象都是可以的\n   > 细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的。\n   > 细节3：如果文件已经存在，则会清空文件\n\n2. 写数据\n\n   > 细节：write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符\n\n3. 释放资源\n\n   > 每次使用完之后都要释放资源\n\n   ```java\n   FileOutputStream fos1 = new FileOutputStream(\"src/day_27_IO/a.txt\");\n   fos1.write(97);\n   fos1.close();\n   ```\n\n> 创建对象：文件存在、文件不存在、追加写入\n>\n> 写出数据：写出整数、写出字节数组、换行写\n>\n> 释放资源：关闭通道\n\n### FileOutputStream的作用:\n\n可以把程序中的数据写到本地文件上，是字节流的基本流。\n\n## 字节输入流的细节：\n\n> 操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来。\n\n1. 创建字节输入流对象\n\n   > 如果文件不存在，直接报错\n\n2. 读取数据\n\n   > 细节1： 一次读一个字节，读出来的是数据在ASCI上对应的数字\n   >\n   > 细节2：读到文件末尾了，read方法返回-1。\n\n3. 释放资源\n\n   > 细节1：每次使用完流必须要释放资源。 \n\n# 字符流\n\n## 字符流原理解析\n\n1. 创建字符输入流对象\n\n   - 底层：关联文件，并创建缓冲区（长度为8192的字节数组)\n\n2. 读取数据\n\n   - 底层\n\n     1. 判断缓冲区中是否有数据可以读取\n\n     2. 缓冲区没有数据：就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区\n        如果文件中也没有数据了，返回-1\n\n     3.  \n\n     4. 缓冲区有数据：就从缓冲区中读取。\n\n        >  空参的read方法：一次读取一个字节，遇到中文一次读多个字节，把字节解码并转成十进制返回\n        > 有参的read方法：把读取字节，解码，强转三步合并了，强转之后的字符放到数组中\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"异常","url":"/2023/03/09/IO(异常&File&综合案例）/","content":"# 1. 异常\n\n## 1.1 异常概念\n\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n* **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.\n\n## 1.2 异常体系\n\n异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。\n\n![](imgs\\异常体系.png)\n\n**Throwable体系：**\n\n* **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。\n* **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。\n\n**Throwable中的常用方法：**\n\n* `public void printStackTrace()`:打印异常的详细信息。\n\n  *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n* `public String getMessage()`:获取发生异常的原因。\n\n  *提示给用户的时候,就提示错误原因。*\n\n* `public String toString()`:获取异常的类型和异常描述信息(不用)。\n\n***出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。***\n\n![](imgs\\简单的异常查看.bmp)\n\n## 1.3 异常分类\n\n我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。\n\n**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?\n\n* **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n* **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\n\n​    ![](imgs\\异常的分类.png)\n\n## 1.4 异常的产生过程解析\n\n先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。\n\n 工具类\n\n```java\npublic class ArrayTools {\n    // 对给定的数组通过给定的角标获取元素。\n    public static int getElement(int[] arr, int index) {\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n 测试类\n\n```java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        int[] arr = { 34, 12, 67 };\n        intnum = ArrayTools.getElement(arr, 4)\n        System.out.println(\"num=\" + num);\n        System.out.println(\"over\");\n    }\n}\n```\n\n上述程序执行过程图解：\n\n ![](imgs\\异常产生过程.png)\n\n## 1.5 抛出异常throw\n\n在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。\n\n在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？\n\n1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。\n\n2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。\n\n   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\n\n**使用格式：**\n\n```\nthrow new 异常类名(参数);\n```\n\n 例如：\n\n```java\nthrow new NullPointerException(\"要访问的arr数组不存在\");\n\nthrow new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\");\n```\n\n学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。\n\n```java\npublic class ThrowDemo {\n    public static void main(String[] args) {\n        //创建一个数组 \n        int[] arr = {2,4,52,2};\n        //根据索引找对应的元素 \n        int index = 4;\n        int element = getElement(arr, index);\n\n        System.out.println(element);\n        System.out.println(\"over\");\n    }\n    /*\n     * 根据 索引找到数组中对应的元素\n     */\n    public static int getElement(int[] arr,int index){ \n       \t//判断  索引是否越界\n        if(index<0 || index>arr.length-1){\n             /*\n             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。\n             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 \n              */\n             throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了```\");\n        }\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。\n>\n> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。\n\n## 1.6 声明异常throws\n\n**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\n\n关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\n\n**声明异常格式：**\n\n```\n修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }\t\n```\n\n声明异常的代码演示：\n\n```java\npublic class ThrowsDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        read(\"a.txt\");\n    }\n\n    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\nthrows用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。\n\n```java\npublic class ThrowsDemo2 {\n    public static void main(String[] args) throws IOException {\n        read(\"a.txt\");\n    }\n\n    public static void read(String path)throws FileNotFoundException, IOException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n        if (!path.equals(\"b.txt\")) {\n            throw new IOException();\n        }\n    }\n}\n```\n\n## 1.7 捕获异常try…catch\n\n如果异常出现的话,会立刻终止程序,所以我们得处理异常:\n\n1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\n2. 在方法中使用try-catch的语句块来处理异常。\n\n**try-catch**的方式就是捕获异常。\n\n* **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\n\n捕获异常语法如下：\n\n```java\ntry{\n     编写可能会出现异常的代码\n}catch(异常类型  e){\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n```\n\n**try：**该代码块中编写可能产生异常的代码。\n\n**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。\n\n> 注意:try和catch都不能单独使用,必须连用。\n\n演示如下：\n\n```java\npublic class TryCatchDemo {\n    public static void main(String[] args) {\n        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。\n            read(\"b.txt\");\n        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？\n          \t//try中抛出的是什么异常，在括号中就定义什么异常类型\n            System.out.println(e);\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n如何获取异常信息：\n\nThrowable类中定义了一些查看方法:\n\n* `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。\n\n\n* `public String toString()`:获取异常的类型和异常描述信息(不用)。\n* `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。\n\n​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n在开发中呢也可以在catch将编译期异常转换成运行期异常处理。\n\n多个异常使用捕获又该如何处理呢？\n\n1. 多个异常分别处理。\n2. 多个异常一次捕获，多次处理。\n3. 多个异常一次捕获一次处理。\n\n一般我们是使用一次捕获多次处理方式，格式如下：\n\n```java\ntry{\n     编写可能会出现异常的代码\n}catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n```\n\n> 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。\n\n## 1.8 finally 代码块\n\n**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。\n\n什么时候的代码必须最终执行？\n\n当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\n\nfinally的语法:\n\n try...catch....finally:自身需要处理异常,最终还得关闭资源。\n\n> 注意:finally不能单独使用。\n\n比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\n\nfinally代码参考如下：\n\n```java\npublic class TryCatchDemo4 {\n    public static void main(String[] args) {\n        try {\n            read(\"a.txt\");\n        } catch (FileNotFoundException e) {\n            //抓取到的是编译期异常  抛出去的是运行期 \n            throw new RuntimeException(e);\n        } finally {\n            System.out.println(\"不管程序怎样，这里都将会被执行。\");\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n```\n\n> 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n\n## 1.9 异常注意事项\n\n* 运行时异常被抛出可以不处理。即不捕获也不声明抛出。\n* 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。\n* 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出\n* 当多异常处理时，捕获处理，前边的类不能是后边类的父类\n* 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。\n\n## 1.10 概述\n\n**为什么需要自定义异常类:**\n\n我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。\n\n在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？\n\n**什么是自定义异常类:**\n\n在开发中根据自己业务的异常情况来定义异常类.\n\n自定义一个业务逻辑异常: **LoginException**。一个登陆异常类。\n\n**异常类如何定义:**\n\n1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。\n2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。\n\n## 1.11 自定义异常的练习\n\n要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。\n\n首先定义一个登陆异常类LoginException：\n\n```java\n// 业务逻辑异常\npublic class LoginException extends Exception {\n    /**\n     * 空参构造\n     */\n    public LoginException() {\n    }\n\n    /**\n     *\n     * @param message 表示异常提示\n     */\n    public LoginException(String message) {\n        super(message);\n    }\n}\n```\n\n模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。\n\n```java\npublic class Demo {\n    // 模拟数据库中已存在账号\n    private static String[] names = {\"bill\",\"hill\",\"jill\"};\n   \n    public static void main(String[] args) {     \n        //调用方法\n        try{\n            // 可能出现异常的代码\n            checkUsername(\"nill\");\n            System.out.println(\"注册成功\");//如果没有异常就是注册成功\n        } catch(LoginException e) {\n            //处理异常\n            e.printStackTrace();\n        }\n    }\n\n    //判断当前注册账号是否存在\n    //因为是编译期异常，又想调用者去处理 所以声明该异常\n    public static boolean checkUsername(String uname) throws LoginException {\n        for (String name : names) {\n            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常\n                throw new LoginException(\"亲\"+name+\"已经被注册了！\");\n            }\n        }\n        return true;\n    }\n}\n```\n\n# 2. File类\n\n## 2.1 概述\n\n`java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n\n## 2.2 构造方法\n\n- `public File(String pathname) ` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。  \n- `public File(String parent, String child) ` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。\n- `public File(File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。  \n- 构造举例，代码如下：\n\n```java\n// 文件路径名\nString pathname = \"D:\\\\aaa.txt\";\nFile file1 = new File(pathname); \n\n// 文件路径名\nString pathname2 = \"D:\\\\aaa\\\\bbb.txt\";\nFile file2 = new File(pathname2); \n\n// 通过父路径和子路径字符串\n String parent = \"d:\\\\aaa\";\n String child = \"bbb.txt\";\n File file3 = new File(parent, child);\n\n// 通过父级File对象和子路径字符串\nFile parentDir = new File(\"d:\\\\aaa\");\nString child = \"bbb.txt\";\nFile file4 = new File(parentDir, child);\n```\n\n> 小贴士：\n>\n> 1. 一个File对象代表硬盘中实际存在的一个文件或者目录。\n> 2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n\n## 2.3 常用方法\n\n### 获取功能的方法\n\n- `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。\n\n- ` public String getPath() ` ：将此File转换为路径名字符串。 \n\n- `public String getName()`  ：返回由此File表示的文件或目录的名称。  \n\n- `public long length()`  ：返回由此File表示的文件的长度。 \n\n  方法演示，代码如下：\n\n  ```java\n  public class FileGet {\n      public static void main(String[] args) {\n          File f = new File(\"d:/aaa/bbb.java\");     \n          System.out.println(\"文件绝对路径:\"+f.getAbsolutePath());\n          System.out.println(\"文件构造路径:\"+f.getPath());\n          System.out.println(\"文件名称:\"+f.getName());\n          System.out.println(\"文件长度:\"+f.length()+\"字节\");\n  \n          File f2 = new File(\"d:/aaa\");     \n          System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath());\n          System.out.println(\"目录构造路径:\"+f2.getPath());\n          System.out.println(\"目录名称:\"+f2.getName());\n          System.out.println(\"目录长度:\"+f2.length());\n      }\n  }\n  输出结果：\n  文件绝对路径:d:\\aaa\\bbb.java\n  文件构造路径:d:\\aaa\\bbb.java\n  文件名称:bbb.java\n  文件长度:636字节\n  \n  目录绝对路径:d:\\aaa\n  目录构造路径:d:\\aaa\n  目录名称:aaa\n  目录长度:4096\n  ```\n\n> API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。\n\n### 绝对路径和相对路径\n\n- **绝对路径**：从盘符开始的路径，这是一个完整的路径。\n- **相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。\n\n```java\npublic class FilePath {\n    public static void main(String[] args) {\n      \t// D盘下的bbb.java文件\n        File f = new File(\"D:\\\\bbb.java\");\n        System.out.println(f.getAbsolutePath());\n      \t\n\t\t// 项目下的bbb.java文件\n        File f2 = new File(\"bbb.java\");\n        System.out.println(f2.getAbsolutePath());\n    }\n}\n输出结果：\nD:\\bbb.java\nD:\\idea_project_test4\\bbb.java\n```\n\n### 判断功能的方法\n\n- `public boolean exists()` ：此File表示的文件或目录是否实际存在。\n- `public boolean isDirectory()` ：此File表示的是否为目录。\n- `public boolean isFile()` ：此File表示的是否为文件。\n\n方法演示，代码如下：\n\n```java\npublic class FileIs {\n    public static void main(String[] args) {\n        File f = new File(\"d:\\\\aaa\\\\bbb.java\");\n        File f2 = new File(\"d:\\\\aaa\");\n      \t// 判断是否存在\n        System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists());\n        System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists());\n      \t// 判断是文件还是目录\n        System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile());\n        System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory());\n    }\n}\n输出结果：\nd:\\aaa\\bbb.java 是否存在:true\nd:\\aaa 是否存在:true\nd:\\aaa 文件?:false\nd:\\aaa 目录?:true\n```\n\n### 创建删除功能的方法\n\n- `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 \n- `public boolean delete()` ：删除由此File表示的文件或目录。  \n- `public boolean mkdir()` ：创建由此File表示的目录。\n- `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n方法演示，代码如下：\n\n```java\npublic class FileCreateDelete {\n    public static void main(String[] args) throws IOException {\n        // 文件的创建\n        File f = new File(\"aaa.txt\");\n        System.out.println(\"是否存在:\"+f.exists()); // false\n        System.out.println(\"是否创建:\"+f.createNewFile()); // true\n        System.out.println(\"是否存在:\"+f.exists()); // true\n\t\t\n     \t// 目录的创建\n      \tFile f2= new File(\"newDir\");\t\n        System.out.println(\"是否存在:\"+f2.exists());// false\n        System.out.println(\"是否创建:\"+f2.mkdir());\t// true\n        System.out.println(\"是否存在:\"+f2.exists());// true\n\n\t\t// 创建多级目录\n      \tFile f3= new File(\"newDira\\\\newDirb\");\n        System.out.println(f3.mkdir());// false\n        File f4= new File(\"newDira\\\\newDirb\");\n        System.out.println(f4.mkdirs());// true\n      \n      \t// 文件的删除\n       \tSystem.out.println(f.delete());// true\n      \n      \t// 目录的删除\n        System.out.println(f2.delete());// true\n        System.out.println(f4.delete());// false\n    }\n}\n```\n\n> API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。\n\n## 2.4 目录的遍历\n\n- `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。\n- `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。  \n\n```java\npublic class FileFor {\n    public static void main(String[] args) {\n        File dir = new File(\"d:\\\\java_code\");\n      \n      \t//获取当前目录下的文件以及文件夹的名称。\n\t\tString[] names = dir.list();\n\t\tfor(String name : names){\n\t\t\tSystem.out.println(name);\n\t\t}\n        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            System.out.println(file);\n        }\n    }\n}\n```\n\n> 小贴士：\n>\n> 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。\n\n## 2.5 综合练习\n\n#### 练习1：创建文件夹\n\n​\t在当前模块下的aaa文件夹中创建一个a.txt文件\n\n代码实现：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) throws IOException {\n        //需求：在当前模块下的aaa文件夹中创建一个a.txt文件\n\n        //1.创建a.txt的父级路径\n        File file = new File(\"myfile\\\\aaa\");\n        //2.创建父级路径\n        //如果aaa是存在的，那么此时创建失败的。\n        //如果aaa是不存在的，那么此时创建成功的。\n        file.mkdirs();\n        //3.拼接父级路径和子级路径\n        File src = new File(file,\"a.txt\");\n        boolean b = src.createNewFile();\n        if(b){\n            System.out.println(\"创建成功\");\n        }else{\n            System.out.println(\"创建失败\");\n        }\n    }\n}\n```\n\n#### 练习2：查找文件（不考虑子文件夹）\n\n​\t定义一个方法找某一个文件夹中，是否有以avi结尾的电影（暂时不需要考虑子文件夹）\n\n代码示例：\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        /*需求：\n             定义一个方法找某一个文件夹中，是否有以avi结尾的电影。\n\t        （暂时不需要考虑子文件夹）\n        */\n\n        File file = new File(\"D:\\\\aaa\\\\bbb\");\n        boolean b = haveAVI(file);\n        System.out.println(b);\n    }\n    /*\n    * 作用：用来找某一个文件夹中，是否有以avi结尾的电影\n    * 形参：要查找的文件夹\n    * 返回值：查找的结果  存在true  不存在false\n    * */\n    public static boolean haveAVI(File file){// D:\\\\aaa\n        //1.进入aaa文件夹，而且要获取里面所有的内容\n        File[] files = file.listFiles();\n        //2.遍历数组获取里面的每一个元素\n        for (File f : files) {\n            //f：依次表示aaa文件夹里面每一个文件或者文件夹的路径\n            if(f.isFile() && f.getName().endsWith(\".avi\")){\n                return true;\n            }\n        }\n        //3.如果循环结束之后还没有找到，直接返回false\n        return false;\n    }\n}\n```\n\n### 练习3：（考虑子文件夹）\n\n​\t找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）\n\n代码示例：\n\n```java\npublic class Test3 {\n    public static void main(String[] args) {\n        /* 需求：\n        找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）\n\n\n        套路：\n            1，进入文件夹\n            2，遍历数组\n            3，判断\n            4，判断\n\n        */\n\n        findAVI();\n\n    }\n\n    public static void findAVI(){\n        //获取本地所有的盘符\n        File[] arr = File.listRoots();\n        for (File f : arr) {\n            findAVI(f);\n        }\n    }\n\n    public static void findAVI(File src){//\"C:\\\\\n        //1.进入文件夹src\n        File[] files = src.listFiles();\n        //2.遍历数组,依次得到src里面每一个文件或者文件夹\n        if(files != null){\n            for (File file : files) {\n                if(file.isFile()){\n                    //3，判断，如果是文件，就可以执行题目的业务逻辑\n                    String name = file.getName();\n                    if(name.endsWith(\".avi\")){\n                        System.out.println(file);\n                    }\n                }else{\n                    //4，判断，如果是文件夹，就可以递归\n                    //细节：再次调用本方法的时候，参数一定要是src的次一级路径\n                    findAVI(file);\n                }\n            }\n        }\n    }\n}\n```\n\n### 练习4：删除多级文件夹\n\n需求： 如果我们要删除一个有内容的文件夹\n\t   1.先删除文件夹里面所有的内容\n           2.再删除自己\n\n代码示例：\n\n```java\npublic class Test4 {\n    public static void main(String[] args) {\n        /*\n           删除一个多级文件夹\n           如果我们要删除一个有内容的文件夹\n           1.先删除文件夹里面所有的内容\n           2.再删除自己\n        */\n\n        File file = new File(\"D:\\\\aaa\\\\src\");\n        delete(file);\n\n    }\n\n    /*\n    * 作用：删除src文件夹\n    * 参数：要删除的文件夹\n    * */\n    public static void delete(File src){\n        //1.先删除文件夹里面所有的内容\n        //进入src\n        File[] files = src.listFiles();\n        //遍历\n        for (File file : files) {\n            //判断,如果是文件，删除\n            if(file.isFile()){\n                file.delete();\n            }else {\n                //判断,如果是文件夹，就递归\n                delete(file);\n            }\n        }\n        //2.再删除自己\n        src.delete();\n    }\n}\n```\n\n### 练习5：统计大小\n\n​\t需求：统计一个文件夹的总大小\n\n代码示例：\n\n```java\npublic class Test5 {\n    public static void main(String[] args) {\n       /*需求：\n            统计一个文件夹的总大小\n      */\n\n\n        File file = new File(\"D:\\\\aaa\\\\src\");\n\n        long len = getLen(file);\n        System.out.println(len);//4919189\n    }\n\n    /*\n    * 作用：\n    *       统计一个文件夹的总大小\n    * 参数：\n    *       表示要统计的那个文件夹\n    * 返回值：\n    *       统计之后的结果\n    *\n    * 文件夹的总大小：\n    *       说白了，文件夹里面所有文件的大小\n    * */\n    public static long getLen(File src){\n        //1.定义变量进行累加\n        long len = 0;\n        //2.进入src文件夹\n        File[] files = src.listFiles();\n        //3.遍历数组\n        for (File file : files) {\n            //4.判断\n            if(file.isFile()){\n                //我们就把当前文件的大小累加到len当中\n                len = len + file.length();\n            }else{\n                //判断，如果是文件夹就递归\n                len = len + getLen(file);\n            }\n        }\n        return len;\n    }\n}\n```\n\n### 练习6：统计文件个数\n\n  需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）\n            打印格式如下：\n            txt:3个\n            doc:4个\n            jpg:6个\n\n代码示例：\n\n```java\npublic class Test6 {\n    public static void main(String[] args) throws IOException {\n        /*\n            需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）\n            打印格式如下：\n            txt:3个\n            doc:4个\n            jpg:6个\n        */\n        File file = new File(\"D:\\\\aaa\\\\src\");\n        HashMap<String, Integer> hm = getCount(file);\n        System.out.println(hm);\n    }\n\n    /*\n    * 作用：\n    *       统计一个文件夹中每种文件的个数\n    * 参数：\n    *       要统计的那个文件夹\n    * 返回值：\n    *       用来统计map集合\n    *       键：后缀名 值：次数\n    *\n    *       a.txt\n    *       a.a.txt\n    *       aaa（不需要统计的）\n    *\n    *\n    * */\n    public static HashMap<String,Integer> getCount(File src){\n        //1.定义集合用来统计\n        HashMap<String,Integer> hm = new HashMap<>();\n        //2.进入src文件夹\n        File[] files = src.listFiles();\n        //3.遍历数组\n        for (File file : files) {\n            //4.判断，如果是文件，统计\n            if(file.isFile()){\n                //a.txt\n                String name = file.getName();\n                String[] arr = name.split(\"\\\\.\");\n                if(arr.length >= 2){\n                    String endName = arr[arr.length - 1];\n                    if(hm.containsKey(endName)){\n                        //存在\n                        int count = hm.get(endName);\n                        count++;\n                        hm.put(endName,count);\n                    }else{\n                        //不存在\n                        hm.put(endName,1);\n                    }\n                }\n            }else{\n                //5.判断，如果是文件夹，递归\n                //sonMap里面是子文件中每一种文件的个数\n                HashMap<String, Integer> sonMap = getCount(file);\n                //hm:  txt=1  jpg=2  doc=3\n                //sonMap: txt=3 jpg=1\n                //遍历sonMap把里面的值累加到hm当中\n                Set<Map.Entry<String, Integer>> entries = sonMap.entrySet();\n                for (Map.Entry<String, Integer> entry : entries) {\n                    String key = entry.getKey();\n                    int value = entry.getValue();\n                    if(hm.containsKey(key)){\n                        //存在\n                        int count = hm.get(key);\n                        count = count + value;\n                        hm.put(key,count);\n                    }else{\n                        //不存在\n                        hm.put(key,value);\n                    }\n                }\n            }\n        }\n        return hm;\n    }\n}\n```\n\n\n\n\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"stream流和方法引用","url":"/2023/03/09/stream流和方法引用/","content":"## 1.不可变集合\n\n### 1.1 什么是不可变集合\n\n​\t是一个长度不可变，内容也无法修改的集合\n\n### 1.2 使用场景\n\n​\t如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。\n\n​\t当集合对象被不可信的库调用时，不可变形式是安全的。\n\n简单理解：\n\n​\t不想让别人修改集合中的内容\n\n比如说：\n\n1，斗地主的54张牌，是不能添加，不能删除，不能修改的\n\n2，斗地主的打牌规则：单张，对子，三张，顺子等，也是不能修改的\n\n3，用代码获取的操作系统硬件信息，也是不能被修改的\n\n### 1.3 不可变集合分类\n\n* 不可变的list集合\n* 不可变的set集合\n* 不可变的map集合\n\n### 1.4 不可变的list集合\n\n```java\npublic class ImmutableDemo1 {\n    public static void main(String[] args) {\n        /*\n            创建不可变的List集合\n            \"张三\", \"李四\", \"王五\", \"赵六\"\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        List<String> list = List.of(\"张三\", \"李四\", \"王五\", \"赵六\");\n\n        System.out.println(list.get(0));\n        System.out.println(list.get(1));\n        System.out.println(list.get(2));\n        System.out.println(list.get(3));\n\n        System.out.println(\"---------------------------\");\n\n        for (String s : list) {\n            System.out.println(s);\n        }\n\n        System.out.println(\"---------------------------\");\n\n\n        Iterator<String> it = list.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println(\"---------------------------\");\n\n        for (int i = 0; i < list.size(); i++) {\n            String s = list.get(i);\n            System.out.println(s);\n        }\n        System.out.println(\"---------------------------\");\n\n        //list.remove(\"李四\");\n        //list.add(\"aaa\");\n        list.set(0,\"aaa\");\n    }\n}\n```\n\n### 1.5 不可变的Set集合\n\n```java\npublic class ImmutableDemo2 {\n    public static void main(String[] args) {\n        /*\n           创建不可变的Set集合\n           \"张三\", \"李四\", \"王五\", \"赵六\"\n\n\n           细节：\n                当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        Set<String> set = Set.of(\"张三\", \"张三\", \"李四\", \"王五\", \"赵六\");\n\n        for (String s : set) {\n            System.out.println(s);\n        }\n\n        System.out.println(\"-----------------------\");\n\n        Iterator<String> it = set.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n\n        System.out.println(\"-----------------------\");\n        //set.remove(\"王五\");\n    }\n}\n```\n\n### 1.6 不可变的Map集合\n\n#### 1.6.1：键值对个数小于等于10\n\n```java\npublic class ImmutableDemo3 {\n    public static void main(String[] args) {\n       /*\n        创建Map的不可变集合\n            细节1：\n                键是不能重复的\n            细节2：\n                Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对\n            细节3：\n                如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        Map<String, String> map = Map.of(\"张三\", \"南京\", \"张三\", \"北京\", \"王五\", \"上海\",\n                \"赵六\", \"广州\", \"孙七\", \"深圳\", \"周八\", \"杭州\",\n                \"吴九\", \"宁波\", \"郑十\", \"苏州\", \"刘一\", \"无锡\",\n                \"陈二\", \"嘉兴\");\n\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            String value = map.get(key);\n            System.out.println(key + \"=\" + value);\n        }\n\n        System.out.println(\"--------------------------\");\n\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            System.out.println(key + \"=\" + value);\n        }\n        System.out.println(\"--------------------------\");\n    }\n}\n```\n\n#### 1.6.2：键值对个数大于10\n\n```java\npublic class ImmutableDemo4 {\n    public static void main(String[] args) {\n\n        /*\n            创建Map的不可变集合,键值对的数量超过10个\n        */\n\n        //1.创建一个普通的Map集合\n        HashMap<String, String> hm = new HashMap<>();\n        hm.put(\"张三\", \"南京\");\n        hm.put(\"李四\", \"北京\");\n        hm.put(\"王五\", \"上海\");\n        hm.put(\"赵六\", \"北京\");\n        hm.put(\"孙七\", \"深圳\");\n        hm.put(\"周八\", \"杭州\");\n        hm.put(\"吴九\", \"宁波\");\n        hm.put(\"郑十\", \"苏州\");\n        hm.put(\"刘一\", \"无锡\");\n        hm.put(\"陈二\", \"嘉兴\");\n        hm.put(\"aaa\", \"111\");\n\n        //2.利用上面的数据来获取一个不可变的集合\n/*\n        //获取到所有的键值对对象（Entry对象）\n        Set<Map.Entry<String, String>> entries = hm.entrySet();\n        //把entries变成一个数组\n        Map.Entry[] arr1 = new Map.Entry[0];\n        //toArray方法在底层会比较集合的长度跟数组的长度两者的大小\n        //如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组\n        //如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用\n        Map.Entry[] arr2 = entries.toArray(arr1);\n        //不可变的map集合\n        Map map = Map.ofEntries(arr2);\n        map.put(\"bbb\",\"222\");*/\n\n\n        //Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0]));\n\n        Map<String, String> map = Map.copyOf(hm);\n        map.put(\"bbb\",\"222\");\n    }\n}\n```\n\n## 2.Stream流\n\n### 2.1体验Stream流【理解】\n\n- 案例需求\n\n  按照下面的要求完成集合的创建和遍历\n\n  - 创建一个集合，存储多个字符串元素\n  - 把集合中所有以\"张\"开头的元素存储到一个新的集合\n  - 把\"张\"开头的集合中的长度为3的元素存储到一个新的集合\n  - 遍历上一步得到的集合\n\n- 原始方式示例代码\n\n  ```java\n  public class MyStream1 {\n      public static void main(String[] args) {\n          //集合的批量添加\n          ArrayList<String> list1 = new ArrayList<>(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\"));\n          //list.add()\n\n          //遍历list1把以张开头的元素添加到list2中。\n          ArrayList<String> list2 = new ArrayList<>();\n          for (String s : list1) {\n              if(s.startsWith(\"张\")){\n                  list2.add(s);\n              }\n          }\n          //遍历list2集合，把其中长度为3的元素，再添加到list3中。\n          ArrayList<String> list3 = new ArrayList<>();\n          for (String s : list2) {\n              if(s.length() == 3){\n                  list3.add(s);\n              }\n          }\n          for (String s : list3) {\n              System.out.println(s);\n          }      \n      }\n  }\n  ```\n\n- 使用Stream流示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //集合的批量添加\n          ArrayList<String> list1 = new ArrayList<>(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\"));\n\n          //Stream流\n          list1.stream().filter(s->s.startsWith(\"张\"))\n                  .filter(s->s.length() == 3)\n                  .forEach(s-> System.out.println(s));\n      }\n  }\n  ```\n\n- Stream流的好处\n\n  - 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印\n  - Stream流把真正的函数式编程风格引入到Java中\n  - 代码简洁\n\n### 2.2Stream流的常见生成方式【应用】\n\n- Stream流的思想\n\n  ![01_Stream流思想](.\\img\\01_Stream流思想.png)\n\n- Stream流的三类方法\n\n  - 获取Stream流\n    - 创建一条流水线,并把数据放到流水线上准备进行操作\n  - 中间方法\n    - 流水线上的操作\n    - 一次操作完毕之后,还可以继续进行其他操作\n  - 终结方法\n    - 一个Stream流只能有一个终结方法\n    - 是流水线上的最后一个操作\n\n- 生成Stream流的方式\n\n  - Collection体系集合\n\n    使用默认方法stream()生成流， default Stream<E> stream()\n\n  - Map体系集合\n\n    把Map转成Set集合，间接的生成流\n\n  - 数组\n\n    通过Arrays中的静态方法stream生成流\n\n  - 同种数据类型的多个数据\n\n    通过Stream接口的静态方法of(T... values)生成流\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //Collection体系的集合可以使用默认方法stream()生成流\n          List<String> list = new ArrayList<String>();\n          Stream<String> listStream = list.stream();\n  \n          Set<String> set = new HashSet<String>();\n          Stream<String> setStream = set.stream();\n  \n          //Map体系的集合间接的生成流\n          Map<String,Integer> map = new HashMap<String, Integer>();\n          Stream<String> keyStream = map.keySet().stream();\n          Stream<Integer> valueStream = map.values().stream();\n          Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();\n  \n          //数组可以通过Arrays中的静态方法stream生成流\n          String[] strArray = {\"hello\",\"world\",\"java\"};\n          Stream<String> strArrayStream = Arrays.stream(strArray);\n        \n        \t//同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流\n          Stream<String> strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\");\n          Stream<Integer> intStream = Stream.of(10, 20, 30);\n      }\n  }\n  ```\n\n### 2.3Stream流中间操作方法【应用】\n\n- 概念\n\n  中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作\n\n- 常见方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | Stream<T> filter(Predicate predicate)    | 用于对流中的数据进行过滤                             |\n  | Stream<T> limit(long maxSize)            | 返回此流中的元素组成的流，截取前指定参数个数的数据                |\n  | Stream<T> skip(long n)                   | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流               |\n  | static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                             |\n  | Stream<T> distinct()                     | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |\n\n- filter代码演示\n\n  ```java\n  public class MyStream3 {\n      public static void main(String[] args) {\n  //        Stream<T> filter(Predicate predicate)：过滤\n  //        Predicate接口中的方法\tboolean test(T t)：对给定的参数进行判断，返回一个布尔值\n\n          ArrayList<String> list = new ArrayList<>();\n          list.add(\"张三丰\");\n          list.add(\"张无忌\");\n          list.add(\"张翠山\");\n          list.add(\"王二麻子\");\n          list.add(\"张良\");\n          list.add(\"谢广坤\");\n\n          //filter方法获取流中的 每一个数据.\n          //而test方法中的s,就依次表示流中的每一个数据.\n          //我们只要在test方法中对s进行判断就可以了.\n          //如果判断的结果为true,则当前的数据留下\n          //如果判断的结果为false,则当前数据就不要.\n  //        list.stream().filter(\n  //                new Predicate<String>() {\n  //                    @Override\n  //                    public boolean test(String s) {\n  //                        boolean result = s.startsWith(\"张\");\n  //                        return result;\n  //                    }\n  //                }\n  //        ).forEach(s-> System.out.println(s));\n\n          //因为Predicate接口中只有一个抽象方法test\n          //所以我们可以使用lambda表达式来简化\n  //        list.stream().filter(\n  //                (String s)->{\n  //                    boolean result = s.startsWith(\"张\");\n  //                        return result;\n  //                }\n  //        ).forEach(s-> System.out.println(s));\n\n          list.stream().filter(s ->s.startsWith(\"张\")).forEach(s-> System.out.println(s));\n\n      }\n  }\n  ```\n\n- limit&skip代码演示\n\n  ```java\n  public class StreamDemo02 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add(\"林青霞\");\n          list.add(\"张曼玉\");\n          list.add(\"王祖贤\");\n          list.add(\"柳岩\");\n          list.add(\"张敏\");\n          list.add(\"张无忌\");\n\n          //需求1：取前3个数据在控制台输出\n          list.stream().limit(3).forEach(s-> System.out.println(s));\n          System.out.println(\"--------\");\n\n          //需求2：跳过3个元素，把剩下的元素在控制台输出\n          list.stream().skip(3).forEach(s-> System.out.println(s));\n          System.out.println(\"--------\");\n\n          //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出\n          list.stream().skip(2).limit(2).forEach(s-> System.out.println(s));\n      }\n  }\n  ```\n\n- concat&distinct代码演示\n\n  ```java\n  public class StreamDemo03 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n  \n          list.add(\"林青霞\");\n          list.add(\"张曼玉\");\n          list.add(\"王祖贤\");\n          list.add(\"柳岩\");\n          list.add(\"张敏\");\n          list.add(\"张无忌\");\n  \n          //需求1：取前4个数据组成一个流\n          Stream<String> s1 = list.stream().limit(4);\n  \n          //需求2：跳过2个数据组成一个流\n          Stream<String> s2 = list.stream().skip(2);\n  \n          //需求3：合并需求1和需求2得到的流，并把结果在控制台输出\n  //        Stream.concat(s1,s2).forEach(s-> System.out.println(s));\n  \n          //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复\n          Stream.concat(s1,s2).distinct().forEach(s-> System.out.println(s));\n      }\n  }\n  ```\n\n### 2.4Stream流终结操作方法【应用】\n\n- 概念\n\n  终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作\n\n- 常见方法\n\n  | 方法名                           | 说明           |\n  | ----------------------------- | ------------ |\n  | void forEach(Consumer action) | 对此流的每个元素执行操作 |\n  | long count()                  | 返回此流中的元素数    |\n\n- 代码演示\n\n  ```java\n  public class MyStream5 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add(\"张三丰\");\n          list.add(\"张无忌\");\n          list.add(\"张翠山\");\n          list.add(\"王二麻子\");\n          list.add(\"张良\");\n          list.add(\"谢广坤\");\n  \n          //method1(list);\n          \n  //        long count()：返回此流中的元素数\n          long count = list.stream().count();\n          System.out.println(count);\n      }\n  \n      private static void method1(ArrayList<String> list) {\n          //  void forEach(Consumer action)：对此流的每个元素执行操作\n          //  Consumer接口中的方法void accept(T t)：对给定的参数执行此操作\n          //在forEach方法的底层,会循环获取到流中的每一个数据.\n          //并循环调用accept方法,并把每一个数据传递给accept方法\n          //s就依次表示了流中的每一个数据.\n          //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了.\n          list.stream().forEach(\n                  new Consumer<String>() {\n                      @Override\n                      public void accept(String s) {\n                          System.out.println(s);\n                      }\n                  }\n          );\n        \n          System.out.println(\"====================\");\n          //lambda表达式的简化格式\n          //是因为Consumer接口中,只有一个accept方法\n          list.stream().forEach(\n                  (String s)->{\n                      System.out.println(s);\n                  }\n          );\n          System.out.println(\"====================\");\n          //lambda表达式还是可以进一步简化的.\n          list.stream().forEach(s->System.out.println(s));\n      }\n  }\n  ```\n\n### 2.5Stream流的收集操作【应用】\n\n- 概念\n\n  对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中\n\n- 常用方法\n\n  | 方法名                            | 说明        |\n  | ------------------------------ | --------- |\n  | R collect(Collector collector) | 把结果收集到集合中 |\n\n- 工具类Collectors提供了具体的收集方式\n\n  | 方法名                                                       | 说明                   |\n  | ------------------------------------------------------------ | ---------------------- |\n  | public static <T> Collector toList()                         | 把元素收集到List集合中 |\n  | public static <T> Collector toSet()                          | 把元素收集到Set集合中  |\n  | public static  Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中  |\n\n- 代码演示\n\n  ```java\n  // toList和toSet方法演示 \n  public class MyStream7 {\n      public static void main(String[] args) {\n          ArrayList<Integer> list1 = new ArrayList<>();\n          for (int i = 1; i <= 10; i++) {\n              list1.add(i);\n          }\n  \n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n  \n          //filter负责过滤数据的.\n          //collect负责收集数据.\n                  //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中.\n          //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中.\n          List<Integer> list = list1.stream().filter(number -> number % 2 == 0)\n                  .collect(Collectors.toList());\n  \n          System.out.println(list);\n  \n      Set<Integer> set = list1.stream().filter(number -> number % 2 == 0)\n              .collect(Collectors.toSet());\n      System.out.println(set);\n  }\n  }\n  /**\n  Stream流的收集方法 toMap方法演示\n  创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄\n  \"zhangsan,23\"\n  \"lisi,24\"\n  \"wangwu,25\"\n  保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值\n  */\n  public class MyStream8 {\n  \tpublic static void main(String[] args) {\n        \tArrayList<String> list = new ArrayList<>();\n          list.add(\"zhangsan,23\");\n          list.add(\"lisi,24\");\n          list.add(\"wangwu,25\");\n  \n          Map<String, Integer> map = list.stream().filter(\n                  s -> {\n                      String[] split = s.split(\",\");\n                      int age = Integer.parseInt(split[1]);\n                      return age >= 24;\n                  }\n  \n           //   collect方法只能获取到流中剩余的每一个数据.\n           //在底层不能创建容器,也不能把数据添加到容器当中\n  \n           //Collectors.toMap 创建一个map集合并将数据添加到集合当中\n  \n            // s 依次表示流中的每一个数据\n  \n            //第一个lambda表达式就是如何获取到Map中的键\n            //第二个lambda表达式就是如何获取Map中的值\n          ).collect(Collectors.toMap(\n                  s -> s.split(\",\")[0],\n                  s -> Integer.parseInt(s.split(\",\")[1]) ));\n  \n          System.out.println(map);\n  \t}\n  }\n  ```\n\n### 2.6Stream流综合练习【应用】\n\n- 案例需求\n\n  现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作\n\n  - 男演员只要名字为3个字的前三人\n  - 女演员只要姓林的，并且不要第一个\n  - 把过滤后的男演员姓名和女演员姓名合并到一起\n  - 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n\n  演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法\n\n- 代码实现\n\n  演员类\n  ```java\n  public class Actor {\n      private String name;\n  \n      public Actor(String name) {\n          this.name = name;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class StreamTest {\n      public static void main(String[] args) {\n          //创建集合\n          ArrayList<String> manList = new ArrayList<String>();\n          manList.add(\"周润发\");\n          manList.add(\"成龙\");\n          manList.add(\"刘德华\");\n          manList.add(\"吴京\");\n          manList.add(\"周星驰\");\n          manList.add(\"李连杰\");\n    \n          ArrayList<String> womanList = new ArrayList<String>();\n          womanList.add(\"林心如\");\n          womanList.add(\"张曼玉\");\n          womanList.add(\"林青霞\");\n          womanList.add(\"柳岩\");\n          womanList.add(\"林志玲\");\n          womanList.add(\"王祖贤\");\n    \n          //男演员只要名字为3个字的前三人\n          Stream<String> manStream = manList.stream().filter(s -> s.length() == 3).limit(3);\n    \n          //女演员只要姓林的，并且不要第一个\n          Stream<String> womanStream = womanList.stream().filter(s -> s.startsWith(\"林\")).skip(1);\n    \n          //把过滤后的男演员姓名和女演员姓名合并到一起\n          Stream<String> stream = Stream.concat(manStream, womanStream);\n    \n        \t// 将流中的数据封装成Actor对象之后打印\n        \tstream.forEach(name -> {\n              Actor actor = new Actor(name);\n              System.out.println(actor);\n          }); \n      }\n  }\n  ```\n\n## 3.方法引用\n\n### 3.1体验方法引用【理解】\n\n- 方法引用的出现原因\n\n  在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作\n\n  那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要\n\n  那我们又是如何使用已经存在的方案的呢？\n\n  这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案\n\n- 代码演示\n\n  ```java\n  public interface Printable {\n      void printString(String s);\n  }\n  \n  public class PrintableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用usePrintable方法\n  //        usePrintable((String s) -> {\n  //            System.out.println(s);\n  //        });\n  \t    //Lambda简化写法\n          usePrintable(s -> System.out.println(s));\n  \n          //方法引用\n          usePrintable(System.out::println);\n  \n      }\n  \n      private static void usePrintable(Printable p) {\n          p.printString(\"爱生活爱Java\");\n      }\n  }\n  \n  ```\n\n### 3.2方法引用符【理解】\n\n- 方法引用符\n\n  ::  该符号为引用运算符，而它所在的表达式被称为方法引用\n\n- 推导与省略\n\n  - 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导\n  - 如果使用方法引用，也是同样可以根据上下文进行推导\n  - 方法引用是Lambda的孪生兄弟\n\n### 3.3引用类方法【应用】\n\n​\t引用类方法，其实就是引用类的静态方法\n\n- 格式\n\n  类名::静态方法\n\n- 范例\n\n  Integer::parseInt\n\n  Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据\n\n- 练习描述\n\n  - 定义一个接口(Converter)，里面定义一个抽象方法 int convert(String s);\n  - 定义一个测试类(ConverterDemo)，在测试类中提供两个方法\n    - 一个方法是：useConverter(Converter c)\n    - 一个方法是主方法，在主方法中调用useConverter方法\n\n- 代码演示\n\n  ```java\n  public interface Converter {\n      int convert(String s);\n  }\n  \n  public class ConverterDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda写法\n          useConverter(s -> Integer.parseInt(s));\n  \n          //引用类方法\n          useConverter(Integer::parseInt);\n  \n      }\n  \n      private static void useConverter(Converter c) {\n          int number = c.convert(\"666\");\n          System.out.println(number);\n      }\n  }\n  ```\n\n- 使用说明\n\n  Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数\n\n### 3.4引用对象的实例方法【应用】\n\n​\t引用对象的实例方法，其实就引用类中的成员方法\n\n- 格式\n\n  对象::成员方法\n\n- 范例\n\n  \"HelloWorld\"::toUpperCase\n\n    String类中的方法：public String toUpperCase() 将此String所有字符转换为大写\n\n- 练习描述\n\n  - 定义一个类(PrintString)，里面定义一个方法\n\n    public void printUpper(String s)：把字符串参数变成大写的数据，然后在控制台输出\n\n  - 定义一个接口(Printer)，里面定义一个抽象方法\n\n    void printUpperCase(String s)\n\n  - 定义一个测试类(PrinterDemo)，在测试类中提供两个方法\n\n    - 一个方法是：usePrinter(Printer p)\n    - 一个方法是主方法，在主方法中调用usePrinter方法\n\n- 代码演示\n\n  ```java\n  public class PrintString {\n      //把字符串参数变成大写的数据，然后在控制台输出\n      public void printUpper(String s) {\n          String result = s.toUpperCase();\n          System.out.println(result);\n      }\n  }\n  \n  public interface Printer {\n      void printUpperCase(String s);\n  }\n  \n  public class PrinterDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda简化写法\n          usePrinter(s -> System.out.println(s.toUpperCase()));\n  \n          //引用对象的实例方法\n          PrintString ps = new PrintString();\n          usePrinter(ps::printUpper);\n  \n      }\n  \n      private static void usePrinter(Printer p) {\n          p.printUpperCase(\"HelloWorld\");\n      }\n  }\n  \n  ```\n\n- 使用说明\n\n  Lambda表达式被对象的实例方法替代的时候，它的形式参数全部传递给该方法作为参数\n\n### 3.5引用类的实例方法【应用】\n\n​\t引用类的实例方法，其实就是引用类中的成员方法\n\n- 格式\n\n  类名::成员方法\n\n- 范例\n\n  String::substring\n\n  public String substring(int beginIndex,int endIndex) \n\n  从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex\n\n- 练习描述\n\n  - 定义一个接口(MyString)，里面定义一个抽象方法：\n\n    String mySubString(String s,int x,int y);\n\n  - 定义一个测试类(MyStringDemo)，在测试类中提供两个方法\n\n    - 一个方法是：useMyString(MyString my)\n    - 一个方法是主方法，在主方法中调用useMyString方法\n\n- 代码演示\n\n  ```java\n  public interface MyString {\n      String mySubString(String s,int x,int y);\n  }\n  \n  public class MyStringDemo {\n      public static void main(String[] args) {\n  \t\t//Lambda简化写法\n          useMyString((s,x,y) -> s.substring(x,y));\n  \n          //引用类的实例方法\n          useMyString(String::substring);\n  \n      }\n  \n      private static void useMyString(MyString my) {\n          String s = my.mySubString(\"HelloWorld\", 2, 5);\n          System.out.println(s);\n      }\n  }\n  ```\n\n- 使用说明\n\n  ​    Lambda表达式被类的实例方法替代的时候\n  ​    第一个参数作为调用者\n  ​    后面的参数全部传递给该方法作为参数\n\n### 3.6引用构造器【应用】\n\n​\t引用构造器，其实就是引用构造方法\n\n- l格式\n\n  类名::new\n\n- 范例\n\n  Student::new\n\n- 练习描述\n\n  - 定义一个类(Student)，里面有两个成员变量(name,age)\n\n    并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法\n\n  - 定义一个接口(StudentBuilder)，里面定义一个抽象方法\n\n    Student build(String name,int age);\n\n  - 定义一个测试类(StudentDemo)，在测试类中提供两个方法\n\n    - 一个方法是：useStudentBuilder(StudentBuilder s)\n    - 一个方法是主方法，在主方法中调用useStudentBuilder方法\n\n- 代码演示\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  }\n  \n  public interface StudentBuilder {\n      Student build(String name,int age);\n  }\n  \n  public class StudentDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda简化写法\n          useStudentBuilder((name,age) -> new Student(name,age));\n  \n          //引用构造器\n          useStudentBuilder(Student::new);\n  \n      }\n  \n      private static void useStudentBuilder(StudentBuilder sb) {\n          Student s = sb.build(\"林青霞\", 30);\n          System.out.println(s.getName() + \",\" + s.getAge());\n      }\n  }\n  ```\n\n- 使用说明\n\n  Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"Map集合","url":"/2023/03/04/集合03/","content":"## 1.Map集合\n\n### 1.1Map集合概述和特点【理解】\n\n- Map集合概述\n\n  ```java\n  interface Map<K,V>  K：键的类型；V：值的类型\n  ```\n\n- Map集合的特点\n\n  - 双列集合,一个键对应一个值\n  - 键不可以重复,值可以重复\n\n- Map集合的基本使用\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n  \n          //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n          map.put(\"itheima001\",\"林青霞\");\n          map.put(\"itheima002\",\"张曼玉\");\n          map.put(\"itheima003\",\"王祖贤\");\n          map.put(\"itheima003\",\"柳岩\");\n  \n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.2Map集合的基本功能【应用】\n\n- 方法介绍\n\n  | 方法名                                 | 说明                 |\n  | ----------------------------------- | ------------------ |\n  | V   put(K key,V   value)            | 添加元素               |\n  | V   remove(Object key)              | 根据键删除键值对元素         |\n  | void   clear()                      | 移除所有的键值对元素         |\n  | boolean containsKey(Object key)     | 判断集合是否包含指定的键       |\n  | boolean containsValue(Object value) | 判断集合是否包含指定的值       |\n  | boolean isEmpty()                   | 判断集合是否为空           |\n  | int size()                          | 集合的长度，也就是集合中键值对的个数 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n  \n          //V put(K key,V value)：添加元素\n          map.put(\"张无忌\",\"赵敏\");\n          map.put(\"郭靖\",\"黄蓉\");\n          map.put(\"杨过\",\"小龙女\");\n  \n          //V remove(Object key)：根据键删除键值对元素\n  //        System.out.println(map.remove(\"郭靖\"));\n  //        System.out.println(map.remove(\"郭襄\"));\n  \n          //void clear()：移除所有的键值对元素\n  //        map.clear();\n  \n          //boolean containsKey(Object key)：判断集合是否包含指定的键\n  //        System.out.println(map.containsKey(\"郭靖\"));\n  //        System.out.println(map.containsKey(\"郭襄\"));\n  \n          //boolean isEmpty()：判断集合是否为空\n  //        System.out.println(map.isEmpty());\n  \n          //int size()：集合的长度，也就是集合中键值对的个数\n          System.out.println(map.size());\n  \n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.3Map集合的获取功能【应用】\n\n- 方法介绍\n\n  | 方法名                              | 说明           |\n  | -------------------------------- | ------------ |\n  | V   get(Object key)              | 根据键获取值       |\n  | Set<K>   keySet()                | 获取所有键的集合     |\n  | Collection<V>   values()         | 获取所有值的集合     |\n  | Set<Map.Entry<K,V>>   entrySet() | 获取所有键值对对象的集合 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo03 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n  \n          //添加元素\n          map.put(\"张无忌\", \"赵敏\");\n          map.put(\"郭靖\", \"黄蓉\");\n          map.put(\"杨过\", \"小龙女\");\n  \n          //V get(Object key):根据键获取值\n  //        System.out.println(map.get(\"张无忌\"));\n  //        System.out.println(map.get(\"张三丰\"));\n  \n          //Set<K> keySet():获取所有键的集合\n  //        Set<String> keySet = map.keySet();\n  //        for(String key : keySet) {\n  //            System.out.println(key);\n  //        }\n  \n          //Collection<V> values():获取所有值的集合\n          Collection<String> values = map.values();\n          for(String value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n### 1.4Map集合的遍历(方式1)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 把所有的丈夫给集中起来\n    - 遍历丈夫的集合，获取到每一个丈夫\n    - 根据丈夫去找对应的妻子\n\n- 步骤分析\n\n  - 获取所有键的集合。用keySet()方法实现\n  - 遍历键的集合，获取到每一个键。用增强for实现  \n  - 根据键去找值。用get(Object key)方法实现\n\n- 代码实现\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n  \n          //添加元素\n          map.put(\"张无忌\", \"赵敏\");\n          map.put(\"郭靖\", \"黄蓉\");\n          map.put(\"杨过\", \"小龙女\");\n  \n          //获取所有键的集合。用keySet()方法实现\n          Set<String> keySet = map.keySet();\n          //遍历键的集合，获取到每一个键。用增强for实现\n          for (String key : keySet) {\n              //根据键去找值。用get(Object key)方法实现\n              String value = map.get(key);\n              System.out.println(key + \",\" + value);\n          }\n      }\n  }\n  ```\n\n### 1.5Map集合的遍历(方式2)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 获取所有结婚证的集合\n    - 遍历结婚证的集合，得到每一个结婚证\n    - 根据结婚证获取丈夫和妻子\n\n- 步骤分析\n\n  - 获取所有键值对对象的集合\n    - Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合\n  - 遍历键值对对象的集合，得到每一个键值对对象\n    - 用增强for实现，得到每一个Map.Entry\n  - 根据键值对对象获取键和值\n    - 用getKey()得到键\n    - 用getValue()得到值\n\n- 代码实现\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n  \n          //添加元素\n          map.put(\"张无忌\", \"赵敏\");\n          map.put(\"郭靖\", \"黄蓉\");\n          map.put(\"杨过\", \"小龙女\");\n  \n          //获取所有键值对对象的集合\n          Set<Map.Entry<String, String>> entrySet = map.entrySet();\n          //遍历键值对对象的集合，得到每一个键值对对象\n          for (Map.Entry<String, String> me : entrySet) {\n              //根据键值对对象获取键和值\n              String key = me.getKey();\n              String value = me.getValue();\n              System.out.println(key + \",\" + value);\n          }\n      }\n  }\n  ```\n\n## 2.HashMap集合\n\n### 2.1HashMap集合概述和特点【理解】\n\n+ HashMap底层是哈希表结构的\n+ 依赖hashCode方法和equals方法保证键的唯一\n+ 如果键要存储的是自定义对象，需要重写hashCode和equals方法\n\n### 2.2HashMap集合应用案例【应用】\n\n- 案例需求\n\n  - 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。\n  - 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  \n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n  \n          Student student = (Student) o;\n  \n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n  \n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashMapDemo {\n      public static void main(String[] args) {\n          //创建HashMap集合对象\n          HashMap<Student, String> hm = new HashMap<Student, String>();\n  \n          //创建学生对象\n          Student s1 = new Student(\"林青霞\", 30);\n          Student s2 = new Student(\"张曼玉\", 35);\n          Student s3 = new Student(\"王祖贤\", 33);\n          Student s4 = new Student(\"王祖贤\", 33);\n  \n          //把学生添加到集合\n          hm.put(s1, \"西安\");\n          hm.put(s2, \"武汉\");\n          hm.put(s3, \"郑州\");\n          hm.put(s4, \"北京\");\n  \n          //遍历集合\n          Set<Student> keySet = hm.keySet();\n          for (Student key : keySet) {\n              String value = hm.get(key);\n              System.out.println(key.getName() + \",\" + key.getAge() + \",\" + value);\n          }\n      }\n  }\n  ```\n\n## 3.TreeMap集合\n\n### 3.1TreeMap集合概述和特点【理解】\n\n+ TreeMap底层是红黑树结构\n+ 依赖自然排序或者比较器排序,对键进行排序\n+ 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则\n\n### 3.2TreeMap集合应用案例【应用】\n\n+ 案例需求\n\n  + 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历\n  + 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  \n      @Override\n      public String toString() {\n          return \"Student{\" +\n                  \"name='\" + name + '\\'' +\n                  \", age=\" + age +\n                  '}';\n      }\n  \n      @Override\n      public int compareTo(Student o) {\n          //按照年龄进行排序\n          int result = o.getAge() - this.getAge();\n          //次要条件，按照姓名排序。\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) {\n        \t// 创建TreeMap集合对象\n          TreeMap<Student,String> tm = new TreeMap<>();\n        \n  \t\t// 创建学生对象\n          Student s1 = new Student(\"xiaohei\",23);\n          Student s2 = new Student(\"dapang\",22);\n          Student s3 = new Student(\"xiaomei\",22);\n        \n  \t\t// 将学生对象添加到TreeMap集合中\n          tm.put(s1,\"江苏\");\n          tm.put(s2,\"北京\");\n          tm.put(s3,\"天津\");\n        \n  \t\t// 遍历TreeMap集合,打印每个学生的信息\n          tm.forEach(\n                  (Student key, String value)->{\n                      System.out.println(key + \"---\" + value);\n                  }\n          );\n      }\n  }\n  ```\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"可变参数","url":"/2023/03/03/可变参数&综合练习/","content":"# 1. 可变参数\n\n在**JDK1.5**之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化.\n\n**格式：**\n\n```\n修饰符 返回值类型 方法名(参数类型... 形参名){  }\n```\n\n**底层：**\n\n​\t其实就是一个数组\n\n**好处：**\n\n​\t在传递数据的时候，省的我们自己创建数组并添加元素了，JDK底层帮我们自动创建数组并添加元素了\n\n**代码演示:**\n\n```java\n  public class ChangeArgs {\n    public static void main(String[] args) {\n        int sum = getSum(6, 7, 2, 12, 2121);\n        System.out.println(sum);\n    }\n    \n    public static int getSum(int... arr) {\n   \t\tint sum = 0;\n   \t     for (int a : arr) {\n         sum += a;\n        }\n   \t\t return sum;\n    }\n}\n```\n\n**注意：**\n\n​\t1.一个方法只能有一个可变参数\n\n​\t2.如果方法中有多个参数，可变参数要放到最后。\n\n**应用场景: Collections**\n\n​\t在Collections中也提供了添加一些元素方法：\n\n​\t`public static <T> boolean addAll(Collection<T> c, T... elements)  `:往集合中添加一些元素。\n\n**代码演示:**\n\n```java\npublic class CollectionsDemo {\n\tpublic static void main(String[] args) {\n      ArrayList<Integer> list = new ArrayList<Integer>();\n      //原来写法\n      //list.add(12);\n      //list.add(14);\n      //list.add(15);\n      //list.add(1000);\n      //采用工具类 完成 往集合中添加元素  \n      Collections.addAll(list, 5, 222, 1，2);\n      System.out.println(list);\n}\n```\n\n# 2. Collections类\n\n## 2.1 Collections常用功能\n\n- `java.utils.Collections`是集合工具类，用来对集合进行操作。\n\n  常用方法如下：\n\n- `public static void shuffle(List<?> list) `:打乱集合顺序。\n- `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。\n- `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。\n\n代码演示：\n\n```java\npublic class CollectionsDemo {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<Integer>();\n   \n        list.add(100);\n        list.add(300);\n        list.add(200);\n        list.add(50);\n        //排序方法 \n        Collections.sort(list);\n        System.out.println(list);\n    }\n}\n结果：\n[50,100, 200, 300]\n```\n\n我们的集合按照默认的自然顺序进行了排列，如果想要指定顺序那该怎么办呢？\n\n## 2.2 Comparator比较器\n\n创建一个学生类，存储到ArrayList集合中完成指定排序操作。\n\nStudent 类\n\n```java\npublic class Student{\n    private String name;\n    private int age;\n\t//构造方法\n    //get/set\n \t//toString\n}\n```\n\n测试类：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        // 创建四个学生对象 存储到集合中\n        ArrayList<Student> list = new ArrayList<Student>();\n\n        list.add(new Student(\"rose\",18));\n        list.add(new Student(\"jack\",16));\n        list.add(new Student(\"abc\",20));\n\t\tCollections.sort(list, new Comparator<Student>() {\n  \t\t  @Override\n    \t\tpublic int compare(Student o1, Student o2) {\n        \treturn o1.getAge()-o2.getAge();//以学生的年龄升序\n   \t\t }\n\t\t});\n\n\n        for (Student student : list) {\n            System.out.println(student);\n        }\n    }\n}\nStudent{name='jack', age=16}\nStudent{name='rose', age=18}\nStudent{name='abc', age=20}\n```\n\n# 3. 综合练习\n\n### 练习1：随机点名器\n\n需求：班级里有N个学生，实现随机点名器\n\n代码实现：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        /* 班级里有N个学生，学生属性:姓名，年龄，性别。\n        实现随机点名器。*/\n\n\n        //1.定义集合\n        ArrayList<String> list = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list,\"范闲\",\"范建\",\"范统\",\"杜子腾\",\"杜琦燕\",\"宋合泛\",\"侯笼藤\",\"朱益群\",\"朱穆朗玛峰\",\"袁明媛\");\n        //3.随机点名\n        /* Random r = new Random();\n        int index = r.nextInt(list.size());\n        String name = list.get(index);\n        System.out.println(name);*/\n\n        //打乱\n        Collections.shuffle(list);\n\n        String name = list.get(0);\n        System.out.println(name);\n\n\n    }\n}\n```\n\n### 练习2：带概率的随机\n\n需求：\n\n​\t班级里有N个学生\n\n​\t要求在随机的时候，70%的概率随机到男生，30%的概率随机到女生\n\n代码实现：\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        /* 班级里有N个学生\n        要求：\n        70%的概率随机到男生\n        30%的概率随机到女生\n\n        \"范闲\",\"范建\",\"范统\",\"杜子腾\",\"宋合泛\",\"侯笼藤\",\"朱益群\",\"朱穆朗玛峰\",\n        \"杜琦燕\",\"袁明媛\",\"李猜\",\"田蜜蜜\",\n        */\n        //1.创建集合\n        ArrayList<Integer> list = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list,1,1,1,1,1,1,1);\n        Collections.addAll(list,0,0,0);\n        //3.打乱集合中的数据\n        Collections.shuffle(list);\n        //4.从list集合中随机抽取0或者1\n        Random r = new Random();\n        int index = r.nextInt(list.size());\n        int number = list.get(index);\n        System.out.println(number);\n        //5.创建两个集合分别存储男生和女生的名字\n        ArrayList<String> boyList = new ArrayList<>();\n        ArrayList<String> girlList = new ArrayList<>();\n\n        Collections.addAll(boyList,\"范闲\",\"范建\",\"范统\",\"杜子腾\",\"宋合泛\",\"侯笼藤\",\"朱益群\",\"朱穆朗玛峰\");\n        Collections.addAll(girlList,\"杜琦燕\",\"袁明媛\",\"李猜\",\"田蜜蜜\");\n\n        //6.判断此时是从boyList里面抽取还是从girlList里面抽取\n        if(number == 1){\n            //boyList\n            int boyIndex = r.nextInt(boyList.size());\n            String name = boyList.get(boyIndex);\n            System.out.println(name);\n        }else{\n            //girlList\n            int girlIndex = r.nextInt(girlList.size());\n            String name = girlList.get(girlIndex);\n            System.out.println(name);\n        }\n\n\n    }\n}\n```\n\n### 练习3：随机不重复\n\n需求：\n\n​\t班级里有N个学生，被点到的学生不会再被点到。但是如果班级中所有的学生都点完了， 需要重新开启第二轮点名。\n\n代码实现：\n\n```java\npublic class Test3 {\n    public static void main(String[] args) {\n       /* 班级里有5个学生\n        要求：\n        被点到的学生不会再被点到。\n        但是如果班级中所有的学生都点完了，需要重新开启第二轮点名。*/\n\n\n        //1.定义集合\n        ArrayList<String> list1 = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list1, \"范闲\", \"范建\", \"范统\", \"杜子腾\", \"杜琦燕\", \"宋合泛\", \"侯笼藤\", \"朱益群\", \"朱穆朗玛峰\", \"袁明媛\");\n        //创建一个临时的集合，用来存已经被点到学生的名字\n        ArrayList<String> list2 = new ArrayList<>();\n        //外循环：表示轮数\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(\"=========第\" + i + \"轮点名开始了======================\");\n            //3.获取集合的长度\n            int count = list1.size();\n            //4.随机点名\n            Random r = new Random();\n            //内循环：每一轮中随机循环抽取的过程\n            for (int j = 0; j < count; j++) {\n                int index = r.nextInt(list1.size());\n                String name = list1.remove(index);\n                list2.add(name);\n                System.out.println(name);\n            }\n            //此时表示一轮点名结束\n            //list1 空了 list2 10个学生的名字\n            list1.addAll(list2);\n            list2.clear();\n\n        }\n    }\n}\n```\n\n## 练习4：集合的嵌套\n\n需求：\n\n​\t定义一个Map集合，键用表示省份名称province，值表示市city，但是市会有多个。\n\n添加完毕后，遍历结果格式如下：\n\n​\t江苏省 = 南京市，扬州市，苏州市，无锡市，常州市\n\n  \t湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市\n  \t\n  \t河北省 = 石家庄市，唐山市，邢台市，保定市，张家口市\n\n代码实现：\n\n```java\npublic class Test4 {\n    public static void main(String[] args) {\n        /* 需求\n        定义一个Map集合，键用表示省份名称province，值表示市city，但是市会有多个。\n        添加完毕后，遍历结果格式如下：\n                江苏省 = 南京市，扬州市，苏州市，无锡市，常州市\n                湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市\n                河北省 = 石家庄市，唐山市，邢台市，保定市，张家口市*/\n\n\n        //1.创建Map集合\n        HashMap<String, ArrayList<String>> hm = new HashMap<>();\n\n        //2.创建单列集合存储市\n        ArrayList<String> city1 = new ArrayList<>();\n        city1.add(\"南京市\");\n        city1.add(\"扬州市\");\n        city1.add(\"苏州市\");\n        city1.add(\"无锡市\");\n        city1.add(\"常州市\");\n\n        ArrayList<String> city2 = new ArrayList<>();\n        city2.add(\"武汉市\");\n        city2.add(\"孝感市\");\n        city2.add(\"十堰市\");\n        city2.add(\"宜昌市\");\n        city2.add(\"鄂州市\");\n\n        ArrayList<String> city3 = new ArrayList<>();\n        city3.add(\"石家庄市\");\n        city3.add(\"唐山市\");\n        city3.add(\"邢台市\");\n        city3.add(\"保定市\");\n        city3.add(\"张家口市\");\n\n        //3.把省份和多个市添加到map集合\n        hm.put(\"江苏省\",city1);\n        hm.put(\"湖北省\",city2);\n        hm.put(\"河北省\",city3);\n\n        Set<Map.Entry<String, ArrayList<String>>> entries = hm.entrySet();\n        for (Map.Entry<String, ArrayList<String>> entry : entries) {\n            //entry依次表示每一个键值对对象\n            String key = entry.getKey();\n            ArrayList<String> value = entry.getValue();\n            StringJoiner sj = new StringJoiner(\", \",\"\",\"\");\n            for (String city : value) {\n                sj.add(city);\n            }\n            System.out.println(key + \" = \" + sj);\n\n        }\n    }\n}\n```\n\n# 4. 斗地主发牌\n\n## 4.1 案例介绍\n\n按照斗地主的规则，完成洗牌发牌的动作。\n具体规则：\n\n使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。\n\n## 4.2 案例分析\n\n- 准备牌：\n\n  牌可以设计为一个ArrayList<String>,每个字符串为一张牌。\n  每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。\n  牌由Collections类的shuffle方法进行随机排序。\n\n- 发牌\n\n  将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。\n\n- 看牌\n\n  直接打印每个集合。\n\n## 4.3 代码实现\n\n```java\npublic class App {\n    public static void main(String[] args) {\n      /*\n        完成控制台版的三步：\n          准备牌\n          洗牌\n          发牌\n       */\n        //从程序的主入口开启斗地主游戏\n        new PokerGame();\n    }\n}\n\npublic class PokerGame {\n    //牌盒\n    //♥3 ♣3\n    static ArrayList<String> list = new ArrayList<>();\n\n    //静态代码块\n    //特点：随着类的加载而在加载的，而且只执行一次。\n    static {\n        //准备牌\n        // \"♦\", \"♣\", \"♥\", \"♠\"\n        // \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\", \"2\"\n        String[] color = {\"♦\", \"♣\", \"♥\", \"♠\" };\n        String[] number = {\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\", \"2\"};\n\n        for (String c : color) {\n            //c依次表示每一种花色\n            for (String n : number) {\n                //n 依次表示每一个数字\n                list.add(c + n);\n            }\n        }\n        list.add(\"小王\");\n        list.add(\"大王\");\n    }\n\n    public PokerGame(){\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        ArrayList<String> lord = new ArrayList<>();\n        ArrayList<String> player1 = new ArrayList<>();\n        ArrayList<String> player2 = new ArrayList<>();\n        ArrayList<String> player3 = new ArrayList<>();\n\n        //遍历牌盒得到每一张牌\n        for (int i = 0; i < list.size(); i++) {\n            //i：索引\n            String poker = list.get(i);\n            if(i <= 2){\n                lord.add(poker);\n                continue;\n            }\n\n            //给三个玩家轮流发牌\n            if(i % 3 == 0){\n                player1.add(poker);\n            }else if(i % 3 == 1){\n                player2.add(poker);\n            }else{\n                player3.add(poker);\n            }\n        }\n        //看牌\n        lookPoker(\"底牌\",lord);\n        lookPoker(\"钢脑壳\",player1);\n        lookPoker(\"大帅比\",player2);\n        lookPoker(\"蛋筒\",player3);\n\n    }\n\n    /*\n    * 参数一：玩家的名字\n    * 参数二：每位玩家的牌\n    * */\n    public void lookPoker(String name, ArrayList<String> list){\n        System.out.print(name + \": \");\n        for (String poker : list) {\n            System.out.print(poker + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n## 4.4 排序（第一种排序方式）\n\n```java\npublic class App {\n    public static void main(String[] args) {\n      /*\n        完成控制台版的四步：\n          准备牌\n          洗牌\n          发牌\n          排序\n\n       */\n\n\t\t//从程序的主入口开启斗地主游戏\n        new PokerGame();\n    }\n}\n\n\npublic class PokerGame {\n    //牌盒 Map\n    //此时我们只要把牌跟序号产生对应关系就可以了，不需要按照序号进行排序，所以只要HashMap就可以了\n    static HashMap<Integer, String> hm = new HashMap<>();\n    static ArrayList<Integer> list = new ArrayList<>();\n\n    static {\n        String[] color = {\"♦\", \"♣\", \"♥\", \"♠\"};\n        String[] number = {\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\", \"2\"};\n\n        //序号\n        int serialNumber = 1;\n        //细节\n        for (String n : number) {\n            //依次表示每一个数字\n            for (String c : color) {\n                //依次表示每一个花色\n                hm.put(serialNumber, c + n);\n                list.add(serialNumber);\n                serialNumber++;\n            }\n        }\n\n        hm.put(serialNumber, \"小王\");\n        list.add(serialNumber);\n        serialNumber++;\n        hm.put(serialNumber, \"大王\");\n        list.add(serialNumber);\n\n    }\n\n    public PokerGame() {\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        TreeSet<Integer> lord = new TreeSet<>();\n        TreeSet<Integer> player1 = new TreeSet<>();\n        TreeSet<Integer> player2 = new TreeSet<>();\n        TreeSet<Integer> player3 = new TreeSet<>();\n\n        for (int i = 0; i < list.size(); i++) {\n            //i :依次表示集合中的每一个索引\n            //list.get(i)元素：牌的序号\n            int serialNumber = list.get(i);\n\n            if(i <= 2){\n                lord.add(serialNumber);\n                continue;\n            }\n\n            if(i % 3 == 0){\n                player1.add(serialNumber);\n            }else if(i % 3 == 1){\n                player2.add(serialNumber);\n            }else{\n                player3.add(serialNumber);\n            }\n        }\n\n\n        //看牌\n        lookPoker(\"底牌\",lord);\n        lookPoker(\"钢脑壳\",player1);\n        lookPoker(\"大帅比\",player2);\n        lookPoker(\"蛋筒\",player3);\n\n    }\n\n    /*\n    * 参数一：玩家的名字\n    * 参数二：牌的序号\n    * */\n    public void lookPoker(String name, TreeSet<Integer> ts){\n        System.out.print(name + \": \");\n        //遍历TreeSet集合得到每一个序号，再拿着序号到Map集合中去找真正的牌\n        for (int serialNumber : ts) {\n            String poker = hm.get(serialNumber);\n            System.out.print(poker + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n## 4.5 排序（第二种排序方式）\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        new PokerGame();\n    }\n}\n\n\npublic class PokerGame {\n    //牌盒\n    static ArrayList<String> list = new ArrayList<>();\n\n    //创建一个集合，用来添加牌的价值\n    static HashMap<String, Integer> hm = new HashMap<>();\n\n    static {\n        //准备牌\n        String[] color = {\"♦\", \"♣\", \"♥\", \"♠\"};\n        String[] number = {\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\", \"2\"};\n\n        for (String c : color) {\n            for (String n : number) {\n                list.add(c + n);\n            }\n        }\n        list.add(\" 小王\");\n        list.add(\" 大王\");\n\n\n        //指定牌的价值\n        //牌上的数字到Map集合中判断是否存在\n        //存在，获取价值\n        //不存在，本身的数字就是价值\n        hm.put(\"J\", 11);\n        hm.put(\"Q\", 12);\n        hm.put(\"K\", 13);\n        hm.put(\"A\", 14);\n        hm.put(\"2\", 15);\n        hm.put(\"小王\", 50);\n        hm.put(\"大王\", 100);\n\n\n    }\n\n    public PokerGame() {\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        ArrayList<String> lord = new ArrayList<>();\n        ArrayList<String> player1 = new ArrayList<>();\n        ArrayList<String> player2 = new ArrayList<>();\n        ArrayList<String> player3 = new ArrayList<>();\n\n        for (int i = 0; i < list.size(); i++) {\n            String poker = list.get(i);\n            //发底牌\n            if (i <= 2) {\n                lord.add(poker);\n                continue;\n            }\n\n            //给三个玩家轮流发牌\n            if (i % 3 == 0) {\n                player1.add(poker);\n            } else if (i % 3 == 1) {\n                player2.add(poker);\n            } else {\n                player3.add(poker);\n            }\n        }\n\n\n        //排序\n        order(lord);\n        order(player1);\n        order(player2);\n        order(player3);\n\n\n        //看牌\n        lookPoker(\"底牌\",lord);\n        lookPoker(\"钢脑壳\",player1);\n        lookPoker(\"大帅比\",player2);\n        lookPoker(\"蛋筒\",player3);\n    }\n\n\n    /*\n     * 参数一：玩家的名字\n     * 参数二：每位玩家的牌\n     * */\n    public void lookPoker(String name, ArrayList<String> list){\n        System.out.print(name + \": \");\n        for (String poker : list) {\n            System.out.print(poker + \" \");\n        }\n        System.out.println();\n\n    }\n\n\n    //利用牌的价值进行排序\n    //参数：集合\n    //♥5 ♥3 ♥6 ♥7 ♥9\n    public void order(ArrayList<String> list){\n        Collections.sort(list, new Comparator<String>() {\n            //Array.sort （插入排序 + 二分查找）\n            @Override\n            public int compare(String o1, String o2) {\n                //o1：表示当前要插入到有序序列中的牌\n                //o2：表示已经在有序序列中存在的牌\n\n                //负数：o1小 插入到前面\n                //正数：o1大 插入到后面\n                //0：o1的数字跟o2的数字是一样的，需要按照花色再次排序\n\n                //1.计算o1的花色和价值   大王\n                String color1 = o1.substring(0, 1);\n                int value1 = getValue(o1);\n\n                //2.计算o2的花色和价值\n                String color2 = o2.substring(0, 1);\n                int value2 = getValue(o2);\n\n                //3.比较o1和o2的价值    ♥3  ♠3\n                int i = value1 - value2;\n                return i == 0 ? color1.compareTo(color2) : i;\n\n            }\n        });\n    }\n\n    //计算牌的价值\n    //参数：牌\n    //返回值：价值\n    public int getValue(String poker){//♥3\n        //获取牌上的数字\n        String number = poker.substring(1);//把这里截取出来的结果，让这个结果再Map集合中存在 “ 大王”\n        //拿着数字到map集合中判断是否存在\n        if(hm.containsKey(number)){\n            //存在，获取价值\n            return hm.get(number);\n        }else{\n            //不存在，类型转换\n            return Integer.parseInt(number);\n        }\n    }\n}\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"HashMap底层源码分析","url":"/2023/02/22/HashMap底层源码分析/","content":"# HashMap底层源码分析","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"TreeMap","url":"/2023/02/21/TreeMap/","content":"# TreeMap\n\n- TreeMap跟TreeSet底层原理一样，都是红黑树结构的。\n- 由键决定特性：不重复、无索引、可排序\n- 可排序：对键进行排序。\n- 注意：默认按照键的从小到大进行排序，也可以自己规定键的排序规则\n\n## 代码书写两种排序规则\n\n- 实现Comparable接口，指定比较规则。\n\n- 创建集合时传递Comparator比较器对象，指定比较规侧。\n\n  > 当默认的比较规则不满足要求时，用compareator比较器对象\n\n  1. ```java\n     package day_25;\n     \n     import java.util.Comparator;\n     \n     public class TreeMap_Demo1 {\n         public static void main(String[] args) {\n             /*\n             TreeMap集合：基本应用\n             需求1：\n             键：整数表示id\n             值：字符串表示商品名称\n             要求：按照id的升序排列、按照id的降序排列\n              */\n     \n             //Integer Double默认情况下都是按照升序排列的\n             //String按照字母再ASCII码表中对应的数字升序进行排列\n             //abcdefg ..\n             java.util.TreeMap<Integer,String> tm =new java.util.TreeMap<>(new Comparator<Integer>() {\n                 @Override\n                 public int compare(Integer o1, Integer o2) {\n     \n                     //o1:当前要添加的元素\n                     //o2:表示已经在红黑树中存在的元素\n                     return o2 - o1;\n                 }\n             });\n             tm.put(4,\"ff\");\n             tm.put(3,\"ff\");\n             tm.put(1,\"ff\");\n             tm.put(2,\"ff\");\n             tm.put(5,\"ff\");\n             System.out.println(tm);\n     \n         }\n     \n     }\n     \n     ```\n\n  2. ```java\n     package day_25;\n     \n     public class Student2 implements Comparable<Student2> {\n         private String name;\n         private int age;\n     \n     \n         public Student2() {\n         }\n     \n         public Student2(String name, int age) {\n             this.name = name;\n             this.age = age;\n         }\n     \n         /**\n          * 获取\n          *\n          * @return name\n          */\n         public String getName() {\n             return name;\n         }\n     \n         /**\n          * 设置\n          *\n          * @param name\n          */\n         public void setName(String name) {\n             this.name = name;\n         }\n     \n         /**\n          * 获取\n          *\n          * @return age\n          */\n         public int getAge() {\n             return age;\n         }\n     \n         /**\n          * 设置\n          *\n          * @param age\n          */\n         public void setAge(int age) {\n             this.age = age;\n         }\n     \n         public String toString() {\n             return \"Student2{name = \" + name + \", age = \" + age + \"}\";\n         }\n     \n         @Override\n         public int compareTo(Student2 o) {\n             //this:表示当前要添加的元素\n             //o:表示已经在红黑树中存在的元素\n             int i = this.getAge() - o.getAge();\n             i = i == 0 ? this.getName().compareTo(o.getName()) : i;\n             return i;\n     \n         }\n     }\n     \n     \n     \n     package day_25;\n     \n     import java.util.TreeMap;\n     \n     public class TreeMap_Demo2 {\n         public static void main(String[] args) {\n             /*\n             TreeMap集合：基本应用\n             需求2：\n             键：学生对象\n             值：籍贯\n             要求按照学生年龄的升序排列，年龄一样按照姓名的字母排列，同姓名年龄视为同一个人。\n              */\n             TreeMap<Student2,String> tm = new TreeMap<>();\n             Student2 s1 = new Student2(\"zhabngsan\",25);\n             Student2 s2 = new Student2(\"zabngsan\",26);\n             Student2 s3 = new Student2(\"zabngsan\",26);\n             Student2 s4 = new Student2(\"kk\",23);\n             tm.put(s1,\"江苏\");\n             tm.put(s2,\"天津\");\n             tm.put(s3,\"伤害\");\n             tm.put(s4,\"哈尔滨\");\n             System.out.println(tm);\n     \n     \n         }\n     \n     }\n     \n     ```\n\n  3. ```java\n     package day_25;\n     \n     import java.util.TreeMap;\n     \n     public class TreeMap_Demo3 {\n         public static void main(String[] args) {\n             /*需求：\n                 字符串“aababcabcdabcde”\n                 请统计字符串中每一个字符出现的次数，并按照以下格式输出\n                 输出结果：\n                 a(5)b(4)c(3)d(2)e(1)\n                 新的统计思想：利用map集合进行统计\n                 如果题日中没有要求对结果进行排序，默认使用HashMap\n                 如果题目中要求对结果进行排序，请使用TreeMap\n                 键：表示要统计的内容\n                 值：表示次数\n     */\n             String s = \"aababcabcdabcde\";\n             TreeMap<Character, Integer> treeMap = new TreeMap<>();\n             for (int i = 0; i < s.length(); i++) {\n                 char c = s.charAt(i);\n                 if (treeMap.containsKey(c)) {\n                     int count = treeMap.get(c);\n                     count++;\n                     treeMap.put(c, count);\n     \n                 } else {\n                     treeMap.put(c, 1);\n                 }\n             }\n             StringBuilder sb = new StringBuilder();\n             treeMap.forEach((key, value) -> sb.append(key).append(\"(\").append(value).append(\")\"));\n             System.out.println(sb);\n     \n         }\n     \n     }\n     \n     ```\n\n  4. \n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"HashMap","url":"/2023/02/21/HashMap/","content":"\n# HashMap\n## HashMap特点\n\n1. HashMap是Map里面的一个实现类。\n2. 没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。\n3. 特点都是由键决定的：无序、不重复、无索引\n4. HashMap跟HashSet底层原理是一模一样的，都是哈希表结构\n\n## 总结\n\n1. HashMap底层是哈希表结构的\n2. 依赖hashCode方法和equals方法保证<font color = red>键的唯一</font>\n3. 如果键存储的是自定义对象，需要重写hashCode和equals方法\n4. 如果值存储自定义对象，不需要重写nashCode和equals方法\n\n## HashMap练习\n\n```java\npackage day_25;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\npublic class HashMap_Demo1 {\n    /*\n    需求：创建一个HashMap集合，键是学生对象(Student),值是籍贯(String)。\n    存储三个键值对元素，并遍历\n    要求：同姓名，同年龄认为是同一个学生\n\n    核心点：\n    HashMap的键位置如果存储的是自定义对象，需要重写HashCode和equals方法。\n     */\n    public static void main(String[] args) {\n        Student s1 = new Student(\"张三\",18);\n        Student s2 = new Student(\"李四\",19);\n        Student s3 = new Student(\"王五\",20);\n        Student s4 = new Student(\"王五\",20);\n        Map<Student,String> map= new HashMap<>();\n        map.put(s1,\"huNan\");\n        map.put(s2,\"HerBin\");\n        map.put(s3,\"shanXi\");\n        map.put(s4,\"fuJin\");\n//        Set<Student> students = map.keySet();\n//        students.forEach(new Consumer<Student>() {\n//            @Override\n//            public void accept(Student student) {\n//                System.out.println(map.get(student));\n//            }\n//        });\n\n        map.forEach(new BiConsumer<Student, String>() {\n            @Override\n            public void accept(Student student, String s) {\n                System.out.println(student+\" \"+s);\n            }\n        });\n    }\n\n}\n\n```\n\n2. ```java\n   package day_25;\n   \n   import java.util.*;\n   \n   public class HashMap_demo2 {\n       public static void main(String[] args) {\n           /*\n           某个班级8日名学生，现在需要组成秋游活动，\n           班长提供了四个景点依次是(A、B、C、D),\n           每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。\n            */\n           String[] arr = {\"A\", \"B\", \"C\", \"D\"};\n           ArrayList<String> list = new ArrayList<>();\n           Random r = new Random();\n           for (int i = 0; i < 80; i++) {\n               int index = r.nextInt(arr.length);\n               list.add(arr[index]);\n           }\n           // System.out.print(list);\n           HashMap<String, Integer> hm = new HashMap<>();\n           for (String s : list) {\n               if (hm.containsKey(s)) {\n                   Integer num = hm.get(s);\n                   num++;\n                   hm.put(s, num);\n               } else {\n                   hm.put(s, 1);\n               }\n            }\n           System.out.println(hm);\n           int max = 0;\n           Set<String> strings = hm.keySet();\n           for (String s : strings) {\n               int count = hm.get(s);\n               if (count >= max){\n                  max = count;\n              }\n           }\n   //        Set<Map.Entry<String, Integer>> entries = hm.entrySet();\n   //\n   //        for (Map.Entry<String, Integer> sMax : entries) {\n   //            int value = sMax.getValue();\n   //            if (value >= max){\n   //                max = value;\n   //            }\n   //        }\n           System.out.println(max);\n   \n       }\n   \n   }\n   \n   ```\n\n# LinkHashMap\n\n## 特点\n\n- 由键快定：有序、不重复、无索引。\n- 这里的有序指的是保证存储和取出的元素顺序一致\n- 原理：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。\n\n```java\npackage day_25;\n\nimport java.util.LinkedHashMap;\n\npublic class LinkHashMap {\n    public static void main(String[] args) {\n        LinkedHashMap<String,Integer> lhm = new LinkedHashMap<>();\n        lhm.put(\"a\",1);\n        lhm.put(\"b\",1);\n        lhm.put(\"c\",1);\n        lhm.put(\"d\",1);\n        System.out.println(lhm);// {a=1, b=1, c=1, d=1}\n    }\n\n}\n\n```\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"Map","url":"/2023/02/20/Map/","content":"# Map\n\n## Map常见的Api\n\n> Mp是双列集合的顶层接口，它的功能是全部双列集合都可以继承使用的\n\n   ![](https://pic.imgdb.cn/item/63f37b02f144a01007f478f2.jpg)\n\n```java\npackage day_25;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Map_Demo1 {\n    /*\n    V put(K key,V value)                  添加元素\n    V remove(object key)                  根据键删除键值对元素\n    void clear()                          移除所有的键值对元素\n    boolean containsKey(object key)       判断集合是否包含指定的键\n    boolean containsValue(object value)   判断集合是否包含指定的值\n    boolean isEmpty()                     判断集合是否为空\ni   int size()                            集合的长度，也就是集合中键值对的个数\n     */\n    public static void main(String[] args) {\n\n        // 创建Map对象\n        Map<String, String> map = new HashMap<>();\n\n        // 添加元素\n        // put方法细节\n        // 添加/覆盖\n\n        // 在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中， 方法返回Null\n        // 在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。\n        map.put(\"a\", \"1\");\n        map.put(\"b\", \"2\");\n        map.put(\"c\", \"3\");\n\n        // String value = map.put(\"a\", \"4\");\n        // System.out.println(value);  // 1\n\n        // 删除\n        // map.remove(\"a\"); // {b=2, c=3}\n\n\n\n        //清空\n        //map.clear();\n        //判断是否包含\n//        boolean keyResult = map.containsKey(\"a\"); // true\n//        System.out.println(keyResult);//true\n//        boolean valueResult = map.containsValue(\"1\"); // true\n//        System.out.println(valueResult);\n\n        // System.out.println(map.isEmpty());  // false\n        System.out.println(map.size()); // 3\n\n        // 打印集合\n        System.out.println(map); //  {a=4, b=2, c=3}\n\n\n    }\n\n}\n\n```\n\n## Map遍历\n\n1. 键找值\n\n   - ```java\n     package day_25;\n     \n     import java.util.HashMap;\n     import java.util.Iterator;\n     import java.util.Map;\n     import java.util.Set;\n     \n     public class Map_Demo2 {\n         public static void main(String[] args) {\n     \n             // Map 遍历，键找值\n             Map<String, String> m = new HashMap<>();\n             m.put(\"a\", \"1\");\n             m.put(\"b\", \"2\");\n             m.put(\"c\", \"3\");\n             // lambda表达式\n             Set<String> st = m.keySet();\n     //        st.forEach(s -> System.out.print(m.get(s) + \" \"));\n     \n             // 增强for遍历\n             for (String s : st) {\n                 System.out.print(m.get(s) + \" \");\n             }\n             // 迭代器遍历\n             Iterator<String> iterator = st.iterator();\n             while (iterator.hasNext()){\n                 String s = iterator.next();\n                 System.out.println(m.get(s));\n             }\n     \n     \n         }\n     \n     }\n     \n     ```\n\n2. 键值对\n\n   - ```java\n     package day_25;\n     \n     import java.util.HashMap;\n     import java.util.Iterator;\n     import java.util.Map;\n     import java.util.Set;\n     \n     public class Map_Demo3 {\n         public static void main(String[] args) {\n             //Map集合的第二种遍历方式\n             //1.创建Map集合的对象\n             Map<String, String> map = new HashMap<>();\n             //2.添加元素\n             //键：人物的外号\n             //值：人物的名字\n             map.put(\"标枪选手\", \"马超\");\n             map.put(\"人物挂件\", \"明世隐\");\n             map.put(\"御龙骑士\", \"尹志平\");\n             //3.Map集合的第二种遍历方式\n             //通过键值对对象进行遍历\n             //3.1通过一个方法获取所有的键值对对象，返回一个Set集合\n             Set<Map.Entry<String, String>> entries = map.entrySet();\n     \n             // 增强for遍历\n     //        for (Map.Entry<String, String> entry : entries) {\n     //            System.out.println(entry.getKey());\n     //            System.out.println(entry.getValue());\n     //        }\n     \n             // lambda 遍历\n             // entries.forEach(stringStringEntry -> System.out.println(stringStringEntry.getKey() + \" \" + stringStringEntry.getValue()));\n     \n             // 迭代器遍历\n             Iterator<Map.Entry<String, String>> iterator = entries.iterator();\n             while (iterator.hasNext()){\n                 Map.Entry<String, String> next = iterator.next();\n                 System.out.println(next.getKey()+\" \"+next.getValue());\n             }\n     \n         }\n     \n     }\n     \n     ```\n\n3. lambda表达式\n\n   - ```java\n     // lambda 遍历\n     \tMap<Student,String> map= new HashMap<>();\n     \n         map.forEach(new BiConsumer<Student, String>() {\n                 @Override\n                 public void accept(Student student, String s) {\n                     System.out.println(student+\" \"+s);\n                 }\n             });\n     ```\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"双列集合","url":"/2023/02/20/双列集合/","content":"# 双列集合\n\n1. 双列集合一次需要存一对数据，分别为键和值\n2. 键不能重复，值可以重复\n3. 键和值是一一对应的，每一个键只能找到自己对应的值\n4. 键+值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"单列集合总结-day24","url":"/2023/02/19/单列集合总结/","content":"# 单列集合总结\n1. 如果想要集合中的元素可重复\n  - **用ArrayList:集合，基于数组的。<font color = red>（用的最多）</font>**\n2. 如果想要集合中的元素可重复，而且当前的<font color =red>增删操作明显多于查询</font>\n   - **用LinkedList:集合，基于链表的。**\n3. 如果想对集合中的元素去重\n   - **用HashSet集合，基于哈希表的。<font color = red>（用的最多）</font>**\n4. 如果想对集合中的元素去重，而且**<font color = red>保证存取顺序</font>**\n   - **用LinkedHashSet?集合，基于哈希表和双链表，效率低于HashSet.。**\n5. 如果想对集合中的元素进行<font color= red>排序</font>\n   - **用TreeSet:集合，基于红黑树。后续也可以用List集合实现排序。**\n\n![](https://pic.imgdb.cn/item/63f1e6c2f144a01007be7d50.jpg)","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"接口详解-day22","url":"/2023/02/19/接口 对象 =new 实现类详解/","content":"# 接口的详解_接口 对象=new 实现类\n- 接口是为了实现多态。\n- 接口是为了实现多态。\n- 接口是为了实现多态。\n## 先讲一下接口回调。\n```java\ninterface People{\n   void peopleList();\n}\nclass Student implements People{\n    public void peopleList(){\n        System.out.println(\"I’m a student.\")；\n    }\n}\nclass Teacher implements People{\n    public void peopleList(){\n        System.out.println(\"I’m a teacher.\");\n    }\t\n}\npublic class Example{\n    public static void main(String args[]){\n    People a;             //声明接口变量\n    a=new Student();      //实例化，接口变量中存放对象的引用\n    a.peopleList();        //接口回调\n    a=new Teacher();     //实例化，接口变量中存放对象的引用\n    a.peopleList();       //接口回调\n    }\n}\n结果：\nI’m a student.\nI’m a teacher.\n \n例子参考：https://zhidao.baidu.com/question/1923748969384870227.html\n```\n\n### refer\n\n> 今天在公司里面写一个接口及其实现类的时候，\n> 遇到一个现象引起了我的思考。\n> 我做的一个后台管理里面的查询功能，\n> 在controller层对接口的方法进行实现的时候，\n> 我采用的是接口的引用对象来实现。\n> 为什么不采用实现类创建引用对象来调用方法实现呢？\n>\n> 按照正常的逻辑，\n> 接口里面只定义了方法名称。\n> 主要的实现还是在继承接口的实现类里面，\n> 而我看了别人的代码，\n> 他们也大部分都是创建接口对象来实现，\n> 重写的方法体是在实现类里面，接口对象为什么就可以使用。\n> 例如：\n\n```java\nList list = new ArrayList();\n//List是接口,ArrayList是它的实现类\n\n```\n\n原因：这就是JAVA多态的特点。\n父类引用指向子类对象，\n父类（接口）的引用就能够直接调用子类（实现类）的方法。\n\n为什么在实际的开发过程中不采用直接创建实现类对象来调用方法呢？\n我在知乎上看到这一篇文章，觉得非常收益，\n这么做的主要目的还是为了能够减少开发过程中代码的修改量。\n\n[快速理解Java多态的含义][https://zhuanlan.zhihu.com/p/53731349]\n\n\n\n##  快速理解Java多态的含义\n\n> 自己把这篇文章归纳总结如下：\n> 定义一个animal抽象类， 里面有两个方法。\n> 接下里定义两个类（cat和dog）去继承animal，\n> cat和dog分别重写了animal中的方法。\n>\n> 我们在调用dog里面的方法之后，\n> 想修改为调用cat的方法。 ----\n> 只需要将Animal animal=new Dog()改成Animal\n> animal=new Catl()， 只改变了一个对象。\n> 接着继续调用animal.sing()，animal.run()。\n> 实际的开发过程中要维护大量的代码量，\n> 如果要换一个对象，改的代码更少。\n\n[][]\n\n[][]\n\n[博客园 深入理解JAva的接口和抽象类][https://www.cnblogs.com/dolphin0520/p/3811437.html]\n\n```java\n//implA 为接口 ClassB为其实现类\nimplA A=new ClassB();//接口类型的引用变量A 去接收对象地址\nor\nClassB A=new ClassB();//类类型的引用变量A 去接收对象地址\n\n\ninterface A { //接口A               \n //接口的方法声明必须是 public abstract ，即便不写默认也是\n    public void fun();\n\n}\npublic class B implements A {\n\n    @Override\n    public void fun() {\n        //your coding\n    }\n\n}\n```\n\n如果我们要使用B类对象，调用B类方法，我们很容易就会习惯的写出\n\n` A demo=new B();`\n\n>用接口类型的引用变量demo，\n>**去接收实现类B实例化出来的对象地址(这里的=是传递的地址)。**\n\n> 为什么不是B demo=new B();\n\n> 呢，这样也不会有问题啊？\n> （当然A demo=newA();\n> 是不可能的，因为接口是不能用来实例化对象的，\n> 但可以用来声明一个接口类型的引用变量）。\n\n先把结论丢出来吧\n应该优先使用接口而不是类来引用对象，但只有存在适当的接口类型时\n\n```java\npublic class InterfaceTest {\n\n    public static void main(String[] args) {\n\n        PetInterface p = new Cat();\n        p.talk();\n        p.batheSelf();//无法调用 ，报错The method batheSelf() is undefined for the type PetInterface\n    }\n\n}\n\ninterface PetInterface {                \n\n    public void talk();\n\n}\n\nclass Dog implements PetInterface {\n\n    @Override\n    public void talk() {\n        System.out.println(\"Bark!\");\n    }\n\n}\n\nclass Cat implements PetInterface {\n\n    @Override\n    public void talk() {\n        System.out.println(\"Meow!\");\n    }\n\n    public void batheSelf() {\n        System.out.println(\"Cat bathing\");\n    }\n\n}\n\n```\n\n> 我们看到，\n> 方法batheSelf()仅仅存在实现类中时，\n> 若我们仍然使用接口来引用对象时\n> PetInterface p = newCat()，\n> 那些仅仅存在实现类中的方法，\n> 是无法直接调用的即p.batheSelf()无法调用会报错。\n> 所以这时使用Cat p = new Cat()即类来引用是更好的。\n\n> 也就是说，\n> 使用接口类去引用对象是有前提条件的\n> ——即实现类中全是接口类的方法的实现，没有自己单独的方法。\n> **当实现类存在自己的方法时，使用实现类来声明变量。**\n\n## 【转型问题】\n\n```java\npublic static void main(String[] args) {\n\n        PetInterface p = new Cat();//向上转型 Cat->PetInterface \n        p.talk();\n        p.batheSelf();//无法调用 ，报错The method batheSelf() is undefined for the type PetInterface\n    }\n```\n\n> 我们说直接p.batheSelf()会报错，\n> 这是因为向上转型的过程中Cat->PetInterface ，\n> 对PetInterface 接口造成的唯一效应就是函数的“遗失”而非”获得”\n> （即遗失了实现类自己独有的函数方法batheSelf()），\n> 而Cat向上转型至PetInterface可能会窄化其功能，\n> 但无论如何不会窄于PetInterface接口功能。\n> 当然也存在向下转型，\n\n```java\n//p.batheSelf();替换为下面形式\n((Cat)p).batheSelf();//向下转型，可正常调用执行\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"TreeSet-day24","url":"/2023/02/18/TreeSet/","content":"# TreeSet\n\n## TreeSet 特点\n\n- 不重复、无索引、可排序\n- 可排序：按照元素的默认规则（有小到大)排序。\n- TreeSet:集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。\n- 底层不是哈希表，是红黑树\n\n## TreeSet集合默认的规则\n\n- 对于数值类型：Integer,Double,默认按照从小到大的顺序进行排序。\n- 对于字符、字符串类型：按照字符在ASCLL码表中的数字升序进行排序。\n\n## TreeSet 排序\n\n### TreeSet的两种比较方式\n\n1. 默认排序/自然排序：Javabean类实现Comparable接口指定比较规则\n2. 比较器排序：创建TreeSet>对象时候，传递比较器Comparator指定规侧\n\n> 使用原则：默认使用第一种，如果第一种不能满足当前需求，就使用第二种\n\n#### 排序方式一\n\n\n\n### Integer排序\n\n```jav\npackage day_24;\n\nimport java.util.Iterator;\n\npublic class TreeSet {\n    /*\n    需求：利用TreeSet存储整数并进行排序\n     */\n    public static void main(String[] args) {\n        java.util.TreeSet<Integer> ts = new java.util.TreeSet<>();\n        ts.add(1);\n        ts.add(5);\n        ts.add(2);\n        ts.add(4);\n        ts.add(3);\n        System.out.println(ts);  // [1, 2, 3, 4, 5]\n\n\n        // 遍历\n        // 迭代器\n        Iterator<Integer> it = ts.iterator();\n        while (it.hasNext()) {\n            Integer next = it.next();\n            System.out.print(next);\n        }\n        System.out.println();\n        // 增强for \n        for (Integer t : ts) {\n            System.out.print(t);\n        }\n        System.out.println();\n        // lambda\n        ts.forEach(integer -> System.out.print(integer));\n\n    }\n\n}\n\n```\n\n### 自定义类型排序\n\n```java\npackage day_24;\n\npublic class Student2 implements Comparable<Student2> {\n    private String name;\n    private int age;\n    @Override\n    public int compareTo(Student2 o) {\n\n        return this.getAge() - o.getAge();\n    }\n}\n\n```\n\n```java\npackage day_24;\n\nimport java.util.TreeSet;\n\npublic class TreeSetDemo2 {\n    public static void main(String[] args) {\n        Student2 s1 = new Student2(\"zahngsan\",23);\n        Student2 s2 = new Student2(\"lisi\",24);\n        Student2 s3 = new Student2(\"wangwu\",25);\n        Student2 s4 = new Student2(\"zahngsan\",23);\n        TreeSet<Student2> st= new TreeSet<>();\n        st.add(s1);\n        st.add(s2);\n        st.add(s3);\n        st.add(s4);\n        System.out.println(st);\n        // [Student2{name = zahngsan, age = 23}, Student2{name = lisi, age = 24}, Student2{name = wangwu, age = 25}]\n     }\n\n}\n\n```\n\n```java\npackage day_24;\n\npublic class Student3 implements Comparable<Student3> {\n    private String name;\n    private int age;\n    // 语文成绩\n    private int chinese;\n    private int math;\n    private int english;\n\n\n    public Student3() {\n    }\n\n    public Student3(String name, int age, int chinese, int math, int english) {\n        this.name = name;\n        this.age = age;\n        this.chinese = chinese;\n        this.math = math;\n        this.english = english;\n    }\n\n    /**\n     * 获取\n     *\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     *\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     *\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     *\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     *\n     * @return chinese\n     */\n    public int getChinese() {\n        return chinese;\n    }\n\n    /**\n     * 设置\n     *\n     * @param chinese\n     */\n    public void setChinese(int chinese) {\n        this.chinese = chinese;\n    }\n\n    /**\n     * 获取\n     *\n     * @return math\n     */\n    public int getMath() {\n        return math;\n    }\n\n    /**\n     * 设置\n     *\n     * @param math\n     */\n    public void setMath(int math) {\n        this.math = math;\n    }\n\n    /**\n     * 获取\n     *\n     * @return english\n     */\n    public int getEnglish() {\n        return english;\n    }\n\n    /**\n     * 设置\n     *\n     * @param english\n     */\n    public void setEnglish(int english) {\n        this.english = english;\n    }\n\n    public String toString() {\n        return \"Student3{name = \" + name + \", age = \" + age + \", chinese = \" + chinese + \", math = \" + math + \", english = \" + english + \"}\";\n    }\n\n    @Override\n    public int compareTo(Student3 o) {\n        /*\n        如果总分一样，按照语文成绩排\n        如果语文一样，按照数学成绩排\n        如果数学成绩一样，按照英语成绩排\n        如果英文成绩一样，按照年龄排\n        如果年龄一样，按照姓名的字母顺序排\n        如果都一样，认为是同一个学生，不存。\n         */\n        int sum1 = this.getChinese() + this.getMath() + this.getEnglish();\n        int sum2 = o.getChinese() + o.getMath() + o.getEnglish();\n        System.out.println(o.getName()+ \"分数\"+sum2);\n        System.out.println(this.getName()+ \"分数\"+sum1);\n\n        int i = sum1 - sum2;\n        i = i == 0 ? this.getChinese() - o.getChinese() : i;\n        i = i == 0 ? this.getMath() - o.getMath() : i;\n        i = i == 0 ? this.getEnglish() - o.getEnglish() : i;\n        i = i == 0 ? this.getAge() - o.getAge() : i;\n        i = i == 0 ? this.getName().compareTo(o.getName()) : i;\n        return i;\n    }\n}\n\n\n\n\n\n\npackage day_24;\n\nimport java.util.TreeSet;\n\npublic class TreeSetDemo4 {\n    /*\n    需求：创建5个学生对象\n    属性：（姓名，年龄，语文成绩，数学成绩，英语成绩），\n    按照总分从高到低输出到控制台\n    如果总分一样，按照语文成绩排\n    如果语文一样，按照数学成绩排\n    如果数学成绩一样，按照英语成绩排\n    如果英文成绩一样，按照年龄排\n    如果年龄一样，按照姓名的字母顺序排\n    如果都一样，认为是同一个学生，不存。\n     */\n    public static void main(String[] args) {\n        Student3 st1 = new Student3(\"ZhangSan\",23,65,80,59);\n        Student3 st2 = new Student3(\"lisi\",24,75,70,69);\n        Student3 st3 = new Student3(\"WangWu\",25,85,60,89);\n        Student3 st4 = new Student3(\"ZhaoLiu\",26,95,50,49);\n\n        TreeSet<Student3> st = new TreeSet<>();\n        st.add(st1);\n        st.add(st2);\n        st.add(st3);\n        st.add(st4);\n        System.out.println(st);\n        // [Student3{name = ZhaoLiu, age = 26, chinese = 95, math = 50, english = 49},\n        // Student3{name = ZhangSan, age = 23, chinese = 65, math = 80, english = 59},\n        // Student3{name = lisi, age = 24, chinese = 75, math = 70, english = 69},\n        // Student3{name = WangWu, age = 25, chinese = 85, math = 60, english = 89}]\n\n    }\n\n}\n\n```\n\n\n\n\n\n![](https://pic.imgdb.cn/item/63f1d3b6f144a01007a197fb.jpg)\n\n#### 排序方式二\n\n```java\npackage day_24;\n\nimport java.util.TreeSet;\n\npublic class TreeSetDemo3 {\n    /*\n    需求：请自行选择比较器排序和自然排序两种方式：\n    要求：存入四个字符串，“c”,“ab”,“df”,“qwer”\n    按照长度排序，如果一样长则按照首字母排序\n    \n    String类中定义了排序规则，因此方式一不适合\n     */\n    public static void main(String[] args) {\n        TreeSet<String> ts = new TreeSet<>(\n           (String o1, String o2)-> {\n                int i = o1.length() - o2.length();\n                i = i == 0 ? o1.compareTo(o2) : i;\n                return i;\n            }\n        );\n        ts.add(\"c\");\n        ts.add(\"ab\");\n        ts.add(\"df\");\n        ts.add(\"qwer\");\n        //  System.out.println(ts); // 默认String中的排序方式 [ab, c, df, qwer]\n        System.out.println(ts);  // 修改排序方式后 [c, ab, df, qwer]\n\n    }\n\n}\n\n```\n\n```java\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"Set系列集合-day24","url":"/2023/02/18/Set系列集合/","content":"# Set系列集合\n\n## 特点\n\n- 无序：存取顺序不一致\n- 不重复：可以去除重复\n- 无索引：没有带索引的方法，所以不能使用普通fo循环遍历，也不能通过索引来获取元素\n\n## Set集合实现类\n\n- HashSet:无序、不重复、无索引\n- LinkedHashSet:有序、不重复、无索引\n- TreeSet:可排序、不重复、无索引\n\n<mark>Set接口中的方法上基本上与Collection的API一致。</mark>\n\n![](https://pic.imgdb.cn/item/63f0a6b9f144a01007d52189.jpg)\n\n## 遍历方式\n\n- 迭代器\n- 增强for\n- lambda表达式\n\n ```java\n package day_24;\n \n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Set;\n import java.util.function.Consumer;\n \n public class SetDemo1 {\n     /*\\\n     利用Set系列的集合，添加字符串，并使用多种方式遍历。\n     迭代器\n     增强for\n     Lambda表达式\n      */\n \n     //1.创建一个Set集合的对象\n     public static void main(String[] args) {\n         Set<String> s = new HashSet<>();\n         //2,添加元素\n         boolean r1 = s.add(\"张三\");\n         boolean r2 = s.add(\"张三\");\n         s.add(\"李四\");\n         s.add(\"王五\");\n         System.out.println(r1);//true\n         System.out.println(r2);// false  Set元素是唯一的\n         System.out.println(s); // [李四, 张三, 王五]    存和取得顺序是不一样的\n \n \n         // 迭代器遍历\n         Iterator<String> iterator = s.iterator();\n         while (iterator.hasNext()) { // 判断当前位置是否有元素\n             String str = iterator.next(); // 获取当前元素，并移动指针\n             System.out.println(str);\n \n         }\n \n         // 增强for遍历\n         for (String item : s) {\n             System.out.println(item);\n         }\n         // lambda 表达式遍历\n //        s.forEach(new Consumer<String>() {\n //            @Override\n //            public void accept(String str) {\n //                System.out.print(str);\n //            }\n //        });\n         s.forEach(str -> System.out.print(str));\n     }\n \n \n }\n \n ```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"HashSet-day24","url":"/2023/02/18/HashSet/","content":"\n# HashSet\n## HashSet底层原理\n\n- HashSets集合底层采取哈希表存储数据\n- 哈希表是一种对于增删改查数据性能都较好的结构\n\n## 哈希表的组成\n\n- JDK8之前：数组+链表\n- JDK8开始：数组+链表+红黑树\n\n## 哈希值\n\n> 哈希值：对象的整数表现形式\n\n- 根据hashCode方法算出来的int类型的整数\n- 该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算\n- 一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值\n\n## 对象的哈希值特点\n\n- 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的 \t\n- 如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的\n- 在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（哈希碰撞）\n\n\t## HashSet JDK8以后底层原理\n\n1. 创建一个默认长度16，默认加载因子0.75的数组，数组名table\n2. 根据元素的哈希值跟数组的长度计算出应存入的位置\n3. 判断当前位置是否为nul,如果是nul直接存入\n4. 如果位置不为null,表示有元素，则调用equals方法比较属性值\n5. 一样：不存     不一样：存入数组，形成链表\n6. JDK8以前：新元素存入数组，老元素挂在新元素下面\n7. JDK8以后：新元素直接挂在老元素下面\n\n- JDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树\n- 如果集合中存储的是自定义对象，必须要重写hashCode和equals方法\n\n## HashSet的三个问题\n\n1. 问题1：HashSet.为什么存和取的顺序不一样？\n\n   > 底层是链表或者红黑树\n\n2. 问题2：HashSet:为什么没有索引？\n\n   > 底层是链表或者红黑树\n\n3. 问题3：HashSet;是利用叶么机制保证数据去重的？\n\n   > HashCode方法\n   > equals.方法\n\n```java\npackage day_24;\n\npublic class HashSetDemo1 {\n    /*\n    哈希值：\n对象的整数表现形式\n1.如果没有重写hashCode方法，不同对象计算出的哈希值是不同的\n2.如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的\n3.但是在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（哈希碰撞）\n     */\n    public static void main(String[] args) {\n        Student s1 = new Student(\"张三\",23);\n        Student s2 = new Student(\"张三\",23);\n        //1.如果没有重写hashCode方法，不同对象计算出的哈希值是不同的\n        System.out.println(s1.hashCode()); // 1324119927\n        System.out.println(s2.hashCode()); //990368553\n        //如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的\n        // System.out.println(s1.hashCode()); // 24022543\n        // System.out.println(s2.hashCode()); //24022543\n\n        // 但是在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（哈希碰撞）\n        System.out.println(\"abc\".hashCode());  // 96354\n        System.out.println(\"acD\".hashCode());  // 96354\n\n\n    }\n\n\n}\n\n```\n\n\n\n# LinkHashSet 底层原理\n\n- <font color = red>有序、</font>不重复、无索引。\n\n  > 这里的有序指的是保证存储和取出的元素顺序一致\n\n- 原理：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。\n\n```java\npackage day_24;\n\nimport java.util.LinkedHashSet;\n\npublic class LinkHashSetDemo1 {\n    public static void main(String[] args) {\n        Student s1 = new Student(\"张三\",23);\n        Student s2 = new Student(\"lisi\",24);\n        Student s3 = new Student(\"WangWu\",25);\n        Student s4 = new Student(\"张三\",23);\n\n        LinkedHashSet<Student> hs  =new LinkedHashSet<>();\n        System.out.println(hs.add(s1));  // true\n        System.out.println(hs.add(s2));  // true\n        System.out.println(hs.add(s3)); // true\n        System.out.println(hs.add(s4)); // false\n\n        System.out.println(hs);  // [Student{name = 张三, age = 23}, Student{name = lisi, age = 24}, Student{name = WangWu, age = 25}]\n    }\n\n}\n\n```\n\n# 总结\n\n1. LinkedHashSet集合的特点和原理是怎么样的？\n   - 有序、不重复、无索引\n   - 底层基于哈希表，使用双链表记录添加顺序\n2. 在以后如果要数据去重，我们使用哪个？\n   - 默认使用HashSet\n   - 如果要求去重且存取有序，才使用LinkedHashSet","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"泛型总结","url":"/2023/02/15/泛型总结/","content":"# 泛型总结\n\n## 什么是泛型？\n\n- JDK5引入的特性，可以在编译阶段约束操作的数据类型，并进行检查\n\n## 泛型的好处？\n\n- 统一数据类型\n- 把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。\n\n## 泛型的细节？\n\n- 泛型中不能写基本数据类型\n- 指定泛型的具体类型后，传递数据时，可以传入该类型和他的子类类型\n- 如果不写泛型，类型默认是Object\n\n## 哪里定义泛型？\n\n- 泛型类：在类名后面定义泛型，创建该类对象的时候，确定类型\n- 泛型方法：在修饰符后面定义方法，调用该方法的时候，确定类型\n- 泛型接口：在接口名后面定义泛型，实现类确定类型，实现类延续泛型\n\n## 泛型的继承和通配符\n\n- 泛型不具备继承性，但是数据具备继承性\n- 泛型的通配符：？\n- ？extend E\n- ？super E\n\n## 使用场景\n\n- ·定义类、方法、接口的时候，如果类型不确定，就可以定义泛型\n- ·如果类型不确定，但是能知道是哪个继承体系中的，可以使用泛型的通配符","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"Java泛型的继承和通配符-day23","url":"/2023/02/15/Java泛型的继承和通配符3/","content":"\n# Java泛型的继承和通配符\n\n\n## 泛型不具备继承性，但是数据具备继承性\n\n```java\n此时，泛型里面写的是什么类型，那么只能传递什么类型的数据。\n弊端：\n利用泛型方法有一个小弊端，此时他可以接受任意的数据类型\nYe Fu zi\nStudent\n希望：本方法虽然不确定类型，但是以后我希望只能传递Ye Fu zi\n此时我们就可以使用泛型的通配符：\n?也表示不确定的类型\n他可以进行类型的限定\n？extends E:表示可以传递E或者E所有的子类类型\n?super E:表示可以传递E或者E所有的父类类型\n应用场景：\n1.如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。\n2.如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符\n泛型的通配符：\n关键点：可以限定类型的范围。\n```\n\n\n## 泛型练习\n```java\npackage day_23.test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class demo3 {\n    /*\n    需求：\n定义一个继承结构：\n                                                动物\n                                                |\n                                  狗                                猫\n\n                           |             |                     |         |\n\n                        泰迪             哈士奇               波斯猫        狸花猫\n\n属性：名字，年龄\n行为：吃东西\n波斯猫方法体打印：一只叫做XXX的，X岁的波斯猫，正在吃小饼干\n狸花猫方法体打印：一只叫做XX的，X岁的狸花猫，正在吃鱼\n泰迪方法体打印：一只叫做XX的，X岁的泰迪，正在吃骨头，边吃边蹭\n哈士奇方法体打印：一只叫做XXX的，，X岁的哈士奇，正在吃骨头，边吃边拆家\n测试类中定义一个方法用于饲养动物\npublic static void keepPet(ArrayList<???>list){}\n//遍历集合，调用动物的eat方法\n要求1：该方法能养所有品种的猫，但是不能养狗\n要求2：该方法能养所有品种的狗，但是不能养猫\n要求3：该方法能养所有的动物，但是不能传递其他类型\n     */\n\n    public static void main(String[] args) {\n        ArrayList<PerSionCat> list1 = new ArrayList<>();\n        ArrayList<LiHuaCat> list2 = new ArrayList<>();\n        ArrayList<HusKeyDog> list3 = new ArrayList<>();\n        ArrayList<TeddyDog> list4 = new ArrayList<>();\n\n        keepPet(list1);\n        keepPet(list2);\n        keepPet(list3);\n        keepPet(list4);\n    }\n    // 要求1：该方法能养所有品种的猫，但是不能养狗\n    // public static  void keepPet(ArrayList<? extends cat> list){}\n    // 要求2：该方法能养所有品种的狗，但是不能养猫\n    // public static  void keepPet(ArrayList<? extends Dog> list){}\n    // 要求3：该方法能养所有的动物，但是不能传递其他类型\n    public static  void keepPet(ArrayList<? extends Animal> list){}\n\n}\n\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"Java泛型","url":"/2023/02/15/Java泛型/","content":"# Java泛型\n\n## 泛型深入\n- 泛型：是DK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。\n- 泛型的格式：<数据类型>\n- 注意：泛型只能支持引用数据类型。\n\n## 结论\n\n```java\n//没有泛型的时候，集合如何存储数据\n//结论：\n//如果我们没有给集合指定类型，默认认为所有的数据类型都是object类型\n//此时可以往集合添加任意的数据类型。\n//带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。\n//此时推出了泛型，可以在添加数据的时候就把类型进行统一。\n//而且我们在获取数据的时候，也省的强转了，非常的方便。\n```\n\n## 泛型的好处\n\n- 统一数据类型。\n- 把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。\n- 扩展知识点：Java中的泛型是伪泛型\n\n## 泛型的细节\n\n- 泛型中不能写基本数据类型\n- 指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型\n\n```java\nArrayList<Animal>list new ArrayList<>();\nlist.add(new Animal());\nlist.add(new cat());\nlist.add(new Dog());\n```\n\n\n\n- 如果不写泛型，类型默认是Object\n\n## 泛型可以在很多地方进行定义\n\n- 类后面 --- 泛型类\n- 方法上面 ---- 泛型方法\n- 接口后面 - --- 泛型接口\n\n### 泛型类\n\n> 使用场景：当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类\n\n```java\n修饰符c1ass类名<类型>{\n}\n\n// 举例\npublic class ArrayList <E>{}\n // 创建该类对象时，E就确定类型\n// 此处E可以理解为变量，但是不是用来记录数据的，而是记录数据的类型，可以写成：T、E、K、V等  \n```\n\n\n\n## 泛型方法\n\n### 方法中形参类型不确定时\n\n- 方案①：使用类名后面定义的泛型\n  所有方法部能用\n- 方案②：在方法申明上定义自己的泛型\n  只有本方法能用\n\n```java\n // 修饰符<类型>返回值类型方法名（类型变量名）{}\n\npublic<T>void show(Tt){}\n\n// 此处T可以理解为变量，但是不是用来记录数据的，而是记录类型的，可以写成：T、E、K、V等\n```\n\n  ## 泛型接口\n\n```java\n修饰符interface接口名<类型>{}\n\npublic interface List<E>{}\n\n```\n\n### 重点--如何使用一个带泛型的接口\n\n- 方式1：实现类给出具体类型\n\n  ```java\n  public class MyArrayList2 implements List<String>\n  ```\n\n  \n\n- 方式2：实现类延续泛型，创建对象时再确定\n\n  ```jav\n  public class MyArrayList3<E> implements List<E>\n  ```\n\n```java\npackage day_23;\n\npublic class ArrayListDemo1 {\n    public static void main(String[] args) {\n        MyArraylist<String> list = new MyArraylist<>();\n        list.add(\"aaa\");\n        list.add(\"bbb\");\n        list.add(\"ccc\");\n        System.out.println(list.get(2));\n        System.out.println(list);\n        MyArraylist<Integer> list2 = new MyArraylist<>();\n\n        System.out.println(list2.get(0));\n        System.out.println(list2);\n\n\n\n\n\n    }\n\n}\n\n```\n\n```java\npackage day_23;\n\nimport java.util.ArrayList;\n\npublic class Demo1 {\n    public static void main(String[] args) {\n        ArrayList<String> list = new ArrayList<>();\n        ListUtils.add(list,\"aaa\",\"bbb\",\"ccc\",\"ddd\");\n        System.out.println(list);\n        ArrayList<Integer> list2 = new ArrayList<>();\n        ListUtils.add(list2,1,2,3,4);\n        System.out.println(list2);\n        ArrayList<Integer> list3 = new ArrayList<>();\n        ListUtils.addAl12(list3,2,2,2,2,2,2,2,2,2,2,2,22,2,2,2,22,2,22);\n        System.out.println(list3);\n\n    }\n\n}\n\n```\n\n```java\npackage day_23;\n\nimport java.util.ArrayList;\n\npublic class ListUtils {\n    private ListUtils(){}\n    /*\n    类中定义一个静态方法addAll,用来添加多个集合的元素。\n    参数一：集合\n    参数二~最后：要添加的元素\n     */\n    public static<E> void add(ArrayList<E> list,E e1,E e2,E e3,E e4){\n        list.add(e1);\n        list.add(e2);\n        list.add(e3);\n        list.add(e4);\n\n    }\n    // ...e可无限延伸，底层是个数组\n    public static<E>void addAl12(ArrayList<E>list,E...e) {\n        for (E element :e) {\n            list.add(element);\n        }\n    }\n\n\n}\n\n```\n\n```java\npackage day_23;\n\nimport java.util.Arrays;\n\npublic class MyArraylist<E> {\n    /*\n    当我在编写一个类的时候，如果不确定类型，那么这个类就可以定义为泛型类。\n     */\n    Object[] obj = new Object[10];\n    int size;\n    /*\n    E:表示是不确定的类型。该类型在类名后面已经定义过了。\n    e:形参的名字，变量名\n     */\n    public boolean add(E e){\n        obj[size] = e;\n        size++;\n        return true;\n\n    }\n    // 泛型方法\n    public E get(int index){\n        return (E) obj[index];\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(obj);\n    }\n}\n\n```\n\n```java\npackage day_23;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class MyArrayList2<E> implements List<E> {\n\n    @Override\n    public int size() {\n        return 0;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return false;\n    }\n\n    @Override\n    public boolean contains(Object o) {\n        return false;\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return null;\n    }\n\n    @Override\n    public Object[] toArray() {\n        return new Object[0];\n    }\n\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return null;\n    }\n\n    @Override\n    public boolean add(E e) {\n        return false;\n    }\n\n    @Override\n    public boolean remove(Object o) {\n        return false;\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        return false;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        return false;\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n        return false;\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        return false;\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        return false;\n    }\n\n    @Override\n    public void clear() {\n\n    }\n\n    @Override\n    public E get(int index) {\n        return null;\n    }\n\n    @Override\n    public E set(int index, E element) {\n        return null;\n    }\n\n    @Override\n    public void add(int index, E element) {\n\n    }\n\n    @Override\n    public E remove(int index) {\n        return null;\n    }\n\n    @Override\n    public int indexOf(Object o) {\n        return 0;\n    }\n\n    @Override\n    public int lastIndexOf(Object o) {\n        return 0;\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return null;\n    }\n\n    @Override\n    public ListIterator<E> listIterator(int index) {\n        return null;\n    }\n\n    @Override\n    public List<E> subList(int fromIndex, int toIndex) {\n        return null;\n    }\n}\n\n```\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"数据结构","url":"/2023/02/15/数据结构 -1/","content":"# 数据结构 -1\n\n## 二叉查找树\n\n> 二叉查找树，又称二叉排序树或者二叉搜索树\n\n### 特点\n\n- 每一个节点上最多有两个子节点\n- 任意节点左子树上的值都小于当前节点\n- 任意节点右子树上的值都大于当前节点\n\n### 添加节点\n\n> 规则：\n>\n> 小的存左边\n>\n> 大的存右边\n>\n> 一样的不存\n\n### 弊端\n\n当数据有规律递增或者递减时，左右子树高度差太大\n\n## 二叉树的遍历\n\n### 前序遍历\n\n> 从根结点开始，然后按照当前结点，左子结点，右子结点的顺序遍历\n\n### 中序遍历\n\n> 从最左边的子节点开始，然后按照左子结点，当前结点，右子结点的顺序遍历\n\n### 后序遍历\n\n> 从最左边的子节点开始，然后按照左子结点，右子结点，当前结点的顺序遍历\n\n### 层序遍历\n\n> 从根节点开始一层一层的遍历\n\n## 节点的内部结构\n\n- 父节点地址\n- 值\n- 左子节点地址\n- 右子节点地址\n\n## 平衡二叉树\n\n> 规则：任意左右子树高度差不超过1\n\n### 旋转机制\n\n- 规则1：左旋\n- 规则2：右旋\n- 触发时机：当添加一个节点之后，该树不再是一颗平衡二叉树\n\n#### 左旋\n\n- 确定支点：从添加的节点开始，不断的往父节点找不平衡的节点\n- 步骤\n  - 以不平衡的点作为支点\n  - 将根节点的右侧往左拉\n  - 原先的右子节点变成新的父节点，并把多\n    余的左子节点出让，给已经降级的根节点\n    当右子节点\n\n### 右旋\n\n- 确定支点：从添加的节点开始，不断的往父节点找不平衡的节点\n- 步骤\n  - 以不平衡的点作为支点\n  - 就是将根节点的左侧往右拉\n  - 原先的左子节点变成新的父节点，并把多\n    余的右子节点出让，给已经降级的根节点\n    当左子节点\n\n### 旋转的四种情况\n\n- 左左\n  - 一次右旋\n  - 左左：当根节点左子树的左子树有节点插入，导致二叉树不平衡\n- 左右\n  - 先后部左旋，再整本右旋\n  - 左右：当根节点左子树的右子树有节点插入，导致二叉树不平衡\n- 右右\n  - 一次左旋\n  - 右右：当根节点右子树的右子树有节点插入，导致二叉树不平衡\n- 右左\n  - 先后部右旋，再整体左旋\n  - 右左：当根节点右子树的左子树有节点插入，导致二叉树不平衡\n\n\n\n\n\n![](https://pic.imgdb.cn/item/63ecfa53f144a01007ac1df2.jpg)\n\n## 红黑树\n\n> 红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。\n> 1972年出现，当时被称之为平衡二叉B树。后来，1978年被修改为如今的\"红黑树\"。\n> 它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，\n> 每一个节点可以是红或者黑；红黑树不是高度平衡的，它的平衡是通过\"红黑规则\"进行实现的\n\n- 是一个二叉查找树\n- 但是不是高度平衡的\n- 条件： 特有的红黑规则\n\n### 红黑规则\n\n1. 每一个节点或是红色的，或是黑色的\n2. 根节点必须是黑色\n3. 如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的\n4. 如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）\n5. 对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点；\n\n![](https://pic.imgdb.cn/item/63f09e30f144a01007c8047f.jpg)\n\n![](https://pic.imgdb.cn/item/63f09e59f144a01007c84262.jpg)\n\n### 添加节点\n\n- 默认颜色：添加节点默认是 <font color = red>红色</font> 的（效率高）\n\n![](https://pic.imgdb.cn/item/63f0a0acf144a01007cc1255.jpg)\n\n### 红黑树小结\n\n<Mark>红黑树增删改查的性能都很好</Mark>\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"LinkList 集合源码分析-day22","url":"/2023/02/08/LinkList 集合/","content":"# LinkList 集合\n\n## 概念\n\n底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。\n\n![](https://pic.imgdb.cn/item/63e35e5b4757feff33236506.jpg)\n\n## 迭代器源码分析\n\n![](https://pic.imgdb.cn/item/63e360114757feff33268f39.jpg)\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"Collection","url":"/2023/01/29/Collection/","content":"# Collection\n## Collection\n> Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。\n> \n\n## collection 是单列集合\n## 集合体系结构\n![集合体系结构](https://pic.imgdb.cn/item/63d5e99aface21e9efe0a37a.png)\n# List 系列集合\n> 添加的元素是有序、可重复、有索引\n\n- 有序：存和取的顺序是一样的，并非排序的有序\n- 可重复：表示集合中元素是**可以**重复的\n- 有索引：可以通过索引获取集合中每个元素\n\n***\n## 代码演示\n```java\npackage day_22;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class CollectionDemo1 {\n    public static void main(String[] args) {\n        /*\n        public boolean add(E e) 添加\n        public void clear()  清空\n        public boolean remove(E e)  删除\n        public boolean contains(Object obj)判断是否包含\n        public boolean isEmpty() 判断是否为空\n        public int size() 集合长度\n\n\n        注意点：\n        collection是一个接口，我们不能直接创建他的对象。\n        所以，现在我们学习他的方法时，只能创建他实现类的对象。\n        实现类：ArrayList\n\n        //目的：为了学习collection接口里面的方法\n        //自己在做一些练习的时候，还是按照之前的方式去创建对象。\n */\n\n        Collection<String> coll = new ArrayList<>();\n//1.添加元素\n//细节1：如果我们要往List系列集合中添加数据，那么方法永远返回true,因为List系列的是允许元素重复的。\n//细节2：如果我们要往Set系列集合中添加数据，如果当前要添加元素不存在，方法返回true,表示添加成功。\n//        如果当前要添加的元素已经存在，方法返回fa1se,表示添加失败。\n//          因为Set系列的集合不允许重复。\n        coll.add(\"aaa\");\n        coll.add(\"bbb\");\n        coll.add(\"ccc\");\n\n        //2.清空\n        //col1.clear();\n//3.删除\n//注意：因为Collection里面定义的是共性的方法，所以此时不能通过索引进行删除。只能通过元素的对象进行删除。\n        System.out.println(coll.remove(\"aaa\"));\n        System.out.println(coll);\n        //4.判断元素是否包含\n        //细节：底层是依赖equals方法进行判断是否存在的。\n        //所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法。\n\n// 因为contains方法在底层依赖equals方法判断对象是否一致的。\n// 如果存的是自定义对象，没有重写equals方法，那么默认使用object:类中的equals方法进行判断，而Object类中equals方法，依赖地址值进行判断。\n// 需求：如果同姓名和同年龄，就认为是同一个学生。\n// 所以，需要在自定义的Javabean类中，重写equals方法就可以了。\n        boolean result = coll.contains(\"bbb\");\n        System.out.println(result);\n\n        //5.判断集合是否为空\n        boolean result2 = coll.isEmpty();\n        System.out.println(result2);//false\n\n        //6.获取集合的长度\n        coll.add(\"ddd\");\n        int size =  coll.size();\n        System.out.println(size);//3\n    }\n\n}\n\n```\n## Collection 的遍历方式\n### 迭代器遍历\n>迭代器不依赖索引 ,迭代器在Java中的类是Iterator,迭代器是集合专用的遍历方式。\n>\n\n- Collection集合获取迭代器\n\n\n    `Iterator<E> iterator()返回迭代器对象，默认指向当前集合的0索引`\n  - Iterator中的常用方法\n  ```java\nboolean hasNext() 判断当前位置是否有元素，有元素返回true,没有元素返回false\nE next() 获取当前位置的元素，并将迭代器对象移向下一个位置。\n\n\n细节注意点：\n1,报错NoSuchElementException\n2,迭代器遍历完毕，指针不会复位\n3,循环中只能用一次next方法\n4,迭代器遍历时，不能用集合的方法进行增加或者删除\n  ```\n  - 代码演示\n\n\n```java\npackage day_22;\n\nimport java.sql.Connection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class CollectionDemo2 {\n    public static void main(String[] args) {\n        //1.创建集合并添加元素\n        Collection<String> coll = new ArrayList<>();\n        coll.add(\"aaa\");\n        coll.add(\"bbb\");\n        coll.add(\"ccc\");\n        //2.获取迭代器对象\n        //迭代器就好比是一个箭头，默认指向集合的索引处\n        Iterator<String> iterator = coll.iterator();\n        //3.利用循环不断的去获取集合中的每一个元素\n        while (iterator.hasNext()){\n            String next = iterator.next();\n            //4.next方法的两件事情：获取元素并移动指针\n            System.out.println(next);\n        }\n\n        //当上面循环结束之后，迭代器的指针已经指向了最后没有元素的位置\n//System.out.println(it.next());//NoSuchElementException\n//迭代器遍历完毕，指针不会复位\n        System.out.println(iterator.hasNext());\n//如果我们要继续第二次遍历集合，只能再次获取一个新的迭代器对象\n        Iterator<String>it2 =  coll.iterator();\n        while(it2.hasNext()){\n            String str = it2.next();\n            System.out.println(str);\n        }\n\n        //        coll.add(\"aaa\");\n        //        coll.add(\"bbb\");\n        //        coll.add(\"ccc\");\n        //        coll.add(\"ddd\");\n        //        coll.add(\"eee\");\n        //3.利用循环不断的去获取集合中的每一个元素\n        while(it2.hasNext()){\n//4.next方法的两件事情：获取元素，并移动指针\n            System.out.println(it2.next());//aaa ccc  eee\n            System.out.println(it2.next());//bbb ddd NoSuchElementException\n        }\n\n        while(it2.hasNext()){\n            String str = it2.next();\n            System.out.println(str);\n            //coll.remove(\"bbb\");  不可以删除，报并发错误\n            it2.remove(); // 可以删除\n        }\n\n\n\n    }\n\n}\n\n```\n\n### 增强for遍历\n\n- 普通for只能用在List系列，而在Set系列是用不了的\n```java\npackage day_22;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class CollectionDemo3 {\n    public static void main(String[] args) {\n        /*\n增强for格式：\nfor(数据类型变量名：集合/数组){}\n*/\n//1.创建集合并添加元素\n        Collection<String> coll = new ArrayList<>();\n        coll.add(\"zhangsan\");\n        coll.add(\"lisi\");\n        coll.add(\"wangwu\");\n//2.利用增强for进行遍历\n//注意点：\n//s其实就是一个第三方变量，在循环的过程中依次表示集合中的每一个数据\n        // 增强for的细节\n        //修改增强for中的变量，不会改变集合中原本的数据。\n        for(String s : coll){\n            System.out.println(s);\n        }\n    }\n\n}\n\n```\n\n### lambda表达式遍历\n```java\npackage day_22;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class CollectionDemo4 {\n    public static void main(String[] args) {\n        //集合并添加元素\n        Collection<String> coll = new ArrayList<>();\n        coll.add(\"zhangsan\");\n        coll.add(\"lisi\");\n        coll.add(\"wangwu\");\n        //2.利用匿名内部类的形式\n//底层原理：\n//其实也会自己遍历集合，依次得到每一个元素\n//把得到的每一个元素，传递给下面的accept方法\n//s依次表示集合中的每一个数据\n/*\ncoll.forEach(new Consumer<String>(){\n@override\npublic void accept(String s){\nSystem.out.println(s);\n}\n});\n*/\n//lambda表达式\n        coll.forEach(s -> System.out.println(s));\n    }\n\n}\n\n```\n## List 中常见方法\n```java\npackage day_22;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CollectionDemo5 {\n    public static void main(String[] args) {\n        /*\n        List系列集合独有的方法：\n          void add(int index,E element)     在此集合中的指定位置插入指定的元素\n          E remove(int index)                删除指定索引处的元素，返回被删除的元素\n          E set(int index,E element)          修改指定索引处的元素，返回被修改的元素\n          E get(int index)                      返回指定索引处的元素\n         */\n\n        // 创建一个集合\n        List<String> list = new ArrayList<>();\n        list.add(\"aaa\");\n        list.add(\"bbb\");\n        list.add(\"ccc\");\n        list.add(\"ddd\");\n        //在此集合中的指定位置插入指定的元素\n        list.add(1, \"qqq\");\n        System.out.println(list);\n        System.out.println(list.remove(1));\n\n\n        //Lst系列集合中的两个别除的方法\n        //1.直接删除元素\n        //2.通过索引进行删除\n        //1.创建集合并添加元素\n        List<Integer> list1 =  new ArrayList<>();\n        list1.add(1);\n        list1.add(2);\n        list1.add(3);\n\n\n        //2.删除元素\n        //请问：此时删除的是1这个元素，还是1索引上的元素？\n        //为什么？\n        //因为在调用方法的时候，如果方法出现了重载现象\n        //优先调用，实参跟形参类型一致的那个方法。\n        //list1.remove(1);\n\n        //手动装箱，手动把基本数据类型的1，变成Integer类型\n        Integer i = Integer.valueOf(1);\n        list1.remove(i);\n        System.out.println(list1);\n\n    }\n}\n\n```\n\n## List集合的遍历方式\n\n- 迭代器遍历  -----在遍历的过程中需要删除元素，请使用迭代器。\n- 列表迭代器遍历 ------ 在遍历的过程中需要添加元素，请使用列表迭代器。\n- 增强for遍历    -------- 仅仅想遍历，那么使用增强for或Lambda表达式。\n- Lambda表达式遍历 -------- 仅仅想遍历，那么使用增强for或Lambda表达式。\n- 普通for循环（因为List集合存在索引) ------- 如果遍历的时候想操作索引，可以用普通for。\n\n```java\npackage day_22;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.function.Consumer;\n\npublic class CollectionDemo7 {\n    public static void main(String[] args) {\n        /*\n        List系列集合的五种遍历方式：\n        1.迭代器\n        2.列表迭代器\n        3.增强for\n        4.Lambda表达式\n        5.普通for循环\n         */\n        List<String> list = new ArrayList<>();\n        list.add(\"aaa\");\n        list.add(\"bbb\");\n        list.add(\"ccc\");\n\n        // 迭代器\n        Iterator<String> iterator = list.iterator();\n        while (iterator.hasNext()){\n            String s = iterator.next();\n            //System.out.println(s);\n        }\n        \n        // 增强for\n        for (String s : list) {\n            //System.out.println(s);\n        }\n        //lambda表达式\n        //list.forEach(s -> System.out.println(s));\n        \n        // 普通for形式\n        for (int i = 0; i < list.size(); i++) {\n            String s = list.get(i);\n            //System.out.println(s);\n        }\n\n        // 列表迭代器\n        ListIterator<String> it = list.listIterator();\n        while (it.hasNext()){\n            String next = it.next();\n            if (\"bbb\".equals(next)){\n                it.add(\"qqq\");\n            }\n        }\n        System.out.println(list);\n    }\n\n}\n\n```\n\n\n\n\n\n# Set 系列集合\n\n> 添加的元素是无序，不重复，无索引\n\n- 无序：表示存进去的元素，按相同的顺序取出来可能是不一样的\n- 不重复：表示集合中元素是**不可以**重复的\n- 无索引：不可以通过索引获取集合中每个元素","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"ArrayList-day22","url":"/2023/01/29/ArrayList/","content":"# ArrayList\n\n1. 利用空参创建的集合，在底层创建一个默认长度为0的数组\n2. 添加第一个元素时，底层会创建一个新的长度为10的数组\n3. 存满时，会扩容1.5倍![](https://pic.imgdb.cn/item/63d68121face21e9ef33796f.jpg)\n\n![](https://pic.imgdb.cn/item/63d683efface21e9ef3b61a9.jpg)","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"数据结构-day22","url":"/2023/01/29/数据结构/","content":"# 数据结构\n\n\n## 数据结构概述\n\n数据结构是计算机底层存储、组织数据的方式。\n是指数据相互之间是以什么方式排列在一起的。\n数据结构是为了更加方便的管理和使用数据，需要结合具体的业务场景来进行选择。\n一般情况下，精心选择的数据结构可以带来更高的运行或者存储效率。\n\n## 链表\n\n链表中的结点是独立的对象，在内存中是不连续的，每个结点包含数据值和下一个结点的地址。  \n\n链表查询慢，无论查询哪个数据都要从头开始找。  \n\n链表增删相对快\n\n## 各种数据结构的特点和作用是什么样的\n* 栈：后进先出，先进后出。\n* 队列：先进先出，后进后出。\n* 数组：内存连续区域，查询快，增删慢。\n* 链表：无素是游离的，查询慢，首尾操作极快。","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"算法","url":"/2023/01/27/算法/","content":"# 常见的七种查找算法：\n\n​\t数据结构是数据存储的方式，算法是数据计算的方式。所以在开发中，算法和数据结构息息相关。今天的讲义中会涉及部分数据结构的专业名词，如果各位铁粉有疑惑，可以先看一下哥们后面录制的数据结构，再回头看算法。\n\n## 1. 基本查找 \n\n​\t也叫做顺序查找\n\n​        说明：顺序查找适合于存储结构为数组或者链表。\n\n**基本思想**：顺序查找也称为线形查找，属于无序查找算法。从数据结构线的一端开始，顺序扫描，依次将遍历到的结点与要查找的值相比较，若相等则表示查找成功；若遍历结束仍没有找到相同的，表示查找失败。\n\n示例代码：\n\n```java\npublic class A01_BasicSearchDemo1 {\n    public static void main(String[] args) {\n        //基本查找/顺序查找\n        //核心：\n        //从0索引开始挨个往后查找\n\n        //需求：定义一个方法利用基本查找，查询某个元素是否存在\n        //数据如下：{131, 127, 147, 81, 103, 23, 7, 79}\n\n\n        int[] arr = {131, 127, 147, 81, 103, 23, 7, 79};\n        int number = 82;\n        System.out.println(basicSearch(arr, number));\n\n    }\n\n    //参数：\n    //一：数组\n    //二：要查找的元素\n\n    //返回值：\n    //元素是否存在\n    public static boolean basicSearch(int[] arr, int number){\n        //利用基本查找来查找number在数组中是否存在\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] == number){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n## 2. 二分查找\n\n​\t也叫做折半查找\n\n说明：元素必须是有序的，从小到大，或者从大到小都是可以的。\n\n如果是无序的，也可以先进行排序。但是排序之后，会改变原有数据的顺序，查找出来元素位置跟原来的元素可能是不一样的，所以排序之后再查找只能判断当前数据是否在容器当中，返回的索引无实际的意义。\n\n　　**基本思想**：也称为是折半查找，属于有序查找算法。用给定值先与中间结点比较。比较完之后有三种情况：\n\n* 相等\n\n  说明找到了\n\n* 要查找的数据比中间节点小\n\n  说明要查找的数字在中间节点左边\n\n* 要查找的数据比中间节点大\n\n  说明要查找的数字在中间节点右边\n\n代码示例：\n\n```java\npackage com.itheima.search;\n\npublic class A02_BinarySearchDemo1 {\n    public static void main(String[] args) {\n        //二分查找/折半查找\n        //核心：\n        //每次排除一半的查找范围\n\n        //需求：定义一个方法利用二分查找，查询某个元素在数组中的索引\n        //数据如下：{7, 23, 79, 81, 103, 127, 131, 147}\n\n        int[] arr = {7, 23, 79, 81, 103, 127, 131, 147};\n        System.out.println(binarySearch(arr, 150));\n    }\n\n    public static int binarySearch(int[] arr, int number){\n        //1.定义两个变量记录要查找的范围\n        int min = 0;\n        int max = arr.length - 1;\n\n        //2.利用循环不断的去找要查找的数据\n        while(true){\n            if(min > max){\n                return -1;\n            }\n            //3.找到min和max的中间位置\n            int mid = (min + max) / 2;\n            //4.拿着mid指向的元素跟要查找的元素进行比较\n            if(arr[mid] > number){\n                //4.1 number在mid的左边\n                //min不变，max = mid - 1；\n                max = mid - 1;\n            }else if(arr[mid] < number){\n                //4.2 number在mid的右边\n                //max不变，min = mid + 1;\n                min = mid + 1;\n            }else{\n                //4.3 number跟mid指向的元素一样\n                //找到了\n                return mid;\n            }\n\n        }\n    }\n}\n```\n\n## 3. 插值查找\n\n在介绍插值查找之前，先考虑一个问题：\n\n​\t为什么二分查找算法一定要是折半，而不是折四分之一或者折更多呢？\n\n其实就是因为方便，简单，但是如果我能在二分查找的基础上，让中间的mid点，尽可能靠近想要查找的元素，那不就能提高查找的效率了吗？\n\n二分查找中查找点计算如下：\n\n　　mid=(low+high)/2, 即mid=low+1/2*(high-low);\n\n我们可以将查找的点改进为如下：\n\n　　mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，\n\n这样，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。\n\n　　基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。\n\n**细节：**对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。\n\n代码跟二分查找类似，只要修改一下mid的计算方式即可。\n\n\n\n## 4. 斐波那契查找\n\n在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。\n\n　　黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。\n\n　　0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。\n\n　　在数学中有一个非常有名的数学规律：斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….\n\n（从第三个数开始，后边每一个数都是前两个数的和）。\n\n然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。\n\n![img](https://img-blog.csdn.net/20150323100632467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlbmJvMjAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) \n\n基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。\n\n斐波那契查找也是在二分查找的基础上进行了优化，优化中间点mid的计算方式即可\n\n代码示例：\n\n```java\npublic class FeiBoSearchDemo {\n    public static int maxSize = 20;\n\n    public static void main(String[] args) {\n        int[] arr = {1, 8, 10, 89, 1000, 1234};\n        System.out.println(search(arr, 1234));\n    }\n\n    public static int[] getFeiBo() {\n        int[] arr = new int[maxSize];\n        arr[0] = 1;\n        arr[1] = 1;\n        for (int i = 2; i < maxSize; i++) {\n            arr[i] = arr[i - 1] + arr[i - 2];\n        }\n        return arr;\n    }\n\n    public static int search(int[] arr, int key) {\n        int low = 0;\n        int high = arr.length - 1;\n        //表示斐波那契数分割数的下标值\n        int index = 0;\n        int mid = 0;\n        //调用斐波那契数列\n        int[] f = getFeiBo();\n        //获取斐波那契分割数值的下标\n        while (high > (f[index] - 1)) {\n            index++;\n        }\n        //因为f[k]值可能大于a的长度，因此需要使用Arrays工具类，构造一个新法数组，并指向temp[],不足的部分会使用0补齐\n        int[] temp = Arrays.copyOf(arr, f[index]);\n        //实际需要使用arr数组的最后一个数来填充不足的部分\n        for (int i = high + 1; i < temp.length; i++) {\n            temp[i] = arr[high];\n        }\n        //使用while循环处理，找到key值\n        while (low <= high) {\n            mid = low + f[index - 1] - 1;\n            if (key < temp[mid]) {//向数组的前面部分进行查找\n                high = mid - 1;\n                /*\n                  对k--进行理解\n                  1.全部元素=前面的元素+后面的元素\n                  2.f[k]=k[k-1]+f[k-2]\n                  因为前面有k-1个元素没所以可以继续分为f[k-1]=f[k-2]+f[k-3]\n                  即在f[k-1]的前面继续查找k--\n                  即下次循环,mid=f[k-1-1]-1\n                 */\n                index--;\n            } else if (key > temp[mid]) {//向数组的后面的部分进行查找\n                low = mid + 1;\n                index -= 2;\n            } else {//找到了\n                //需要确定返回的是哪个下标\n                if (mid <= high) {\n                    return mid;\n                } else {\n                    return high;\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n## 5. 分块查找 \n\n当数据表中的数据元素很多时，可以采用分块查找。\n\n汲取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找\n\n分块查找适用于数据较多，但是数据不会发生变化的情况，如果需要一边添加一边查找，建议使用哈希查找\n\n分块查找的过程：\n\n1. 需要把数据分成N多小块，块与块之间不能有数据重复的交集。\n2. 给每一块创建对象单独存储到数组当中\n3. 查找数据的时候，先在数组查，当前数据属于哪一块\n4. 再到这一块中顺序查找\n\n代码示例：\n\n```java\npackage com.itheima.search;\n\npublic class A03_BlockSearchDemo {\n    public static void main(String[] args) {\n        /*\n            分块查找\n            核心思想：\n                块内无序，块间有序\n            实现步骤：\n                1.创建数组blockArr存放每一个块对象的信息\n                2.先查找blockArr确定要查找的数据属于哪一块\n                3.再单独遍历这一块数据即可\n        */\n        int[] arr = {16, 5, 9, 12,21, 18,\n                     32, 23, 37, 26, 45, 34,\n                     50, 48, 61, 52, 73, 66};\n\n        //创建三个块的对象\n        Block b1 = new Block(21,0,5);\n        Block b2 = new Block(45,6,11);\n        Block b3 = new Block(73,12,17);\n\n        //定义数组用来管理三个块的对象（索引表）\n        Block[] blockArr = {b1,b2,b3};\n\n        //定义一个变量用来记录要查找的元素\n        int number = 37;\n\n        //调用方法，传递索引表，数组，要查找的元素\n        int index = getIndex(blockArr,arr,number);\n\n        //打印一下\n        System.out.println(index);\n\n\n\n    }\n\n    //利用分块查找的原理，查询number的索引\n    private static int getIndex(Block[] blockArr, int[] arr, int number) {\n        //1.确定number是在那一块当中\n        int indexBlock = findIndexBlock(blockArr, number);\n\n        if(indexBlock == -1){\n            //表示number不在数组当中\n            return -1;\n        }\n\n        //2.获取这一块的起始索引和结束索引   --- 30\n        // Block b1 = new Block(21,0,5);   ----  0\n        // Block b2 = new Block(45,6,11);  ----  1\n        // Block b3 = new Block(73,12,17); ----  2\n        int startIndex = blockArr[indexBlock].getStartIndex();\n        int endIndex = blockArr[indexBlock].getEndIndex();\n\n        //3.遍历\n        for (int i = startIndex; i <= endIndex; i++) {\n            if(arr[i] == number){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n\n    //定义一个方法，用来确定number在哪一块当中\n    public static int findIndexBlock(Block[] blockArr,int number){ //100\n\n\n        //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的\n        for (int i = 0; i < blockArr.length; i++) {\n            if(number <= blockArr[i].getMax()){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n\n\n}\n\nclass Block{\n    private int max;//最大值\n    private int startIndex;//起始索引\n    private int endIndex;//结束索引\n\n\n    public Block() {\n    }\n\n    public Block(int max, int startIndex, int endIndex) {\n        this.max = max;\n        this.startIndex = startIndex;\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * 获取\n     * @return max\n     */\n    public int getMax() {\n        return max;\n    }\n\n    /**\n     * 设置\n     * @param max\n     */\n    public void setMax(int max) {\n        this.max = max;\n    }\n\n    /**\n     * 获取\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * 设置\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * 获取\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * 设置\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    public String toString() {\n        return \"Block{max = \" + max + \", startIndex = \" + startIndex + \", endIndex = \" + endIndex + \"}\";\n    }\n}\n```\n\n## 6. 哈希查找\n\n哈希查找是分块查找的进阶版，适用于数据一边添加一边查找的情况。\n\n一般是数组 + 链表的结合体或者是数组+链表 + 红黑树的结合体\n\n在课程中，为了让大家方便理解，所以规定：\n\n- 数组的0索引处存储1~100\n- 数组的1索引处存储101~200\n- 数组的2索引处存储201~300\n- 以此类推\n\n但是实际上，我们一般不会采取这种方式，因为这种方式容易导致一块区域添加的元素过多，导致效率偏低。\n\n更多的是先计算出当前数据的哈希值，用哈希值跟数组的长度进行计算，计算出应存入的位置，再挂在数组的后面形成链表，如果挂的元素太多而且数组长度过长，我们也会把链表转化为红黑树，进一步提高效率。\n\n具体的过程，大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了哈希表的数据结构。全程采取动画形式讲解，让大家一目了然。\n\n在此不多做阐述。\n\n ![Snipaste_2022-09-05_21-36-50](F:/JavaSE%E6%9C%80%E6%96%B0%E7%89%88/day21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/%E7%AC%94%E8%AE%B0/img/Snipaste_2022-09-05_21-36-50.png)\n\n## 7. 树表查找 \n\n本知识点涉及到数据结构：树。\n\n建议先看一下后面阿玮讲解的数据结构，再回头理解。\n\n基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 \n\n　　二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree），具有下列性质的二叉树：\n\n　　1）若任意节点左子树上所有的数据，均小于本身；\n\n　　2）若任意节点右子树上所有的数据，均大于本身；\n\n　　二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。\n\n​        不同形态的二叉查找树如下图所示：\n\n ![20180226113852869](img\\20180226113852869.png) \n\n\n\n　　基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。\n\n具体细节大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了树数据结构。全程采取动画形式讲解，让大家一目了然。\n\n在此不多做阐述。\n\n​\t不管是二叉查找树，还是平衡二叉树，还是红黑树，查找的性能都比较高\n\n\n\n\n\n\n\n# 十大排序算法：\n\n## 1. 冒泡排序\n\n冒泡排序（Bubble Sort）也是一种简单直观的排序算法。\n\n它重复的遍历过要排序的数列，一次比较相邻的两个元素，如果他们的顺序错误就把他们交换过来。\n\n这个算法的名字由来是因为越大的元素会经由交换慢慢\"浮\"到最后面。\n\n当然，大家可以按照从大到小的方式进行排列。\n\n### 1.1 算法步骤\n\n1. 相邻的元素两两比较，大的放右边，小的放左边\n2. 第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推\n3. 如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以\n\n### 1.2 动图演示\n\n![冒泡](F:\\JavaSE最新版\\day21-API（算法，lambda，练习）\\笔记\\img\\冒泡.gif)\n\n### 1.3 代码示例\n\n```java\npublic class A01_BubbleDemo {\n    public static void main(String[] args) {\n        /*\n            冒泡排序：\n            核心思想：\n            1，相邻的元素两两比较，大的放右边，小的放左边。\n            2，第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。\n            3，如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。\n        */\n\n\n        //1.定义数组\n        int[] arr = {2, 4, 5, 3, 1};\n\n        //2.利用冒泡排序将数组中的数据变成 1 2 3 4 5\n\n        //外循环：表示我要执行多少轮。 如果有n个数据，那么执行n - 1 轮\n        for (int i = 0; i < arr.length - 1; i++) {\n            //内循环：每一轮中我如何比较数据并找到当前的最大值\n            //-1：为了防止索引越界\n            //-i：提高效率，每一轮执行的次数应该比上一轮少一次。\n            for (int j = 0; j < arr.length - 1 - i; j++) {\n                //i 依次表示数组中的每一个索引：0 1 2 3 4\n                if(arr[j] > arr[j + 1]){\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n\n        printArr(arr);\n\n\n\n\n    }\n\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n\n\n## 2. 选择排序\n\n### 2.1 算法步骤\n\n1. 从0索引开始，跟后面的元素一一比较\n2. 小的放前面，大的放后面\n3. 第一次循环结束后，最小的数据已经确定\n4. 第二次循环从1索引开始以此类推\n5. 第三轮循环从2索引开始以此类推\n6. 第四轮循环从3索引开始以此类推。 \n\n### 2.2 动图演示\n\n![选择排序](img\\选择排序.gif)\n\n \n\n```java\npublic class A02_SelectionDemo {\n    public static void main(String[] args) {\n\n        /*\n            选择排序：\n                1，从0索引开始，跟后面的元素一一比较。\n                2，小的放前面，大的放后面。\n                3，第一次循环结束后，最小的数据已经确定。\n                4，第二次循环从1索引开始以此类推。\n\n         */\n\n\n        //1.定义数组\n        int[] arr = {2, 4, 5, 3, 1};\n\n\n        //2.利用选择排序让数组变成 1 2 3 4 5\n       /* //第一轮：\n        //从0索引开始，跟后面的元素一一比较。\n        for (int i = 0 + 1; i < arr.length; i++) {\n            //拿着0索引跟后面的数据进行比较\n            if(arr[0] > arr[i]){\n                int temp = arr[0];\n                arr[0] = arr[i];\n                arr[i] = temp;\n            }\n        }*/\n\n        //最终代码：\n        //外循环：几轮\n        //i:表示这一轮中，我拿着哪个索引上的数据跟后面的数据进行比较并交换\n        for (int i = 0; i < arr.length -1; i++) {\n            //内循环：每一轮我要干什么事情？\n            //拿着i跟i后面的数据进行比较交换\n            for (int j = i + 1; j < arr.length; j++) {\n                if(arr[i] > arr[j]){\n                    int temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n\n\n        printArr(arr);\n\n\n    }\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n}\n\n```\n\n\n\n## 3. 插入排序\n\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过创建有序序列和无序序列，然后再遍历无序序列得到里面每一个数字，把每一个数字插入到有序序列中正确的位置。\n\n插入排序在插入的时候，有优化算法，在遍历有序序列找正确位置时，可以采取二分查找\n\n### 3.1 算法步骤\n\n将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。\n\n遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\n\nN的范围：0~最大索引\n\n### 3.2 动图演示\n\n![插入排序](img\\插入排序.gif)\n\n```java\npackage com.itheima.mysort;\n\n\npublic class A03_InsertDemo {\n    public static void main(String[] args) {\n        /*\n            插入排序：\n                将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。\n                遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\n                N的范围：0~最大索引\n\n        */\n        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};\n\n        //1.找到无序的哪一组数组是从哪个索引开始的。  2\n        int startIndex = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] > arr[i + 1]){\n                startIndex = i + 1;\n                break;\n            }\n        }\n\n        //2.遍历从startIndex开始到最后一个元素，依次得到无序的哪一组数据中的每一个元素\n        for (int i = startIndex; i < arr.length; i++) {\n            //问题：如何把遍历到的数据，插入到前面有序的这一组当中\n\n            //记录当前要插入数据的索引\n            int j = i;\n\n            while(j > 0 && arr[j] < arr[j - 1]){\n                //交换位置\n                int temp = arr[j];\n                arr[j] = arr[j - 1];\n                arr[j - 1] = temp;\n                j--;\n            }\n\n        }\n        printArr(arr);\n    }\n\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n}\n\n```\n\n\n\n\n\n## 4. 快速排序 \n\n快速排序是由东尼·霍尔所发展的一种排序算法。\n\n快速排序又是一种分而治之思想在排序算法上的典型应用。\n\n快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！\n\n它是处理大数据最快的排序算法之一了。\n\n### 4.1 算法步骤\n\n1. 从数列中挑出一个元素，一般都是左边第一个数字，称为 \"基准数\";\n2. 创建两个指针，一个从前往后走，一个从后往前走。\n3. 先执行后面的指针，找出第一个比基准数小的数字\n4. 再执行前面的指针，找出第一个比基准数大的数字\n5. 交换两个指针指向的数字\n6. 直到两个指针相遇\n7. 将基准数跟指针指向位置的数字交换位置，称之为：基准数归位。\n8. 第一轮结束之后，基准数左边的数字都是比基准数小的，基准数右边的数字都是比基准数大的。\n9. 把基准数左边看做一个序列，把基准数右边看做一个序列，按照刚刚的规则递归排序\n\n### 4.2 动图演示\n\n![快速排序](img\\快速排序.gif)\n\n ```java\npackage com.itheima.mysort;\n\nimport java.util.Arrays;\n\npublic class A05_QuickSortDemo {\n    public static void main(String[] args) {\n        System.out.println(Integer.MAX_VALUE);\n        System.out.println(Integer.MIN_VALUE);\n      /*\n        快速排序：\n            第一轮：以0索引的数字为基准数，确定基准数在数组中正确的位置。\n            比基准数小的全部在左边，比基准数大的全部在右边。\n            后面以此类推。\n      */\n\n        int[] arr = {1,1, 6, 2, 7, 9, 3, 4, 5, 1,10, 8};\n\n\n        //int[] arr = new int[1000000];\n\n       /* Random r = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = r.nextInt();\n        }*/\n\n\n        long start = System.currentTimeMillis();\n        quickSort(arr, 0, arr.length - 1);\n        long end = System.currentTimeMillis();\n\n        System.out.println(end - start);//149\n\n        System.out.println(Arrays.toString(arr));\n        //课堂练习：\n        //我们可以利用相同的办法去测试一下，选择排序，冒泡排序以及插入排序运行的效率\n        //得到一个结论：快速排序真的非常快。\n\n       /* for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }*/\n\n    }\n\n\n    /*\n     *   参数一：我们要排序的数组\n     *   参数二：要排序数组的起始索引\n     *   参数三：要排序数组的结束索引\n     * */\n    public static void quickSort(int[] arr, int i, int j) {\n        //定义两个变量记录要查找的范围\n        int start = i;\n        int end = j;\n\n        if(start > end){\n            //递归的出口\n            return;\n        }\n\n\n\n        //记录基准数\n        int baseNumber = arr[i];\n        //利用循环找到要交换的数字\n        while(start != end){\n            //利用end，从后往前开始找，找比基准数小的数字\n            //int[] arr = {1, 6, 2, 7, 9, 3, 4, 5, 10, 8};\n            while(true){\n                if(end <= start || arr[end] < baseNumber){\n                    break;\n                }\n                end--;\n            }\n            System.out.println(end);\n            //利用start，从前往后找，找比基准数大的数字\n            while(true){\n                if(end <= start || arr[start] > baseNumber){\n                    break;\n                }\n                start++;\n            }\n\n\n\n            //把end和start指向的元素进行交换\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n        }\n\n        //当start和end指向了同一个元素的时候，那么上面的循环就会结束\n        //表示已经找到了基准数在数组中应存入的位置\n        //基准数归位\n        //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换\n        int temp = arr[i];\n        arr[i] = arr[start];\n        arr[start] = temp;\n\n        //确定6左边的范围，重复刚刚所做的事情\n        quickSort(arr,i,start - 1);\n        //确定6右边的范围，重复刚刚所做的事情\n        quickSort(arr,start + 1,j);\n\n    }\n}\n ```\n\n\n\n其他排序方式待更新~","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"Arrays-day21","url":"/2023/01/26/Arrays总结/","content":"# Arrays\n\n操作数组的工具类\n\n## Api\n```java\n//toString:将数组变成字符串\npublic static String toString(数组)\t\t把数组拼接成一个字符串\n    //binarySearch:二分查找法查找元素\n//细节1：二分查找的前提：数组中的元素必须是有序，数组中的元素必须是升序的\n//细节2：如果要查找的元素是存在的，那么返回的是真实的索引\n//但是，如果要查找的元素是不存在的，返回的是-插入点-1\n//疑问：为什么要减1呢？\n//解释：如果此时，我现在要查找数字©，那么如果返回的值是-插入点，就会出现问题了。\n//如果要查找数字6，此时©是不存在的，但是按照上面的规则-插入点，应该就是-日\n//为了避免这样的情况，Java在这个基础上又减一。\n    \npublic static int binarySearch(数组，查找的元素)\t\t二分查找法查找元素\n    //copy0f:拷贝数组\n//参数一：老数组\n//参数二：新数组的长度\n//方法的底层会根据第二个参数来创建新的数组\n//如果新数组的长度是小于老数组的长度，会部分拷贝\n//如果新数组的长度是等于老数组的长度，会完全拷贝\n//如果新数组的长度是大于老数组的长度，会补上默认初始值\npublic static int[]copyOf(原数组，新数组长度)\t拷贝数组\n    //copyOfRange:拷贝数组（指定范围）\n//细节：包头不包尾，包左不包右\npublic static int[]copyofRange(原数组，起始索引，结束索引)\t拷贝数组（指定范围）\n    //fi11:填充数组\npublic static void fi11(数组，元素)\t\t填充数组\npublic static void sort(数组)\t\t按照默认方式进行数组排序\n//第二个参数是一个接口，所以我们在调用方法的时候，需要传递这个接口的实现类对象，作为排序的规则。\n//但是这个实现类，我只要使用一次，所以就没有必要单独的去写一个类，直接采取匿名内部类的方式就可以了\n    \n//底层原理：\n//利用插入排序+二分查找的方式进行排序的。\n//默认把索引的数据当做是有序的序列，1索引到最后认为是无序的序列。\n//遍历无序的序列得到里面的每一个元素，假设当前遍历得到的元素是A元素\n//把A往有序序列中进行插入，在插入的时候，是利用二分查找确定A元素的插入点。\n//拿着A元素，跟插入点的元素进行比较，比较的规则就是compare方法的方法体\n//如果方法的返回值是负数，拿着A继续跟前面的数据进行比较\n//如果方法的返回值是正数，拿着A继续跟后面的数据进行比较\n//如果方法的返回值是，也拿着A跟后面的数据进行比较\n//直到能确定A的最终位置为止。\n    \n//compare方法的形式参数：\n//参数一o1:表示在无序序列中，遍历得到的每一个元素\n//参数二o2:有序序列中的元素\n    \n//返回值：\n//负数：表示当前要插入的元素是小的，放在前面\n//正数：表示当前要插入的元素是大的，放在后面\n//0表示当前要插入的元素跟现在的元素比是一样的们也会放在后面\n    \n //简单理解：\n//o1-o2:升序排列\n//o2-o1:降序排序\npublic static void sort(数组，排序规则)\t\t按照指定的规则排序\nArrays.sort(arr,new Comparator<Integer>(){\n@Override\npublic int compare(Integer o1,Integer o2){\nreturn 0;\n});\n   \n```\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"lambda-day21","url":"/2023/01/26/lambda总结/","content":"# lambda表达式\n## 函数式编程\n- 函数式编程(Functional programming)是一种思想特点。\n- 函数式编程思想，忽略面向对象的复杂语法，强调做什么，而不是谁去做。\n- 而我们要学习的Lambda表达式就是函数式思想的体现。\n## 注意点\n- Lambda表达式可以用来简化匿名内部类的书写\n- Lambda表达式只能简化**函数式接口**的匿名内部类的写法\n- ():代表形参\n- ->:固定格式\n- {}:代表方法体\n## 函数式接口：\n- 有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@Functionallnterface注解\n## Lambda表达式的标准格式\n- Lambda表达式是JDK8开始后的一种新语法形式。\n\n## Lambda表达式的基本作用？\n- 简化函数式接口的匿名内部类的写法。\n## Lambda表达式有什么使用前提？\n- 必须是接口的匿名内部类，接口中只能有一个抽象方法\n## Lambda的好处？\n- Lambda是一个匿名函数，我们可以把Lambda.表达式理解为是一段可以传递的代码，它可以写出更简洁、更灵活的代码，作为一种更紧凑的代码风格，使Java语言表达能力得到了提升。\n## lambda的省略规则：\n1. 参数类型可以省略不写。\n2. 如果只有一个参数，参数类型可以省略，同时()也可以省略。\n3. 如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略。\n```java\n\tmethod(new Swim(){\n\t\t@Override\n\t\tpublic void swimming(){\n\t\t\tSystem.out.println(\"正在游泳~~~\")；\n\t\t\t\t}\n});\n//  利用lambda表达式进行简写\n\tmethod(\n\t\t\t()->{\n\t\t\t\tSystem.out.println(\"正在游泳~~\")；\n\t\t\t\t}\n\t\t);\n\n\tpublic static void method(Swim s){\n\t\ts.swimming();\n\t}\n\ninterface Swim{\n\tpublic abstract void swimming();\n}\n```\n***\n```java\npublic static void main(String[] args) {\n        Integer[] arr = {3,2,1};\n        // 不使用lambda写法\n        Arrays.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o1 - o2;\n            }\n        });\n\n        // lambda完整写法\n        Arrays.sort(arr, (Integer o1, Integer o2)->{\n                return o1 - o2;\n            }\n        );\n        \n    // lambda省略写法\n        Arrays.sort(arr, (o1, o2) -> o1 - o2);\n        System.out.println(Arrays.toString(arr));\n    }\n\n```\n***\n```java\n    /*\n            定义数组并存储一些字符串，利用Arrays中的sort方法进行排序\n            要求：\n            按照字符串的长度进行排序，短的在前面，长的在后面。\n            (暂时不比较字符串里面的内容)\n             */\n        String[] arr = {\"a\", \"aaaa\", \"aaa\", \"aa\"};\n        \n            // 如果以后我们要把数组中的数据按照指定的方式进行排列，就需要用到sot方法，而且要指定排序的规则\n        Arrays.sort(arr, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                    // 字符串的长度进行排序\n                return o1.length() - o2.length();\n            }\n        });\n\n\t\t //Lambda完整格式\n        Arrays.sort(arr,(String o1,String o2)-> {\n            return o1.length() - o2.length();\n        }\n        );\n\n        //Lambda简写格式\n        //小括号：数据类型可以省略，如果参数只有一个，小括号还可以省略\n        //大括号：如果方法体只有一行，return,分号，大括号都可以省略\n        Arrays.sort(arr,(o1,o2)->o1.length()-o2.length());\n\n        \n            //打印数组\n        System.out.println(Arrays.toString(arr));\n```\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"查找-day21","url":"/2023/01/26/学习总结_04/","content":"# 七种查找方式\n- 基本查找，二分查找，插值查找，斐波那契额查找\n- 分块查找，哈希查找\n- 树表查找\n# 二分查找\n## 二分查找的优势？  \n​\t提升查找效率\n\n## 二分查找的前提条件？\n​\t数据必须是有序的\n\n## 二分查找的过程\n\n - min和max表示当前查找的范围\n - mid是在min和max中间的\n - 如果查找的元素在mid的左边，缩小范围时，min不变，max等于mid减1\n - 如果查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1\n - 如果mid等于要查找的值，则说明找到了\n## 二分查找，插值查找，斐波那契额查询的各自特点\n- 相同点\n\t- 都是通过不断缩小范围来查找对应的数据的\n- 不同点\n\t- 计算mid的方式不一样\n### 二分查找：\n> mid每次都指向范围的中间位置\n\n### 插值查找：\n> mid尽可能的靠近要查找的数据，但是要求数据尽可能的分布均匀\n\n### 斐波那契额查找： 利用黄金比例算mid指向的位置\n# 分块查找\n\n## 分块的原则\n\n- 前一块中的最大数据，小于后一块中的所有数据（块内无序，块间有序）\n- 块数数量一般等于数字的个数开根号。比如16个数字一般分为4块左右\n\n## 核心思路\n\n> 先确定要查找的元素在哪一块，然后在块内挨个查找","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"排序-day21","url":"/2023/01/26/排序总结/","content":"# 递归算法\n## 递归算法的作用\n- 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。\n递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n## 书写递归的两个核心\n- 找出口：什么时候不在调用方法\n- 找规则：如何把大问题变成规模较小的问题\n# 排序\n- 冒泡排序、选择排序、插入排序、快速排序\n- 希尔排序、堆排序、桶排序、归并排序、计数排序、基数排序\n## 冒泡排序\n- 相邻的数据两两比较，小的放前面，大的放后面。\n## 选择排序\n- 从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面，以此类推\n## 插入排序\n- 将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。\n遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\nN的范围：0~最大索引\n## 快速排序\n> 第一轮：把0索引的数字作为基准数，确定基准数在数组中正确的位置。比基准数小的全部在左边，比基准数大的全部在右边。\n- 将排序范围中的第一个数字作为基准数，再定义两个变量start,end\n- start,从前往后找比基准数大的，end从后往前找比基准数小的。\n- 找到之后交换start和end指向的元素，并循环这一过程，直到start和end处于同一个位置，该位置是基准数在数组中应存入的位置，再让基准数归位。\n- 归位后的效果：基准数左边的，比基准数小，基准数右边的，比基准数大","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"Date","url":"/2023/01/24/Date/","content":"# day04【常用API】\n\n## 今日内容\n\n* JDK7时间相关类\n* JDK8时间相关类\n* 包装类\n* 综合练习\n* Collection集合\n\n## 教学目标\n\n- [ ] 能够使用日期类输出当前日期\n- [ ] 能够使用将日期格式化为字符串的方法\n- [ ] 能够使用将字符串转换成日期的方法\n- [ ] 能够说出8种基本类型对应的包装类名称\n- [ ] 能够说出自动装箱、自动拆箱的概念\n- [ ] 能够将字符串转换为对应的基本类型\n- [ ] 能够将基本类型转换为对应的字符串\n- [ ] 能够完成课题上讲解的所有练习\n\n# 第一章 Date类\n\n## 1.1 Date概述\n\njava.util.Date`类 表示特定的瞬间，精确到毫秒。\n\n继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，我们重点看以下两个构造函数\n\n- `public Date()`：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\n- `public Date(long date)`：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n> tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间/格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。\n\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：\n\n```java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}\n```\n\n> tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。\n\n## 1.2 Date常用方法\n\nDate类中的多数方法已经过时，常用的方法有：\n\n- `public long getTime()` 把日期对象转换成对应的时间毫秒值。\n- `public void setTime(long time)` 把方法参数给定的毫秒值设置给日期对象\n\n示例代码\n\n```java\npublic class DateDemo02 {\n    public static void main(String[] args) {\n        //创建日期对象\n        Date d = new Date();\n        \n        //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n        //System.out.println(d.getTime());\n        //System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + \"年\");\n\n        //public void setTime(long time):设置时间，给的是毫秒值\n        //long time = 1000*60*60;\n        long time = System.currentTimeMillis();\n        d.setTime(time);\n\n        System.out.println(d);\n    }\n}\n```\n\n> 小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。\n\n# 第二章 SimpleDateFormat类\n\n`java.text.SimpleDateFormat` 是日期/时间格式化类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n\n- **格式化**：按照指定的格式，把Date对象转换为String对象。\n- **解析**：按照指定的格式，把String对象转换为Date对象。\n\n## 2.1 构造方法\n\n由于DateFormat为抽象类，不能直接使用，所以需要常用的子类`java.text.SimpleDateFormat`。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\n\n- `public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。\n\n## 2.2 格式规则\n\n常用的格式规则为：\n\n| 标识字母（区分大小写） | 含义 |\n| ---------------------- | ---- |\n| y                      | 年   |\n| M                      | 月   |\n| d                      | 日   |\n| H                      | 时   |\n| m                      | 分   |\n| s                      | 秒   |\n\n> 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。\n\n## 2.3 常用方法\n\nDateFormat类的常用方法有：\n\n- `public String format(Date date)`：将Date对象格式化为字符串。\n\n- `public Date parse(String source)`：将字符串解析为Date对象。\n\n  ```java\n  package com.itheima.a01jdk7datedemo;\n  \n  import java.text.ParseException;\n  import java.text.SimpleDateFormat;\n  import java.util.Date;\n  \n  public class A03_SimpleDateFormatDemo1 {\n      public static void main(String[] args) throws ParseException {\n          /*\n              public simpleDateFormat() 默认格式\n              public simpleDateFormat(String pattern) 指定格式\n              public final string format(Date date) 格式化(日期对象 ->字符串)\n              public Date parse(string source) 解析(字符串 ->日期对象)\n          */\n  \n          //1.定义一个字符串表示时间\n          String str = \"2023-11-11 11:11:11\";\n          //2.利用空参构造创建simpleDateFormat对象\n          // 细节:\n          //创建对象的格式要跟字符串的格式完全一致\n          SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n          Date date = sdf.parse(str);\n          //3.打印结果\n          System.out.println(date.getTime());//1699672271000\n  \n  \n      }\n  \n      private static void method1() {\n          //1.利用空参构造创建simpleDateFormat对象，默认格式\n          SimpleDateFormat sdf1 = new SimpleDateFormat();\n          Date d1 = new Date(0L);\n          String str1 = sdf1.format(d1);\n          System.out.println(str1);//1970/1/1 上午8:00\n  \n          //2.利用带参构造创建simpleDateFormat对象，指定格式\n          SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy年MM月dd日HH:mm:ss\");\n          String str2 = sdf2.format(d1);\n          System.out.println(str2);//1970年01月01日 08:00:00\n  \n          //课堂练习:yyyy年MM月dd日 时:分:秒 星期\n      }\n  }\n  \n  ```\n\n> 小结：DateFormat可以将Date对象和字符串相互转换。\n\n## 2.4 练习1(初恋女友的出生日期)\n\n```java\n/*\n     假设，你初恋的出生年月日为:2000-11-11\n     请用字符串表示这个数据，并将其转换为:2000年11月11日\n\n     创建一个Date对象表示2000年11月11日\n     创建一个SimpleDateFormat对象，并定义格式为年月日把时间变成:2000年11月11日\n*/\n\n//1.可以通过2000-11-11进行解析，解析成一个Date对象\nString str = \"2000-11-11\";\n//2.解析\nSimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy-MM-dd\");\nDate date = sdf1.parse(str);\n//3.格式化\nSimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy年MM月dd日\");\nString result = sdf2.format(date);\nSystem.out.println(result);\n```\n\n## 2.5 练习2(秒杀活动)\n\n```java\n/* 需求:\n            秒杀活动开始时间:2023年11月11日 0:0:0(毫秒值)\n            秒杀活动结束时间:2023年11月11日 0:10:0(毫秒值)\n\n            小贾下单并付款的时间为:2023年11月11日 0:01:0\n            小皮下单并付款的时间为:2023年11月11日 0:11:0\n            用代码说明这两位同学有没有参加上秒杀活动?\n         */\n\n//1.定义字符串表示三个时间\nString startstr = \"2023年11月11日 0:0:0\";\nString endstr = \"2023年11月11日 0:10:0\";\nString orderstr = \"2023年11月11日 0:01:00\";\n//2.解析上面的三个时间，得到Date对象\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日HH:mm:ss\");\nDate startDate = sdf.parse(startstr);\nDate endDate = sdf.parse(endstr);\nDate orderDate = sdf.parse(orderstr);\n\n//3.得到三个时间的毫秒值\nlong startTime = startDate.getTime();\nlong endTime = endDate.getTime();\nlong orderTime = orderDate.getTime();\n\n//4.判断\nif (orderTime >= startTime && orderTime <= endTime) {\n    System.out.println(\"参加秒杀活动成功\");\n} else {\n    System.out.println(\"参加秒杀活动失败\");\n}\n```\n\n# 第三章 Calendar类\n\n## 3.1 概述\n\n- java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。\n- 有两种方式可以获取GregorianCalendar对象：\n  - 直接创建GregorianCalendar对象；\n  - 通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象【本次课使用】\n\n## 3.2 常用方法\n\n| 方法名                                | 说明                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| public static Calendar getInstance()  | 获取一个它的子类GregorianCalendar对象。                      |\n| public int get(int field)             | 获取某个字段的值。field参数表示获取哪个字段的值，<br />可以使用Calender中定义的常量来表示：<br />Calendar.YEAR : 年<br />Calendar.MONTH ：月<br />Calendar.DAY_OF_MONTH：月中的日期<br />Calendar.HOUR：小时<br />Calendar.MINUTE：分钟<br />Calendar.SECOND：秒<br />Calendar.DAY_OF_WEEK：星期 |\n| public void set(int field,int value)  | 设置某个字段的值                                             |\n| public void add(int field,int amount) | 为某个字段增加/减少指定的值                                  |\n\n## 3.3 get方法示例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        //1.获取一个GregorianCalendar对象\n        Calendar instance = Calendar.getInstance();//获取子类对象\n\n        //2.打印子类对象\n        System.out.println(instance);\n\n        //3.获取属性\n        int year = instance.get(Calendar.YEAR);\n        int month = instance.get(Calendar.MONTH) + 1;//Calendar的月份值是0-11\n        int day = instance.get(Calendar.DAY_OF_MONTH);\n\n        int hour = instance.get(Calendar.HOUR);\n        int minute = instance.get(Calendar.MINUTE);\n        int second = instance.get(Calendar.SECOND);\n\n        int week = instance.get(Calendar.DAY_OF_WEEK);//返回值范围：1--7，分别表示：\"星期日\",\"星期一\",\"星期二\",...,\"星期六\"\n\n        System.out.println(year + \"年\" + month + \"月\" + day + \"日\" + \n                           \thour + \":\" + minute + \":\" + second);\n        System.out.println(getWeek(week));\n\n    }\n\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}\n\n```\n\n## 3.4 set方法示例：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        //设置属性——set(int field,int value):\n\t\tCalendar c1 = Calendar.getInstance();//获取当前日期\n\n\t\t//计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日)\n\t\tc1.set(Calendar.YEAR, 1998);\n\t\tc1.set(Calendar.MONTH, 3 - 1);//转换为Calendar内部的月份值\n\t\tc1.set(Calendar.DAY_OF_MONTH, 18);\n\n\t\tint w = c1.get(Calendar.DAY_OF_WEEK);\n\t\tSystem.out.println(\"班长出生那天是：\" + getWeek(w));\n\n        \n    }\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}\n```\n\n\n\n## 3.5 add方法示例：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        //计算200天以后是哪年哪月哪日，星期几？\n\t\tCalendar c2 = Calendar.getInstance();//获取当前日期\n        c2.add(Calendar.DAY_OF_MONTH, 200);//日期加200\n\n        int y = c2.get(Calendar.YEAR);\n        int m = c2.get(Calendar.MONTH) + 1;//转换为实际的月份\n        int d = c2.get(Calendar.DAY_OF_MONTH);\n\n        int wk = c2.get(Calendar.DAY_OF_WEEK);\n        System.out.println(\"200天后是：\" + y + \"年\" + m + \"月\" + d + \"日\" + getWeek(wk));\n\n    }\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}\n```\n\n# 第四章 JDK8时间相关类\n\n| JDK8时间类类名    | 作用                   |\n| ----------------- | ---------------------- |\n| ZoneId            | 时区                   |\n| Instant           | 时间戳                 |\n| ZoneDateTime      | 带时区的时间           |\n| DateTimeFormatter | 用于时间的格式化和解析 |\n| LocalDate         | 年、月、日             |\n| LocalTime         | 时、分、秒             |\n| LocalDateTime     | 年、月、日、时、分、秒 |\n| Duration          | 时间间隔（秒，纳，秒） |\n| Period            | 时间间隔（年，月，日） |\n| ChronoUnit        | 时间间隔（所有单位）   |\n\n## 4.1  ZoneId 时区\n\n```java\n/*\n        static Set<string> getAvailableZoneIds() 获取Java中支持的所有时区\n        static ZoneId systemDefault() 获取系统默认时区\n        static Zoneld of(string zoneld) 获取一个指定时区\n        */\n\n//1.获取所有的时区名称\nSet<String> zoneIds = ZoneId.getAvailableZoneIds();\nSystem.out.println(zoneIds.size());//600\nSystem.out.println(zoneIds);// Asia/Shanghai\n\n//2.获取当前系统的默认时区\nZoneId zoneId = ZoneId.systemDefault();\nSystem.out.println(zoneId);//Asia/Shanghai\n\n//3.获取指定的时区\nZoneId zoneId1 = ZoneId.of(\"Asia/Pontianak\");\nSystem.out.println(zoneId1);//Asia/Pontianak\n```\n\n## 4.2  Instant 时间戳\n\n```java\n/*\n            static Instant now() 获取当前时间的Instant对象(标准时间)\n            static Instant ofXxxx(long epochMilli) 根据(秒/毫秒/纳秒)获取Instant对象\n            ZonedDateTime atZone(ZoneIdzone) 指定时区\n            boolean isxxx(Instant otherInstant) 判断系列的方法\n            Instant minusXxx(long millisToSubtract) 减少时间系列的方法\n            Instant plusXxx(long millisToSubtract) 增加时间系列的方法\n        */\n//1.获取当前时间的Instant对象(标准时间)\nInstant now = Instant.now();\nSystem.out.println(now);\n\n//2.根据(秒/毫秒/纳秒)获取Instant对象\nInstant instant1 = Instant.ofEpochMilli(0L);\nSystem.out.println(instant1);//1970-01-01T00:00:00z\n\nInstant instant2 = Instant.ofEpochSecond(1L);\nSystem.out.println(instant2);//1970-01-01T00:00:01Z\n\nInstant instant3 = Instant.ofEpochSecond(1L, 1000000000L);\nSystem.out.println(instant3);//1970-01-01T00:00:027\n\n//3. 指定时区\nZonedDateTime time = Instant.now().atZone(ZoneId.of(\"Asia/Shanghai\"));\nSystem.out.println(time);\n\n\n//4.isXxx 判断\nInstant instant4=Instant.ofEpochMilli(0L);\nInstant instant5 =Instant.ofEpochMilli(1000L);\n\n//5.用于时间的判断\n//isBefore:判断调用者代表的时间是否在参数表示时间的前面\nboolean result1=instant4.isBefore(instant5);\nSystem.out.println(result1);//true\n\n//isAfter:判断调用者代表的时间是否在参数表示时间的后面\nboolean result2 = instant4.isAfter(instant5);\nSystem.out.println(result2);//false\n\n//6.Instant minusXxx(long millisToSubtract) 减少时间系列的方法\nInstant instant6 =Instant.ofEpochMilli(3000L);\nSystem.out.println(instant6);//1970-01-01T00:00:03Z\n\nInstant instant7 =instant6.minusSeconds(1);\nSystem.out.println(instant7);//1970-01-01T00:00:02Z\n\n```\n\n\n\n## 4.3 ZoneDateTime  带时区的时间\n\n```java\n/*\n            static ZonedDateTime now() 获取当前时间的ZonedDateTime对象\n            static ZonedDateTime ofXxxx(。。。) 获取指定时间的ZonedDateTime对象\n            ZonedDateTime withXxx(时间) 修改时间系列的方法\n            ZonedDateTime minusXxx(时间) 减少时间系列的方法\n            ZonedDateTime plusXxx(时间) 增加时间系列的方法\n         */\n//1.获取当前时间对象(带时区)\nZonedDateTime now = ZonedDateTime.now();\nSystem.out.println(now);\n\n//2.获取指定的时间对象(带时区)1/年月日时分秒纳秒方式指定\nZonedDateTime time1 = ZonedDateTime.of(2023, 10, 1,\n                                       11, 12, 12, 0, ZoneId.of(\"Asia/Shanghai\"));\nSystem.out.println(time1);\n\n//通过Instant + 时区的方式指定获取时间对象\nInstant instant = Instant.ofEpochMilli(0L);\nZoneId zoneId = ZoneId.of(\"Asia/Shanghai\");\nZonedDateTime time2 = ZonedDateTime.ofInstant(instant, zoneId);\nSystem.out.println(time2);\n\n\n//3.withXxx 修改时间系列的方法\nZonedDateTime time3 = time2.withYear(2000);\nSystem.out.println(time3);\n\n//4. 减少时间\nZonedDateTime time4 = time3.minusYears(1);\nSystem.out.println(time4);\n\n//5.增加时间\nZonedDateTime time5 = time4.plusYears(1);\nSystem.out.println(time5);\n```\n\n\n\n## 4.4DateTimeFormatter   用于时间的格式化和解析\n\n```java\n/*\n            static DateTimeFormatter ofPattern(格式) 获取格式对象\n            String format(时间对象) 按照指定方式格式化\n        */\n//获取时间对象\nZonedDateTime time = Instant.now().atZone(ZoneId.of(\"Asia/Shanghai\"));\n\n// 解析/格式化器\nDateTimeFormatter dtf1=DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm;ss EE a\");\n// 格式化\nSystem.out.println(dtf1.format(time));\n```\n\n\n\n## 4.5LocalDate  年、月、日\n\n```java\n//1.获取当前时间的日历对象(包含 年月日)\nLocalDate nowDate = LocalDate.now();\n//System.out.println(\"今天的日期:\" + nowDate);\n//2.获取指定的时间的日历对象\nLocalDate ldDate = LocalDate.of(2023, 1, 1);\nSystem.out.println(\"指定日期:\" + ldDate);\n\nSystem.out.println(\"=============================\");\n\n//3.get系列方法获取日历中的每一个属性值//获取年\nint year = ldDate.getYear();\nSystem.out.println(\"year: \" + year);\n//获取月//方式一:\nMonth m = ldDate.getMonth();\nSystem.out.println(m);\nSystem.out.println(m.getValue());\n\n//方式二:\nint month = ldDate.getMonthValue();\nSystem.out.println(\"month: \" + month);\n\n\n//获取日\nint day = ldDate.getDayOfMonth();\nSystem.out.println(\"day:\" + day);\n\n//获取一年的第几天\nint dayofYear = ldDate.getDayOfYear();\nSystem.out.println(\"dayOfYear:\" + dayofYear);\n\n//获取星期\nDayOfWeek dayOfWeek = ldDate.getDayOfWeek();\nSystem.out.println(dayOfWeek);\nSystem.out.println(dayOfWeek.getValue());\n\n//is开头的方法表示判断\nSystem.out.println(ldDate.isBefore(ldDate));\nSystem.out.println(ldDate.isAfter(ldDate));\n\n//with开头的方法表示修改，只能修改年月日\nLocalDate withLocalDate = ldDate.withYear(2000);\nSystem.out.println(withLocalDate);\n\n//minus开头的方法表示减少，只能减少年月日\nLocalDate minusLocalDate = ldDate.minusYears(1);\nSystem.out.println(minusLocalDate);\n\n\n//plus开头的方法表示增加，只能增加年月日\nLocalDate plusLocalDate = ldDate.plusDays(1);\nSystem.out.println(plusLocalDate);\n\n//-------------\n// 判断今天是否是你的生日\nLocalDate birDate = LocalDate.of(2000, 1, 1);\nLocalDate nowDate1 = LocalDate.now();\n\nMonthDay birMd = MonthDay.of(birDate.getMonthValue(), birDate.getDayOfMonth());\nMonthDay nowMd = MonthDay.from(nowDate1);\n\nSystem.out.println(\"今天是你的生日吗? \" + birMd.equals(nowMd));//今天是你的生日吗?\n```\n\n\n\n## 4.6 LocalTime  时、分、秒\n\n```java\n// 获取本地时间的日历对象。(包含 时分秒)\nLocalTime nowTime = LocalTime.now();\nSystem.out.println(\"今天的时间:\" + nowTime);\n\nint hour = nowTime.getHour();//时\nSystem.out.println(\"hour: \" + hour);\n\nint minute = nowTime.getMinute();//分\nSystem.out.println(\"minute: \" + minute);\n\nint second = nowTime.getSecond();//秒\nSystem.out.println(\"second:\" + second);\n\nint nano = nowTime.getNano();//纳秒\nSystem.out.println(\"nano:\" + nano);\nSystem.out.println(\"------------------------------------\");\nSystem.out.println(LocalTime.of(8, 20));//时分\nSystem.out.println(LocalTime.of(8, 20, 30));//时分秒\nSystem.out.println(LocalTime.of(8, 20, 30, 150));//时分秒纳秒\nLocalTime mTime = LocalTime.of(8, 20, 30, 150);\n\n//is系列的方法\nSystem.out.println(nowTime.isBefore(mTime));\nSystem.out.println(nowTime.isAfter(mTime));\n\n//with系列的方法，只能修改时、分、秒\nSystem.out.println(nowTime.withHour(10));\n\n//plus系列的方法，只能修改时、分、秒\nSystem.out.println(nowTime.plusHours(10));\n```\n\n\n\n## 4.7 LocalDateTime  年、月、日、时、分、秒\n\n```java\n// 当前时间的的日历对象(包含年月日时分秒)\nLocalDateTime nowDateTime = LocalDateTime.now();\n\nSystem.out.println(\"今天是:\" + nowDateTime);//今天是：\nSystem.out.println(nowDateTime.getYear());//年\nSystem.out.println(nowDateTime.getMonthValue());//月\nSystem.out.println(nowDateTime.getDayOfMonth());//日\nSystem.out.println(nowDateTime.getHour());//时\nSystem.out.println(nowDateTime.getMinute());//分\nSystem.out.println(nowDateTime.getSecond());//秒\nSystem.out.println(nowDateTime.getNano());//纳秒\n// 日:当年的第几天\nSystem.out.println(\"dayofYear:\" + nowDateTime.getDayOfYear());\n//星期\nSystem.out.println(nowDateTime.getDayOfWeek());\nSystem.out.println(nowDateTime.getDayOfWeek().getValue());\n//月份\nSystem.out.println(nowDateTime.getMonth());\nSystem.out.println(nowDateTime.getMonth().getValue());\n\nLocalDate ld = nowDateTime.toLocalDate();\nSystem.out.println(ld);\n\nLocalTime lt = nowDateTime.toLocalTime();\nSystem.out.println(lt.getHour());\nSystem.out.println(lt.getMinute());\nSystem.out.println(lt.getSecond());\n```\n\n\n\n## 4.8 Duration  时间间隔（秒，纳，秒）\n\n```java\n// 本地日期时间对象。\nLocalDateTime today = LocalDateTime.now();\nSystem.out.println(today);\n\n// 出生的日期时间对象\nLocalDateTime birthDate = LocalDateTime.of(2000, 1, 1, 0, 0, 0);\nSystem.out.println(birthDate);\n\nDuration duration = Duration.between(birthDate, today);//第二个参数减第一个参数\nSystem.out.println(\"相差的时间间隔对象:\" + duration);\n\nSystem.out.println(\"============================================\");\nSystem.out.println(duration.toDays());//两个时间差的天数\nSystem.out.println(duration.toHours());//两个时间差的小时数\nSystem.out.println(duration.toMinutes());//两个时间差的分钟数\nSystem.out.println(duration.toMillis());//两个时间差的毫秒数\nSystem.out.println(duration.toNanos());//两个时间差的纳秒数\n```\n\n\n\n## 4.9 Period  时间间隔（年，月，日）\n\n```java\n// 当前本地 年月日\nLocalDate today = LocalDate.now();\nSystem.out.println(today);\n\n// 生日的 年月日\nLocalDate birthDate = LocalDate.of(2000, 1, 1);\nSystem.out.println(birthDate);\n\nPeriod period = Period.between(birthDate, today);//第二个参数减第一个参数\n\nSystem.out.println(\"相差的时间间隔对象:\" + period);\nSystem.out.println(period.getYears());\nSystem.out.println(period.getMonths());\nSystem.out.println(period.getDays());\n\nSystem.out.println(period.toTotalMonths());\n```\n\n\n\n## 4.10 ChronoUnit  时间间隔（所有单位）\n\n```java\n// 当前时间\nLocalDateTime today = LocalDateTime.now();\nSystem.out.println(today);\n// 生日时间\nLocalDateTime birthDate = LocalDateTime.of(2000, 1, 1,0, 0, 0);\nSystem.out.println(birthDate);\n\nSystem.out.println(\"相差的年数:\" + ChronoUnit.YEARS.between(birthDate, today));\nSystem.out.println(\"相差的月数:\" + ChronoUnit.MONTHS.between(birthDate, today));\nSystem.out.println(\"相差的周数:\" + ChronoUnit.WEEKS.between(birthDate, today));\nSystem.out.println(\"相差的天数:\" + ChronoUnit.DAYS.between(birthDate, today));\nSystem.out.println(\"相差的时数:\" + ChronoUnit.HOURS.between(birthDate, today));\nSystem.out.println(\"相差的分数:\" + ChronoUnit.MINUTES.between(birthDate, today));\nSystem.out.println(\"相差的秒数:\" + ChronoUnit.SECONDS.between(birthDate, today));\nSystem.out.println(\"相差的毫秒数:\" + ChronoUnit.MILLIS.between(birthDate, today));\nSystem.out.println(\"相差的微秒数:\" + ChronoUnit.MICROS.between(birthDate, today));\nSystem.out.println(\"相差的纳秒数:\" + ChronoUnit.NANOS.between(birthDate, today));\nSystem.out.println(\"相差的半天数:\" + ChronoUnit.HALF_DAYS.between(birthDate, today));\nSystem.out.println(\"相差的十年数:\" + ChronoUnit.DECADES.between(birthDate, today));\nSystem.out.println(\"相差的世纪(百年)数:\" + ChronoUnit.CENTURIES.between(birthDate, today));\nSystem.out.println(\"相差的千年数:\" + ChronoUnit.MILLENNIA.between(birthDate, today));\nSystem.out.println(\"相差的纪元数:\" + ChronoUnit.ERAS.between(birthDate, today));\n```\n\n# 第五章  包装类\n\n## 5.1 概述\n\nJava提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\n\n| 基本类型 | 对应的包装类（位于java.lang包中） |\n| -------- | --------------------------------- |\n| byte     | Byte                              |\n| short    | Short                             |\n| int      | **Integer**                       |\n| long     | Long                              |\n| float    | Float                             |\n| double   | Double                            |\n| char     | **Character**                     |\n| boolean  | Boolean                           |\n\n## 5.2 Integer类\n\n- Integer类概述\n\n  包装一个对象中的原始类型 int 的值\n\n- Integer类构造方法及静态方法\n\n| 方法名                                  | 说明                                   |\n| --------------------------------------- | -------------------------------------- |\n| public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)     |\n| public Integer(String s)                | 根据 String 值创建 Integer 对象(过时)  |\n| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例 |\n| public static Integer valueOf(String s) | 返回保存指定String值的 Integer 对象    |\n| static string tobinarystring(int i)     | 得到二进制                             |\n| static string tooctalstring(int i)      | 得到八进制                             |\n| static string toHexstring(int i)        | 得到十六进制                           |\n| static int parseInt(string s)           | 将字符串类型的整数转成int类型的整数    |\n\n- 示例代码\n\n```java\n//public Integer(int value)：根据 int 值创建 Integer 对象(过时)\nInteger i1 = new Integer(100);\nSystem.out.println(i1);\n\n//public Integer(String s)：根据 String 值创建 Integer 对象(过时)\nInteger i2 = new Integer(\"100\");\n//Integer i2 = new Integer(\"abc\"); //NumberFormatException\nSystem.out.println(i2);\nSystem.out.println(\"--------\");\n\n//public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\nInteger i3 = Integer.valueOf(100);\nSystem.out.println(i3);\n\n//public static Integer valueOf(String s)：返回保存指定String值的Integer对象 \nInteger i4 = Integer.valueOf(\"100\");\nSystem.out.println(i4);\n```\n\n```java\n/*\n            public static string tobinarystring(int i) 得到二进制\n            public static string tooctalstring(int i) 得到八进制\n            public static string toHexstring(int i) 得到十六进制\n            public static int parseInt(string s) 将字符串类型的整数转成int类型的整数\n */\n\n//1.把整数转成二进制，十六进制\nString str1 = Integer.toBinaryString(100);\nSystem.out.println(str1);//1100100\n\n//2.把整数转成八进制\nString str2 = Integer.toOctalString(100);\nSystem.out.println(str2);//144\n\n//3.把整数转成十六进制\nString str3 = Integer.toHexString(100);\nSystem.out.println(str3);//64\n\n//4.将字符串类型的整数转成int类型的整数\n//强类型语言:每种数据在java中都有各自的数据类型\n//在计算的时候，如果不是同一种数据类型，是无法直接计算的。\nint i = Integer.parseInt(\"123\");\nSystem.out.println(i);\nSystem.out.println(i + 1);//124\n//细节1:\n//在类型转换的时候，括号中的参数只能是数字不能是其他，否则代码会报错\n//细节2:\n//8种包装类当中，除了Character都有对应的parseXxx的方法，进行类型转换\nString str = \"true\";\nboolean b = Boolean.parseBoolean(str);\nSystem.out.println(b);\n```\n\n## 5.3 装箱与拆箱\n\n基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n\n- **装箱**：从基本类型转换为对应的包装类对象。\n- **拆箱**：从包装类对象转换为对应的基本类型。\n\n用Integer与 int为例：（看懂代码即可）\n\n基本数值---->包装对象\n\n```java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\n```\n\n包装对象---->基本数值\n\n```java\nint num = i.intValue();\n```\n\n## 5.4 自动装箱与自动拆箱\n\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\n```java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。\n```\n\n## 5.5 基本类型与字符串之间的转换\n\n### 基本类型转换为String\n\n- 转换方式\n- 方式一：直接在数字后加一个空字符串\n- 方式二：通过String类静态方法valueOf()\n- 示例代码\n\n```java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //int --- String\n        int number = 100;\n        //方式1\n        String s1 = number + \"\";\n        System.out.println(s1);\n        //方式2\n        //public static String valueOf(int i)\n        String s2 = String.valueOf(number);\n        System.out.println(s2);\n        System.out.println(\"--------\");\n    }\n}\n```\n\n### String转换成基本类型 \n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\n\n- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。\n- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。\n- **`public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。**\n- **`public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。**\n- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。\n- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。\n- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。\n\n代码使用（仅以Integer类的静态方法parseXxx为例）如：\n\n- 转换方式\n  - 方式一：先将字符串数字转成Integer，再调用valueOf()方法\n  - 方式二：通过Integer静态方法parseInt()进行转换\n- 示例代码\n\n```java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //String --- int\n        String s = \"100\";\n        //方式1：String --- Integer --- int\n        Integer i = Integer.valueOf(s);\n        //public int intValue()\n        int x = i.intValue();\n        System.out.println(x);\n        //方式2\n        //public static int parseInt(String s)\n        int y = Integer.parseInt(s);\n        System.out.println(y);\n    }\n}\n```\n\n> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。\n\n## 5.6 底层原理\n\n建议：获取Integer对象的时候不要自己new，而是采取直接赋值或者静态方法valueOf的方式\n\n因为在实际开发中，-128~127之间的数据，用的比较多。如果每次使用都是new对象，那么太浪费内存了。\n\n所以，提前把这个范围之内的每一个数据都创建好对象，如果要用到了不会创建新的，而是返回已经创建好的对象。\n\n```java\n//1.利用构造方法获取Integer的对象(JDK5以前的方式)\n/*Integer i1 = new Integer(1);\n        Integer i2 = new Integer(\"1\");\n        System.out.println(i1);\n        System.out.println(i2);*/\n\n//2.利用静态方法获取Integer的对象(JDK5以前的方式)\nInteger i3 = Integer.valueOf(123);\nInteger i4 = Integer.valueOf(\"123\");\nInteger i5 = Integer.valueOf(\"123\", 8);\n\nSystem.out.println(i3);\nSystem.out.println(i4);\nSystem.out.println(i5);\n\n//3.这两种方式获取对象的区别(掌握)\n//底层原理：\n//因为在实际开发中，-128~127之间的数据，用的比较多。\n//如果每次使用都是new对象，那么太浪费内存了\n//所以，提前把这个范围之内的每一个数据都创建好对象\n//如果要用到了不会创建新的，而是返回已经创建好的对象。\nInteger i6 = Integer.valueOf(127);\nInteger i7 = Integer.valueOf(127);\nSystem.out.println(i6 == i7);//true\n\nInteger i8 = Integer.valueOf(128);\nInteger i9 = Integer.valueOf(128);\nSystem.out.println(i8 == i9);//false\n\n//因为看到了new关键字，在Java中，每一次new都是创建了一个新的对象\n//所以下面的两个对象都是new出来，地址值不一样。\n/*Integer i10 = new Integer(127);\n        Integer i11 = new Integer(127);\n        System.out.println(i10 == i11);\n\n        Integer i12 = new Integer(128);\n        Integer i13 = new Integer(128);\n        System.out.println(i12 == i13);*/\n```\n\n# 第六章：算法小题\n\n## 练习一：\n\n需求：\n\n​\t键盘录入一些1~10日之间的整数，并添加到集合中。直到集合中所有数据和超过200为止。\n\n代码示例：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        /*\n            键盘录入一些1~10日之间的整数，并添加到集合中。直到集合中所有数据和超过200为止。\n        */\n        //1.创建一个集合用来添加整数\n        ArrayList<Integer> list = new ArrayList<>();\n        //2.键盘录入数据添加到集合中\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            System.out.println(\"请输入一个整数\");\n            String numStr = sc.nextLine();\n            int num = Integer.parseInt(numStr);//先把异常数据先进行过滤\n            if (num < 1 || num > 100){\n                System.out.println(\"当前数字不在1~100的范围当中，请重新输入\");\n                continue;\n            }\n            //添加到集合中//细节:\n            //num:基本数据类型\n            //集合里面的数据是Integer\n            //在添加数据的时候触发了自动装箱\n            list.add(num);\n            //统计集合中所有的数据和\n            int sum = getSum(list);\n            //对sum进行判断\n            if(sum > 200){\n            System.out.println(\"集合中所有的数据和已经满足要求\");\n            break;\n        }\n    }\n\n}\n\n\n    private static int getSum(ArrayList<Integer> list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            //i :索引\n            //list.get(i);\n            int num = list.get(i);\n            sum = sum + num;//+=\n        }\n        return sum;\n    }\n}\n\n```\n\n## 练习二：\n\n需求：\n\n​\t自己实现parseInt方法的效果，将字符串形式的数据转成整数。要求:字符串中只能是数字不能有其他字符最少一位，最多10位日不能开头\n\n代码示例：\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        /*\n            自己实现parseInt方法的效果，将字符串形式的数据转成整数。要求:\n            字符串中只能是数字不能有其他字符最少一位，最多10位日不能开头\n        */\n\n        //1.定义一个字符串\n        String str = \"123\";\n        //2.校验字符串\n        //习惯:会先把异常数据进行过滤，剩下来就是正常的数据。\n        if (!str.matches(\"[1-9]\\\\d{0,9}\")) {\n            //错误的数据\n            System.out.println(\"数据格式有误\");\n        } else {\n            //正确的数据\n            System.out.println(\"数据格式正确\");\n            //3.定义一个变量表示最终的结果\n            int number = 0;\n            //4.遍历字符串得到里面的每一个字符\n            for (int i = 0; i < str.length(); i++) {\n                int c = str.charAt(i) - '0';//把每一位数字放到number当中\n                number = number * 10 + c;\n            }\n            System.out.println(number);\n            System.out.println(number + 1);\n        }\n    }\n}\n```\n\n## 练习三：\n\n需求：\n\n​\t定义一个方法自己实现toBinaryString方法的效果，将一个十进制整数转成字符串表示的二进制\n\n代码示例：\n\n```java\npackage com.itheima.a04test;\n\npublic class Test3 {\n    public static void main(String[] args) {\n        /*\n\n            定义一个方法自己实现toBinaryString方法的效果，将一个十进制整数转成字符串表示的二进制\n\n         */\n    }\n\n\n    public static String tobinarystring(int number) {//6\n        //核心逻辑:\n        //不断的去除以2，得到余数，一直到商为日就结束。\n        //还需要把余数倒着拼接起来\n\n        //定义一个StringBuilder用来拼接余数\n        StringBuilder sb = new StringBuilder();\n        //利用循环不断的除以2获取余数\n        while (true) {\n            if (number == 0) {\n                break;\n            }\n            //获取余数 %\n            int remaindar = number % 2;//倒着拼接\n            sb.insert(0, remaindar);\n            //除以2 /\n            number = number / 2;\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n## 练习四：\n\n需求：\n\n​\t请使用代码实现计算你活了多少天，用JDK7和JDK8两种方式完成\n\n代码示例：\n\n```java\npublic class Test4 {\n    public static void main(String[] args) throws ParseException {\n        //请使用代码实现计算你活了多少天，用JDK7和JDK8两种方式完成\n        //JDK7\n        //规则:只要对时间进行计算或者判断，都需要先获取当前时间的毫秒值\n        //1.计算出生年月日的毫秒值\n        String birthday = \"2000年1月1日\";\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        Date date = sdf.parse(birthday);\n        long birthdayTime = date.getTime();\n        //2.获取当前时间的毫秒值\n        long todayTime = System.currentTimeMillis();\n        //3.计算间隔多少天\n        long time = todayTime - birthdayTime;\n        System.out.println(time / 1000 / 60 / 60 / 24);\n\n\n        //JDK8\n        LocalDate ld1 = LocalDate.of(2000, 1, 1);\n        LocalDate ld2 = LocalDate.now();\n        long days = ChronoUnit.DAYS.between(ld1, ld2);\n        System.out.println(days);\n    }\n}\n```\n\n## 练习五：\n\n需求：\n\n​\t判断任意的一个年份是闰年还是平年要求:用JDK7和JDK8两种方式判断提示:二月有29天是闰年一年有366天是闰年\n\n代码示例：\n\n```java\npublic class Test5 {\n    public static void main(String[] args) {\n        /*\n            判断任意的一个年份是闰年还是平年要求:用JDK7和JDK8两种方式判断提示:\n            二月有29天是闰年一年有366天是闰年\n        */\n\n        //jdk7\n        //我们可以把时间设置为2000年3月1日\n        Calendar c = Calendar.getInstance();\n        c.set(2000, 2, 1);\n        //月份的范围:0~11\n        //再把日历往前减一天\n        c.add(Calendar.DAY_OF_MONTH, -1);\n        //看当前的时间是28号还是29号?\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        System.out.println(day);\n\n\n        //jdk8\n        //月份的范围:1~12\n        //设定时间为2000年的3月1日\n        LocalDate ld = LocalDate.of(2001, 3, 1);\n        //把时间往前减一天\n        LocalDate ld2 = ld.minusDays(1);\n        //获取这一天是一个月中的几号\n        int day2 = ld2.getDayOfMonth();\n        System.out.println(day2);\n\n        //true:闰年\n        //false:平年\n        System.out.println(ld.isLeapYear());\n    }\n}\n```\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"新年快乐","url":"/2023/01/22/新年快乐/","content":"# 新年快乐！！！\n## 祝我们在新的一年里越来越好！！\n\n![](https://pic.imgdb.cn/item/63cd1cfebe43e0d30ed92a03.jpg)\n![](https://pic.imgdb.cn/item/63cd1d02be43e0d30ed93105.jpg)\n","tags":["生活"],"categories":["生活"]},{"title":"Api","url":"/2023/01/20/API/","content":"# 课程目标\n\n能够熟练使用Math类中的常见方法\n\n能够熟练使用System类中的常见方法\n\n能够理解Object类的常见方法作用\n\n能够熟练使用Objects类的常见方法\n\n能够熟练使用BigInteger类的常见方法\n\n能够熟练使用BigDecimal类的常见方法\n\n# 1 Math类\n\n## 1.1 概述\n\n> tips：了解内容\n\n查看API文档，我们可以看到API文档中关于Math类的定义如下：\n\n ![1576047659085](.\\assets\\1576047659085.png) \n\nMath类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。\n\nMath类包含执行基本数字运算的方法，我们可以使用Math类完成基本的数学运算。\n\n\n\n要想使用Math类我们就需要先创建该类的对象，那么创建对象就需要借助于构造方法。因此我们就需要首先查看一下API文档，看看API文档中针对Math类有没有提供对应的构造方法。通过API文档来查看\n\n一下Math类的成员，如下所示：\n\n![1576047846672](.\\assets\\1576047846672.png) \n\n在API文档中没有体现可用的构造方法，因此我们就不能直接通过new关键字去创建Math类的对象。同时我们发现Math类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用。在Math类中\n\n定义了很多数学运算的方法，但是我们并不可能将所有的方法学习一遍，我们主要学习的就是一些常见的方法。\n\n## 1.2 常见方法\n\n> tips：重点讲解内容\n\n<font color=\"red\" size=\"3\">**常见方法介绍**</font>\n\n我们要学习的Math的常见方法如下所示：\n\n```java\npublic static int abs(int a)\t\t\t\t\t// 返回参数的绝对值\npublic static double ceil(double a)\t\t\t\t// 返回大于或等于参数的最小整数\npublic static double floor(double a)\t\t\t// 返回小于或等于参数的最大整数\npublic static int round(float a)\t\t\t\t// 按照四舍五入返回最接近参数的int类型的值\npublic static int max(int a,int b)\t\t\t\t// 获取两个int值中的较大值\npublic static int min(int a,int b)\t\t\t\t// 获取两个int值中的较小值\npublic static double pow (double a,double b)\t// 计算a的b次幂的值\npublic static double random()\t\t\t\t\t// 返回一个[0.0,1.0)的随机值\n```\n\n<font color=\"red\" size=\"3\">**案例演示**</font>\n\n接下来我们就来演示一些这些方法的执行效果，如下所示：\n\n```java\npublic class MathDemo01 {\n\n    public static void main(String[] args) {\n\n        // public static int abs(int a)         返回参数的绝对值\n        System.out.println(\"-2的绝对值为：\" + Math.abs(-2));\n        System.out.println(\"2的绝对值为：\" + Math.abs(2));\n\n        // public static double ceil(double a)  返回大于或等于参数的最小整数\n        System.out.println(\"大于或等于23.45的最小整数位：\" + Math.ceil(23.45));\n        System.out.println(\"大于或等于-23.45的最小整数位：\" + Math.ceil(-23.45));\n\n        // public static double floor(double a) 返回小于或等于参数的最大整数\n        System.out.println(\"小于或等于23.45的最大整数位：\" + Math.floor(23.45));\n        System.out.println(\"小于或等于-23.45的最大整数位：\" + Math.floor(-23.45));\n\n        // public static int round(float a)     按照四舍五入返回最接近参数的int\n        System.out.println(\"23.45四舍五入的结果为：\" + Math.round(23.45));\n        System.out.println(\"23.55四舍五入的结果为：\" + Math.round(23.55));\n\n        // public static int max(int a,int b)   返回两个int值中的较大值\n        System.out.println(\"23和45的最大值为: \" + Math.max(23, 45));\n\n        // public static int min(int a,int b)   返回两个int值中的较小值\n        System.out.println(\"12和34的最小值为: \" + Math.min(12 , 34));\n\n        // public static double pow (double a,double b)返回a的b次幂的值\n        System.out.println(\"2的3次幂计算结果为: \" + Math.pow(2,3));\n\n        // public static double random()返回值为double的正值，[0.0,1.0)\n        System.out.println(\"获取到的0-1之间的随机数为: \" + Math.random());\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下：\n\n```java\n-2的绝对值为：2\n2的绝对值为：2\n大于或等于23.45的最小整数位：24.0\n大于或等于-23.45的最小整数位：-23.0\n小于或等于23.45的最大整数位：23.0\n小于或等于-23.45的最大整数位：-24.0\n23.45四舍五入的结果为：23\n23.55四舍五入的结果为：24\n23和45的最大值为: 45\n12和34的最小值为: 12\n2的3次幂计算结果为: 8.0\n获取到的0-1之间的随机数为: 0.7322484131745958\n```\n\n## 1.3 算法小题(质数)\n\n需求：\n\n​\t判断一个数是否为一个质数\n\n代码实现：\n\n```java\npublic class MathDemo2 {\n    public static void main(String[] args) {\n        //判断一个数是否为一个质数\n        System.out.println(isPrime(997));\n        //997 2~996 995次\n    }\n\n    public static boolean isPrime(int number) {\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            count++;\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        System.out.println(count);\n        return true;\n    }\n}\n```\n\n## 1.4 算法小题(自幂数)\n\n自幂数，一个n位自然数等于自身各个数位上数字的n次幂之和\n\n​\t举例1：三位数  1^3 + 5^3 + 3^3 = 153  \n\n​\t举例2：四位数  1^4 + 6^4 + 3^4 + 4^3 = 1634\n\n如果自幂数是：\n\n* 一位自幂数，也叫做：独身数\n* 三位自幂数：水仙花数  四位自幂数：四叶玫瑰数\n* 五位自幂数：五角星数  六位自幂数：六合数\n* 七位自幂数：北斗七星数  八位自幂数：八仙数\n* 九位自幂数：九九重阳数  十位自幂数：十全十美数\n\n要求1：统计一共有多少个水仙花数。\n\n要求2：（课后作业）证明没有两位的自幂数。\n\n要求3：（课后作业）分别统计有多少个四叶玫瑰数和五角星数。（答案：都是3个）\n\n```java\n//水仙花数:100 ~ 999\nint count = 0;\n//得到每一个三位数\nfor (int i = 100; i <= 999; i++) {\n    //个位 十位 百位\n    int ge = i % 10;\n    int shi = i / 10 % 10;\n    int bai = i / 100 % 10;\n    //判断:\n    //每一位的三次方之和 跟本身 进行比较。\n    double sum = Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3);\n    if (sum == i) {\n        count++;\n        //System.out.println(i);\n\n        System.out.println(count);\n    }\n}\n```\n\n## 1.5 课后练习\n\n要求2：（课后作业）证明没有两位的自幂数。\n\n要求3：（课后作业）分别统计有多少个四叶玫瑰数和五角星数。（答案：都是3个）\n\n\n\n# 2 System类\n\n## 2.1 概述\n\n> tips：了解内容\n\n查看API文档，我们可以看到API文档中关于System类的定义如下：\n\n ![1576049347968](assets/1576049347968.png) \n\n\n\nSystem类所在包为java.lang包，因此在使用的时候不需要进行导包。并且System类被final修饰了，因此该类是不能被继承的。\n\nSystem包含了系统操作的一些常用的方法。比如获取当前时间所对应的毫秒值，再比如终止当前JVM等等。\n\n\n\n要想使用System类我们就需要先创建该类的对象，那么创建对象就需要借助于构造方法。因此我们就需要首先查看一下API文档，看看API文档中针对System类有没有提供对应的构造方法。通过API文档来\n\n查看一下System类的成员，如下所示：\n\n![1576049535584](assets/1576049535584.png) \n\n在API文档中没有体现可用的构造方法，因此我们就不能直接通过new关键字去创建System类的对象。同时我们发现System类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用（Nested \n\nClass Summary内部类或者内部接口的描述）。\n\n## 2.2 常见方法\n\n> tips：重点讲解内容\n\n<font color=\"red\" size=\"3\">**常见方法介绍**</font>\n\n我们要学习的System类中的常见方法如下所示：\n\n```java\npublic static long currentTimeMillis()\t\t\t// 获取当前时间所对应的毫秒值（当前时间为0时区所对应的时间即就是英国格林尼治天文台旧址所在位置）\npublic static void exit(int status)\t\t\t\t// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); // 进行数值元素copy\n```\n\n<font color=\"red\" size=\"3\">**案例演示**</font>\n\n接下来我们就来通过一些案例演示一下这些方法的特点。\n\n<font color=\"blue\" size=\"2\">**案例1**</font>：演示currentTimeMillis方法\n\n```java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n\n        // 获取当前时间所对应的毫秒值\n        long millis = System.currentTimeMillis();\n\n        // 输出结果\n        System.out.println(\"当前时间所对应的毫秒值为：\" + millis);\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台的输出结果如下：\n\n```java\n当前时间所对应的毫秒值为：1576050298343\n```\n\n获取到当前时间的毫秒值的意义：我们常常来需要统计某一段代码的执行时间。此时我们就可以在执行这段代码之前获取一次时间，在执行完毕以后再次获取一次系统时间，然后计算两个时间的差值，\n\n这个差值就是这段代码执行完毕以后所需要的时间。如下代码所示：\n\n```java\npublic class SystemDemo2 {\n    public static void main(String[] args) {\n        //判断1~100000之间有多少个质数\n\n        long start = System.currentTimeMillis();\n\n        for (int i = 1; i <= 100000; i++) {\n            boolean flag = isPrime2(i);\n            if (flag) {\n                System.out.println(i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        //获取程序运行的总时间\n        System.out.println(end - start); //方式一：1514 毫秒  方式二：71毫秒\n    }\n\n    //以前判断是否为质数的方式\n    public static boolean isPrime1(int number) {\n        for (int i = 2; i < number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //改进之后判断是否为质数的方式（效率高）\n    public static boolean isPrime2(int number) {\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n<font color=\"blue\" size=\"2\">**案例2**</font>：演示exit方法\n\n```java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n        \n        // 输出\n        System.out.println(\"程序开始执行了.....\");\n        \n        // 终止JVM\n        System.exit(0);\n        \n        // 输出\n        System.out.println(\"程序终止了..........\");\n        \n    }\n    \n}\n```\n\n运行程序进行测试，控制台输出结果如下：\n\n```java\n程序开始执行了.....\n```\n\n此时可以看到在控制台只输出了\"程序开始了...\"，由于JVM终止了，因此输出\"程序终止了...\"这段代码没有被执行。\n\n<font color=\"blue\" size=\"2\">**案例3**</font>：演示arraycopy方法\n\n方法参数说明：\n\n```java\n// src: \t 源数组\n// srcPos：  源数值的开始位置\n// dest：    目标数组\n// destPos： 目标数组开始位置\n// length:   要复制的元素个数\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); \n```\n\n代码如下所示：\n\n```java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n\n        // 定义源数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n\n        // 定义目标数组\n        int[] desArray = new int[10] ;\n\n        // 进行数组元素的copy: 把srcArray数组中从0索引开始的3个元素，从desArray数组中的1索引开始复制过去\n        System.arraycopy(srcArray , 0 , desArray , 1 , 3);\n\n        // 遍历目标数组\n        for(int x = 0 ; x < desArray.length ; x++) {\n            if(x != desArray.length - 1) {\n                System.out.print(desArray[x] + \", \");\n            }else {\n                System.out.println(desArray[x]);\n            }\n\n        }\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\n0, 23, 45, 67, 0, 0, 0, 0, 0, 0\n```\n\n通过控制台输出结果我们可以看到，数组元素的确进行复制了。\n\n使用这个方法我们也可以完成数组元素的删除操作，如下所示：\n\n```java\npublic class SystemDemo02 {\n    public static void main(String[] args) {\n        // 定义一个数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n        // 删除数组中第3个元素(67)：要删除67这个元素，我们只需要将67后面的其他元素依次向前进行移动即可\n        System.arraycopy(srcArray , 3 , srcArray , 2 , 3);\n        // 遍历srcArray数组\n        for(int x = 0 ; x < srcArray.length ; x++) {\n            if(x != desArray.length - 1) {\n                System.out.print(srcArray[x] + \", \");\n            }else {\n                System.out.println(srcArray[x]);\n            }\n        }\n    }\n}\n```\n\n运行程序进行测试，控制台的输出结果如下所示：\n\n```java\n23, 45, 89, 14, 56, 56 \n```\n\n通过控制台输出结果我们可以看到此时多出了一个56元素，此时我们只需要将最后一个位置设置为0即可。如下所示：\n\n```java\npublic class SystemDemo02 {\n    public static void main(String[] args) {\n        // 定义一个数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n        // 删除数组中第3个元素(67)：要删除67这个元素，我们只需要将67后面的其他元素依次向前进行移动即可\n        System.arraycopy(srcArray , 3 , srcArray , 2 , 3);\n        // 将最后一个位置的元素设置为0\n        srcArray[srcArray.length - 1] = 0 ;\n        // 遍历srcArray数组\n        for(int x = 0 ; x < srcArray.length ; x++) {\n            if(x != srcArray.length - 1 ) {\n                System.out.print(srcArray[x] + \", \");\n            }else {\n                System.out.println(srcArray[x]);\n            }\n        }\n    }\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\n23, 45, 89, 14, 56, 0\n```\n\n此时我们可以看到元素\"67\"已经被删除掉了。67后面的其他元素依次向前进行移动了一位。\n\n**arraycopy方法底层细节：**\n\n1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错\n\n2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错\n\n3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型\n\n代码示例：\n\n```java\npublic class SystemDemo3 {\n    public static void main(String[] args) {\n        //public static void arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数) 数组拷贝\n        //细节:\n        //1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错\n        //2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错\n        //3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型\n\n        Student s1 = new Student(\"zhangsan\", 23);\n        Student s2 = new Student(\"lisi\", 24);\n        Student s3 = new Student(\"wangwu\", 25);\n\n        Student[] arr1 = {s1, s2, s3};\n        Person[] arr2 = new Person[3];\n        //把arr1中对象的地址值赋值给arr2中\n        System.arraycopy(arr1, 0, arr2, 0, 3);\n\n        //遍历数组arr2\n        for (int i = 0; i < arr2.length; i++) {\n            Student stu = (Student) arr2[i];\n            System.out.println(stu.getName() + \",\" + stu.getAge());\n        }\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     *\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     *\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     *\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     *\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"Person{name = \" + name + \", age = \" + age + \"}\";\n    }\n}\n\n\nclass Student extends Person {\n\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        super(name, age);\n    }\n}\n```\n\n# 3 Runtime\n\n## 3.1 概述\n\n​\tRuntime表示Java中运行时对象，可以获取到程序运行时设计到的一些信息\n\n## 3.2 常见方法\n\n<font color=\"red\" size=\"3\">**常见方法介绍**</font>\n\n我们要学习的Object类中的常见方法如下所示：\n\n```java\npublic static Runtime getRuntime()\t\t//当前系统的运行环境对象\npublic void exit(int status)\t\t\t//停止虚拟机\npublic int availableProcessors()\t\t//获得CPU的线程数\npublic long maxMemory()\t\t\t\t    //JVM能从系统中获取总内存大小（单位byte）\npublic long totalMemory()\t\t\t\t//JVM已经从系统中获取总内存大小（单位byte）\npublic long freeMemory()\t\t\t\t//JVM剩余内存大小（单位byte）\npublic Process exec(String command) \t//运行cmd命令\n```\n\n代码示例：\n\n```java\npublic class RunTimeDemo1 {\n    public static void main(String[] args) throws IOException {\n        /*\n            public static Runtime getRuntime() 当前系统的运行环境对象\n            public void exit(int status) 停止虚拟机\n            public int availableProcessors() 获得CPU的线程数\n            public long maxMemory() JVM能从系统中获取总内存大小(单位byte)\n            public long totalMemory() JVM已经从系统中获取总内存大小(单位byte)\n            public long freeMemory() JVM剩余内存大小(单位byte)\n            public Process exec(string command) 运行cmd命令\n        */\n\n        //1.获取Runtime的对象\n        //Runtime r1 =Runtime.getRuntime();\n\n        //2.exit 停止虚拟机\n        //Runtime.getRuntime().exit(0);\n        //System.out.println(\"看看我执行了吗?\");\n\n\n        //3.获得CPU的线程数\n        System.out.println(Runtime.getRuntime().availableProcessors());//8\n        //4.总内存大小,单位byte字节\n        System.out.println(Runtime.getRuntime().maxMemory() / 1024 / 1024);//4064\n        //5.已经获取的总内存大小,单位byte字节\n        System.out.println(Runtime.getRuntime().totalMemory() / 1024 / 1024);//254\n        //6.剩余内存大小\n        System.out.println(Runtime.getRuntime().freeMemory() / 1024 / 1024);//251\n\n        //7.运行cmd命令\n        //shutdown :关机\n        //加上参数才能执行\n        //-s :默认在1分钟之后关机\n        //-s -t 指定时间 : 指定关机时间\n        //-a :取消关机操作\n        //-r: 关机并重启\n        Runtime.getRuntime().exec(\"shutdown -s -t 3600\");\n\n\n    }\n}\n\n```\n\n## 3.3 恶搞好基友\n\n需求：\n\n​\t界面上方按钮默认隐藏\n\n​\t界面中间有一个提示文本和三个按钮\n\n​\t当你的好基友点击中间三个按钮的时候就在N秒之后关机，不同的按钮N的值不一样\n\n​\t任意一个按钮被点击之后，上方了按钮出现。当点击上方按钮之后取消关机任务\n\n ![恶搞好基友](assets\\恶搞好基友.png)\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        new MyJframe();\n    }\n}\n```\n\n```java\npublic class MyJframe extends JFrame implements ActionListener {\n\n    JButton yesBut = new JButton(\"帅爆了\");\n    JButton midBut = new JButton(\"一般般吧\");\n    JButton noBut = new JButton(\"不帅，有点磕碜\");\n    JButton dadBut = new JButton(\"饶了我吧！\");\n\n\n    //决定了上方的按钮是否展示\n    boolean flag = false;\n\n\n    public MyJframe() {\n        initJFrame();\n\n\n        initView();\n\n\n        //显示\n        this.setVisible(true);\n    }\n\n    private void initView() {\n\n        this.getContentPane().removeAll();\n\n        if (flag) {\n            //展示按钮\n            dadBut.setBounds(50, 20, 100, 30);\n            dadBut.addActionListener(this);\n            this.getContentPane().add(dadBut);\n        }\n\n\n        JLabel text = new JLabel(\"你觉得自己帅吗？\");\n        text.setFont(new Font(\"微软雅黑\", 0, 30));\n        text.setBounds(120, 150, 300, 50);\n\n\n        yesBut.setBounds(200, 250, 100, 30);\n        midBut.setBounds(200, 325, 100, 30);\n        noBut.setBounds(160, 400, 180, 30);\n\n        yesBut.addActionListener(this);\n        midBut.addActionListener(this);\n        noBut.addActionListener(this);\n\n        this.getContentPane().add(text);\n        this.getContentPane().add(yesBut);\n        this.getContentPane().add(midBut);\n        this.getContentPane().add(noBut);\n\n        this.getContentPane().repaint();\n    }\n\n    private void initJFrame() {\n        //设置宽高\n        this.setSize(500, 600);\n        //设置标题\n        this.setTitle(\"恶搞好基友\");\n        //设置关闭模式\n        this.setDefaultCloseOperation(3);\n        //置顶\n        this.setAlwaysOnTop(true);\n        //居中\n        this.setLocationRelativeTo(null);\n        //取消内部默认布局\n        this.setLayout(null);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        Object obj = e.getSource();\n        if (obj == yesBut) {\n            //给好基友一个弹框\n            showJDialog(\"xxx，你太自信了，给你一点小惩罚\");\n            try {\n                Runtime.getRuntime().exec(\"shutdown -s -t 3600\");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n            flag = true;\n            initView();\n\n        } else if (obj == midBut) {\n            System.out.println(\"你的好基友点击了一般般吧\");\n\n            //给好基友一个弹框\n            showJDialog(\"xxx，你还是太自信了，也要给你一点小惩罚\");\n\n            try {\n                Runtime.getRuntime().exec(\"shutdown -s -t 7200\");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n            flag = true;\n            initView();\n\n\n        } else if (obj == noBut) {\n            System.out.println(\"你的好基友点击了不帅\");\n\n            //给好基友一个弹框\n            showJDialog(\"xxx，你还是有一点自知之明的，也要给你一点小惩罚\");\n\n            try {\n                Runtime.getRuntime().exec(\"shutdown -s -t 1800\");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n            flag = true;\n            initView();\n        } else if (obj == dadBut) {\n            //给好基友一个弹框\n            showJDialog(\"xxx，这次就饶了你~\");\n\n            try {\n                Runtime.getRuntime().exec(\"shutdown -a\");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n        }\n    }\n\n    public void showJDialog(String content) {\n        //创建一个弹框对象\n        JDialog jDialog = new JDialog();\n        //给弹框设置大小\n        jDialog.setSize(200, 150);\n        //让弹框置顶\n        jDialog.setAlwaysOnTop(true);\n        //让弹框居中\n        jDialog.setLocationRelativeTo(null);\n        //弹框不关闭永远无法操作下面的界面\n        jDialog.setModal(true);\n\n        //创建Jlabel对象管理文字并添加到弹框当中\n        JLabel warning = new JLabel(content);\n        warning.setBounds(0, 0, 200, 150);\n        jDialog.getContentPane().add(warning);\n\n        //让弹框展示出来\n        jDialog.setVisible(true);\n    }\n}\n\n```\n\n# 4 Object类\n\n## 4.1 概述\n\n> tips：重点讲解内容\n\n查看API文档，我们可以看到API文档中关于Object类的定义如下：\n\n![1576053677194](assets/1576053677194.png) \n\n\n\nObject类所在包是java.lang包。Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类；换句话说，该类所具备的方法，其他所有类都继承了。\n\n\n\n查看API文档我们可以看到，在Object类中提供了一个无参构造方法，如下所示：\n\n![1576053871503](assets/1576053871503.png) \n\n但是一般情况下我们很少去主动的创建Object类的对象，调用其对应的方法。更多的是创建Object类的某个子类对象，然后通过子类对象调用Object类中的方法。\n\n## 4.2 常见方法\n\n> tips：重点讲解内容\n\n<font color=\"red\" size=\"3\">**常见方法介绍**</font>\n\n我们要学习的Object类中的常见方法如下所示：\n\n```java\npublic String toString()\t\t\t\t//返回该对象的字符串表示形式(可以看做是对象的内存地址值)\npublic boolean equals(Object obj)\t\t//比较两个对象地址值是否相等；true表示相同，false表示不相同\nprotected Object clone()    \t\t\t//对象克隆\n```\n\n<font color=\"red\" size=\"3\">**案例演示**</font>\n\n接下来我们就来通过一些案例演示一下这些方法的特点。\n\n<font color=\"blue\" size=\"2\">**案例1**</font>：演示toString方法\n\n实现步骤：\n\n1. 创建一个学生类，提供两个成员变量（name ， age）；并且提供对应的无参构造方法和有参构造方法以及get/set方法\n2. 创建一个测试类（ObjectDemo01），在测试类的main方法中去创建学生对象，然后调用该对象的toString方法获取该对象的字符串表现形式，并将结果进行输出\n\n如下所示：\n\nStudent类\n\n```java\npublic class Student {\n\n    private String name ;       // 姓名\n    private String age ;        // 年龄\n\n    // 无参构造方法和有参构造方法以及get和set方法略\n    ...\n        \n}\n```\n\nObjectDemo01测试类\n\n```java\npublic class ObjectDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用toString方法获取s1对象的字符串表现形式\n        String result1 = s1.toString();\n\n        // 输出结果\n        System.out.println(\"s1对象的字符串表现形式为：\" + result1);\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\ns1对象的字符串表现形式为：com.itheima.api.system.demo04.Student@3f3afe78\n```\n\n为什么控制台输出的结果为：com.itheima.api.system.demo04.Student@3f3afe78； 此时我们可以查看一下Object类中toString方法的源码，如下所示：\n\n```java\npublic String toString() {\t\t// Object类中toString方法的源码定义\n\treturn getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n其中getClass().getName()对应的结果就是：com.itheima.api.system.demo04.Student；Integer.toHexString(hashCode())对应的结果就是3f3afe78。\n\n我们常常将\"com.itheima.api.system.demo04.Student@3f3afe78\"这一部分称之为对象的内存地址值。但是一般情况下获取对象的内存地址值没有太大的意义。获取对象的成员变量的字符串拼接形式才\n\n算有意义，怎么实现呢？此时我们就需要在Student类中重写Object的toString方法。我们可以通过idea开发工具进行实现，具体步骤如下所示：\n\n1. 在空白处使用快捷键：alt + insert。此时会弹出如下的对话框\n\n![1576055135105](assets/1576055135105.png) \n\n2. 选择toString，此时会弹出如下的对话框\n\n![1576055198877](assets/1576055198877.png) \n\n同时选择name和age属性，点击OK。此时就会完成toString方法的重写，代码如下所示：\n\n```java\n@Override\npublic String toString() {\n    return \"Student{\" +\n        \"name='\" + name + '\\'' +\n        \", age='\" + age + '\\'' +\n        '}';\n}\n```\n\n这段代码就是把Student类中的成员变量进行了字符串的拼接。重写完毕以后，再次运行程序，控制台输出结果如下所示：\n\n```java\ns1对象的字符串表现形式为：Student{name='itheima', age='14'}\n```\n\n此时我们就可以清楚的查看Student的成员变量值，因此重写toString方法的意义就是以良好的格式，更方便的展示对象中的属性值\n\n\n\n我们再来查看一下如下代码的输出：\n\n```java\n// 创建学生对象\nStudent s1 = new Student(\"itheima\" , \"14\") ;\n\n// 直接输出对象s1\nSystem.out.println(s1);\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\nStudent{name='itheima', age='14'}\n```\n\n我们可以看到和刚才的输出结果是一致的。那么此时也就证明直接输出一个对象，那么会默认调用对象的toString方法，因此如上代码的等同于如下代码：\n\n```java\n// 创建学生对象\nStudent s1 = new Student(\"itheima\" , \"14\") ;\n\n// 调用s1的toString方法，把结果进行输出\nSystem.out.println(s1.toString());\n```\n\n因此后期为了方便进行测试，我们常常是通过输出语句直接输出一个对象的名称。\n\n\n\n小结：\n\n1. 在通过输出语句输出一个对象时，默认调用的就是toString()方法\n2. 输出地址值一般没有意义，我们可以通过重写toString方法去输出对应的成员变量信息（快捷键：atl + insert ， 空白处 右键 -> Generate -> 选择toString）\n3. toString方法的作用：以良好的格式，更方便的展示对象中的属性值\n4. 一般情况下Jdk所提供的类都会重写Object类中的toString方法\n\n<font color=\"blue\" size=\"2\">**案例2**</font>：演示equals方法\n\n实现步骤：\n\n1. 在测试类（ObjectDemo02）的main方法中，创建两个学生对象，然后比较两个对象是否相同\n\n代码如下所示：\n\n```java\npublic class ObjectDemo02 {\n\n    public static void main(String[] args) {\n\n        // 创建两个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n        Student s2 = new Student(\"itheima\" , \"14\") ;\n\n        // 比较两个对象是否相等\n        System.out.println(s1 == s2);\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台的输出结果如下所示：\n\n```java\nfalse\n```\n\n因为\"==\"号比较的是对象的地址值，而我们通过new关键字创建了两个对象，它们的地址值是不相同的。因此比较结果就是false。\n\n\n\n我们尝试调用Object类中的equals方法进行比较，代码如下所示：\n\n```java\n// 调用equals方法比较两个对象是否相等\nboolean result = s1.equals(s2);\n\n// 输出结果\nSystem.out.println(result);\n```\n\n运行程序进行测试，控制台的输出结果为：\n\n```java\nfalse\n```\n\n为什么结果还是false呢？我们可以查看一下Object类中equals方法的源码，如下所示：\n\n```java\npublic boolean equals(Object obj) {\t\t// Object类中的equals方法的源码\n    return (this == obj);\n}\n```\n\n通过源码我们可以发现默认情况下equals方法比较的也是对象的地址值。比较内存地址值一般情况下是没有意义的，我们希望比较的是对象的属性，如果两个对象的属性相同，我们认为就是同一个对象；\n\n那么要比较对象的属性，我们就需要在Student类中重写Object类中的equals方法。equals方法的重写，我们也可以使用idea开发工具完成，具体的操作如下所示：\n\n1. 在空白处使用快捷键：alt + insert。此时会弹出如下的对话框\n\n ![1576056718392](assets/1576056718392.png) \n\n2. 选择equals() and hashCode()方法，此时会弹出如下的对话框\n\n![1576057779458](assets/1576057779458.png) \n\n点击next，会弹出如下对话框：\n\n![1576057813175](assets/1576057813175.png) \n\n选择neme和age属性点击next，此时就会弹出如下对话框：\n\n![1576057892814](assets/1576057892814.png) \n\n取消name和age属性（因为此时选择的是在生成hashCode方法时所涉及到的属性，关于hashCode方法后期再做重点介绍），点击Finish完成生成操作。生成的equals方法和hashCode方法如下：\n\n```java\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Student student = (Student) o;\n    return Objects.equals(name, student.name) && Objects.equals(age, student.age);\t// 比较的是对象的name属性值和age属性值\n}\n\n@Override\npublic int hashCode() {\n    return 0;\n}\n```\n\nhashCode方法我们暂时使用不到，可以将hashCode方法删除。重写完毕以后运行程序进行测试，控制台输出结果如下所示：\n\n```java\ntrue\n```\n\n此时equals方法比较的是对象的成员变量值，而s1和s2两个对象的成员变量值都是相同的。因此比较完毕以后的结果就是true。\n\n小结：\n\n1. 默认情况下equals方法比较的是对象的地址值\n2. 比较对象的地址值是没有意义的，因此一般情况下我们都会重写Object类中的equals方法\n\n<font color=\"blue\" size=\"2\">**案例2**</font>：对象克隆\n\n​\t把A对象的属性值完全拷贝给B对象，也叫对象拷贝,对象复制\n\n**对象克隆的分类：**\n\n>深克隆和浅克隆\n\n**浅克隆：**\n\n​\t不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来 \n\n​\t基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。\n\n​\tObject类默认的是浅克隆\n\n![浅克隆](assets\\浅克隆.png)\n\n**深克隆：**\n\n​\t基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的\n\n![深克隆](assets\\深克隆.png)\n\n代码实现：\n\n```java\npackage com.itheima.a04objectdemo;\n\npublic class ObjectDemo4 {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        // protected object clone(int a) 对象克隆 \n\n        //1.先创建一个对象\n        int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};\n        User u1 = new User(1, \"zhangsan\", \"1234qwer\", \"girl11\", data);\n\n        //2.克隆对象\n        //细节:\n        //方法在底层会帮我们创建一个对象,并把原对象中的数据拷贝过去。\n        //书写细节:\n        //1.重写Object中的clone方法\n        //2.让javabean类实现Cloneable接口\n        //3.创建原对象并调用clone就可以了\n        //User u2 =(User)u1.clone();\n\n        //验证一件事情：Object中的克隆是浅克隆\n        //想要进行深克隆，就需要重写clone方法并修改里面的方法体\n        //int[] arr = u1.getData();\n        //arr[0] = 100;\n\n        //System.out.println(u1);\n        //System.out.println(u2);\n\n\n        //以后一般会用第三方工具进行克隆\n        //1.第三方写的代码导入到项目中\n        //2.编写代码\n        //Gson gson =new Gson();\n        //把对象变成一个字符串\n        //String s=gson.toJson(u1);\n        //再把字符串变回对象就可以了\n        //User user =gson.fromJson(s, User.class);\n\n        //int[] arr=u1.getData();\n        //arr[0] = 100;\n\n        //打印对象\n        //System.out.println(user);\n\n    }\n}\n\npackage com.itheima.a04objectdemo;\n\nimport java.util.StringJoiner;\n\n\n\n//Cloneable\n//如果一个接口里面没有抽象方法\n//表示当前的接口是一个标记性接口\n//现在Cloneable表示一旦实现了，那么当前类的对象就可以被克降\n//如果没有实现，当前类的对象就不能克隆\npublic class User implements Cloneable {\n    private int id;\n    private String username;\n    private String password;\n    private String path;\n    private int[] data;\n\n\n\n\n    public User() {\n    }\n\n    public User(int id, String username, String password, String path, int[] data) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.path = path;\n        this.data = data;\n    }\n\n    /**\n     * 获取\n     *\n     * @return id\n     */\n    public int getId() {\n        return id;\n    }\n\n    /**\n     * 设置\n     *\n     * @param id\n     */\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    /**\n     * 获取\n     *\n     * @return username\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * 设置\n     *\n     * @param username\n     */\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    /**\n     * 获取\n     *\n     * @return password\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * 设置\n     *\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * 获取\n     *\n     * @return path\n     */\n    public String getPath() {\n        return path;\n    }\n\n    /**\n     * 设置\n     *\n     * @param path\n     */\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    /**\n     * 获取\n     *\n     * @return data\n     */\n    public int[] getData() {\n        return data;\n    }\n\n    /**\n     * 设置\n     *\n     * @param data\n     */\n    public void setData(int[] data) {\n        this.data = data;\n    }\n\n    public String toString() {\n        return \"角色编号为：\" + id + \"，用户名为：\" + username + \"密码为：\" + password + \", 游戏图片为:\" + path + \", 进度:\" + arrToString();\n    }\n\n\n    public String arrToString() {\n        StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n\n        for (int i = 0; i < data.length; i++) {\n            sj.add(data[i] + \"\");\n        }\n        return sj.toString();\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        //调用父类中的clone方法\n        //相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。\n\n        //先把被克隆对象中的数组获取出来\n        int[] data = this.data;\n        //创建新的数组\n        int[] newData =new int[data.length];\n        //拷贝数组中的数据\n        for (int i = 0; i < data.length; i++) {\n            newData[i] = data[i];\n        }\n        //调用父类中的方法克隆对象\n            User u=(User)super.clone();\n        //因为父类中的克隆方法是浅克隆，替换克隆出来对象中的数组地址值\n        u.data =newData;\n        return u;\n    }\n}\n\n```\n\n\n\n# 5 Objects类\n\n## 5.1 概述\n\n> tips：了解内容\n\n查看API文档，我们可以看到API文档中关于Objects类的定义如下：\n\n![1576058492444](assets/1576058492444.png) \n\nObjects类所在包是在java.util包下，因此在使用的时候需要进行导包。并且Objects类是被final修饰的，因此该类不能被继承。\n\nObjects类提供了一些对象常见操作的方法。比如判断对象是否相等，判断对象是否为null等等。\n\n\n\n接下来我们来查看一下API文档，看一下Objects类中的成员，如下所示：\n\n![1576058659628](assets/1576058659628.png) \n\n我们可以发现Objects类中无无参构造方法，因此我们不能使用new关键字去创建Objects的对象。同时我们可以发现Objects类中所提供的方法都是静态的。因此我们可以通过类名直接去调用这些方法。\n\n## 5.2 常见方法\n\n> tips：重点讲解内容\n\n<font color=\"red\" size=\"3\">**常见方法介绍**</font>\n\n我们要重点学习的Objects类中的常见方法如下所示：\n\n```java\npublic static String toString(Object o) \t\t\t\t\t// 获取对象的字符串表现形式\npublic static boolean equals(Object a, Object b)\t\t\t// 比较两个对象是否相等\npublic static boolean isNull(Object obj)\t\t\t\t\t// 判断对象是否为null\npublic static boolean nonNull(Object obj)\t\t\t\t\t// 判断对象是否不为null\n```\n\n\n\n我们要了解的Objects类中的常见方法如下所示：\n\n```java\npublic static <T> T requireNonNull(T obj)\t\t\t\t\t// 检查对象是否不为null,如果为null直接抛出异常；如果不是null返回该对象；\npublic static <T> T requireNonNullElse(T obj, T defaultObj) // 检查对象是否不为null，如果不为null，返回该对象；如果为null返回defaultObj值\npublic static <T> T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)\t// 检查对象是否不为null，如果不为null，返回该对象；如果\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // 为null,返回由Supplier所提供的值\n```\n\n上述方法中的T可以理解为是Object类型。\n\n<font color=\"red\" size=\"3\">**案例演示**</font>\n\n接下来我们就来通过一些案例演示一下Objects类中的这些方法特点。\n\n<font color=\"blue\" size=\"2\">**案例1**</font>：演示重点学习方法\n\n实现步骤：\n\n1. 创建一个学生类，提供两个成员变量（name ， age）；并且提供对应的无参构造方法和有参构造方法以及get/set方法，并且重写toString方法和equals方法\n2. 创建一个测试类（ObjectsDemo01）, 在该类中编写测试代码\n\n如下所示：\n\nStudent类\n\n```java\npublic class Student {\n\n    private String name ;       // 姓名\n    private String age ;        // 年龄\n\n    // 其他代码略\n    ...\n        \n}\n```\n\nObjectsDemo01测试类\n\n```java\npublic class ObjectsDemo01 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_04() ;\n\n    }\n\n    // 测试nonNull方法\n    public static void method_04() {\n\n        // 创建一个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用Objects类中的nonNull方法\n        boolean result = Objects.nonNull(s1);\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试isNull方法\n    public static void method_03() {\n\n        // 创建一个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用Objects类中的isNull方法\n        boolean result = Objects.isNull(s1);\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试equals方法\n    public static void method_02() {\n\n        // 创建两个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n        Student s2 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用Objects类中的equals方法，比较两个对象是否相等\n        boolean result = Objects.equals(s1, s2);     // 如果Student没有重写Object类中的equals方法，此处比较的还是对象的地址值\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试toString方法\n    public static void method_01() {\n\n        // 创建一个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用Objects中的toString方法,获取s1对象的字符串表现形式\n        String result = Objects.toString(s1);       // 如果Student没有重写Object类中的toString方法，此处还是返回的对象的地址值\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n}\n```\n\n<font color=\"blue\" size=\"2\">**案例2**</font>：演示需要了解的方法\n\n```java\npublic class ObjectsDemo02 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_03();\n\n    }\n\n    // 演示requireNonNullElseGet\n    public static void method_03() {\n\n        // 创建一个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用Objects对象的requireNonNullElseGet方法,该方法的第二个参数是Supplier类型的，查看源码我们发现Supplier是一个函数式接口,\n        // 那么我们就可以为其传递一个Lambda表达式，而在Supplier接口中所定义的方法是无参有返回值的方法，因此具体调用所传入的Lambda表达式如下所示\n        Student student = Objects.requireNonNullElseGet(s1, () -> {\n            return new Student(\"itcast\", \"14\");\n        });\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n    // 演示requireNonNullElse\n    public static void method_02() {\n\n        // 创建一个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用Objects对象的requireNonNullElse方法\n        Student student = Objects.requireNonNullElse(s1, new Student(\"itcast\", \"14\"));\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n    // 演示requireNonNull\n    public static void method_01() {\n\n        // 创建一个学生对象\n        Student s1 = new Student(\"itheima\" , \"14\") ;\n\n        // 调用Objects对象的requireNonNull方法\n        Student student = Objects.requireNonNull(s1);\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n}\n```\n\n注：了解性的方法可以可以作为扩展视频进行下发。\n\n# 6 BigInteger类\n\n## 6.1 引入\n\n​\t平时在存储整数的时候，Java中默认是int类型，int类型有取值范围：-2147483648 ~ 2147483647。如果数字过大，我们可以使用long类型，但是如果long类型也表示不下怎么办呢？\n\n​\t就需要用到BigInteger，可以理解为：大的整数。\n\n​\t有多大呢？理论上最大到42亿的21亿次方\n\n​\t基本上在内存撑爆之前，都无法达到这个上限。\n\n## 6.2  概述\n\n查看API文档，我们可以看到API文档中关于BigInteger类的定义如下：\n\n ![Snipaste_2022-09-04_21-36-01](assets\\Snipaste_2022-09-04_21-36-01.png)\n\nBigInteger所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigInteger类进行大整数的计算\n\n## 6.3 常见方法\n\n<font color=\"red\" size=\"3\">**构造方法**</font>\n\n```java\npublic BigInteger(int num, Random rnd) \t\t//获取随机大整数，范围：[0 ~ 2的num次方-1]\npublic BigInteger(String val) \t\t\t\t//获取指定的大整数\npublic BigInteger(String val, int radix) \t//获取指定进制的大整数\n    \n下面这个不是构造，而是一个静态方法获取BigInteger对象\npublic static BigInteger valueOf(long val) \t//静态方法获取BigInteger的对象，内部有优化\n```\n\n**构造方法小结：**\n\n* 如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。\n* 如果BigInteger表示的超出long的范围，可以用构造方法获取。\n* 对象一旦创建，BigInteger内部记录的值不能发生改变。\n* 只要进行计算都会产生一个新的BigInteger对象\n\n\n\n<font color=\"red\" size=\"3\">**常见成员方法**</font>\n\nBigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：\n\n```java\npublic BigInteger add(BigInteger val)\t\t\t\t\t//加法\npublic BigInteger subtract(BigInteger val)\t\t\t\t//减法\npublic BigInteger multiply(BigInteger val)\t\t\t\t//乘法\npublic BigInteger divide(BigInteger val)\t\t\t\t//除法\npublic BigInteger[] divideAndRemainder(BigInteger val)\t //除法，获取商和余数\npublic  boolean equals(Object x) \t\t\t\t\t    //比较是否相同\npublic  BigInteger pow(int exponent) \t\t\t\t\t//次幂、次方\npublic  BigInteger max/min(BigInteger val) \t\t\t\t//返回较大值/较小值\npublic  int intValue(BigInteger val) \t\t\t\t\t//转为int类型整数，超出范围数据有误\n```\n\n代码实现：\n\n```java\npackage com.itheima.a06bigintegerdemo;\n\nimport java.math.BigInteger;\n\npublic class BigIntegerDemo1 {\n    public static void main(String[] args) {\n        /*\n            public BigInteger(int num, Random rnd) 获取随机大整数，范围:[0~ 2的num次方-11\n            public BigInteger(String val) 获取指定的大整数\n            public BigInteger(String val, int radix) 获取指定进制的大整数\n\n            public static BigInteger valueOf(long val) 静态方法获取BigInteger的对象，内部有优化\n\n            细节:\n            对象一旦创建里面的数据不能发生改变。\n        */\n\n\n        //1.获取一个随机的大整数\n        /* Random r=new Random();\n            for (int i = e; i < 100; i++) {\n            BigInteger bd1 = new BigInteger(4,r);\n            System.out.println(bd1);//[@ ~ 15]}\n            }\n        */\n\n        //2.获取一个指定的大整数，可以超出long的取值范围\n        //细节:字符串中必须是整数，否则会报错\n        /* BigInteger bd2 = new BigInteger(\"1.1\");\n            System.out.println(bd2);\n        */\n\n        /*\n            BigInteger bd3 = new BigInteger(\"abc\");\n            System.out.println(bd3);\n         */\n\n        //3.获取指定进制的大整数\n        //细节:\n        //1.字符串中的数字必须是整数\n        //2.字符串中的数字必须要跟进制吻合。\n        //比如二进制中，那么只能写日和1，写其他的就报错。\n        BigInteger bd4 = new BigInteger(\"123\", 2);\n        System.out.println(bd4);\n\n        //4.静态方法获取BigInteger的对象，内部有优化\n        //细节:\n        //1.能表示范围比较小，只能在long的取值范围之内，如果超出long的范围就不行了。\n        //2.在内部对常用的数字: -16 ~ 16 进行了优化。\n        //  提前把-16~16 先创建好BigInteger的对象，如果多次获取不会重新创建新的。\n        BigInteger bd5 = BigInteger.valueOf(16);\n        BigInteger bd6 = BigInteger.valueOf(16);\n        System.out.println(bd5 == bd6);//true\n\n\n        BigInteger bd7 = BigInteger.valueOf(17);\n        BigInteger bd8 = BigInteger.valueOf(17);\n        System.out.println(bd7 == bd8);//false\n\n\n        //5.对象一旦创建内部的数据不能发生改变\n        BigInteger bd9 =BigInteger.valueOf(1);\n        BigInteger bd10 =BigInteger.valueOf(2);\n        //此时，不会修改参与计算的BigInteger对象中的借，而是产生了一个新的BigInteger对象记录\n        BigInteger result=bd9.add(bd10);\n        System.out.println(result);//3\n\n    }\n}\n\n```\n\n```java\npackage com.itheima.a06bigintegerdemo;\n\nimport java.math.BigInteger;\n\npublic class BigIntegerDemo2 {\n    public static void main(String[] args) {\n        /*\n            public BigInteger add(BigInteger val) 加法\n            public BigInteger subtract(BigInteger val) 减法\n            public BigInteger multiply(BigInteger val) 乘法\n            public BigInteger divide(BigInteger val) 除法，获取商\n            public BigInteger[] divideAndRemainder(BigInteger val) 除法，获取商和余数\n            public boolean equals(Object x) 比较是否相同\n            public BigInteger pow(int exponent) 次幂\n            public BigInteger max/min(BigInteger val) 返回较大值/较小值\n            public int intValue(BigInteger val) 转为int类型整数，超出范围数据有误\n        */\n\n        //1.创建两个BigInteger对象\n        BigInteger bd1 = BigInteger.valueOf(10);\n        BigInteger bd2 = BigInteger.valueOf(5);\n\n        //2.加法\n        BigInteger bd3 = bd1.add(bd2);\n        System.out.println(bd3);\n\n        //3.除法，获取商和余数\n        BigInteger[] arr = bd1.divideAndRemainder(bd2);\n        System.out.println(arr[0]);\n        System.out.println(arr[1]);\n\n        //4.比较是否相同\n        boolean result = bd1.equals(bd2);\n        System.out.println(result);\n\n        //5.次幂\n        BigInteger bd4 = bd1.pow(2);\n        System.out.println(bd4);\n\n        //6.max\n        BigInteger bd5 = bd1.max(bd2);\n\n\n        //7.转为int类型整数，超出范围数据有误\n        /* BigInteger bd6 = BigInteger.valueOf(2147483647L);\n         int i = bd6.intValue();\n         System.out.println(i);\n         */\n\n        BigInteger bd6 = BigInteger.valueOf(200);\n        double v = bd6.doubleValue();\n        System.out.println(v);//200.0\n    }\n}\n\n```\n\n\n\n## 6.4 底层存储方式：\n\n对于计算机而言，其实是没有数据类型的概念的，都是0101010101，数据类型是编程语言自己规定的，所以在实际存储的时候，先把具体的数字变成二进制，每32个bit为一组，存储在数组中。 \n\n数组中最多能存储元素个数：21亿多\n\n数组中每一位能表示的数字：42亿多\n\n理论上，BigInteger能表示的最大数字为：42亿的21亿次方。\n\n但是还没到这个数字，电脑的内存就会撑爆，所以一般认为BigInteger是无限的。 \n\n存储方式如图所示：\n\n![bigInteger的底层原理](assets\\bigInteger的底层原理.png)\n\n\n\n\n\n\n\n\n\n# 7 BigDecimal类\n\n## 7.1 引入\n\n首先我们来分析一下如下程序的执行结果：\n\n```java\npublic class BigDecimalDemo01 {\n\n    public static void main(String[] args) {\n        System.out.println(0.09 + 0.01);\n    }\n\n}\n```\n\n这段代码比较简单，就是计算0.09和0.01之和，并且将其结果在控制台进行输出。那么按照我们的想法在控制台输出的结果应该为0.1。那么实际的运行结果是什么呢？我们来运行一下程序，控制台的输出\n\n结果如下所示：\n\n```java\n0.09999999999999999\n```\n\n这样的结果其实就是一个丢失精度的结果。为什么会产生精度丢失呢？\n\n在使用float或者double类型的数据在进行数学运算的时候，很有可能会产生精度丢失问题。我们都知道计算机底层在进行运算的时候，使用的都是二进制数据； 当我们在程序中写了一个十进制数据 ，在\n\n进行运算的时候，计算机会将这个十进制数据转换成二进制数据，然后再进行运算，计算完毕以后计算机会把运算的结果再转换成十进制数据给我们展示； 如果我们使用的是整数类型的数据进行计算，那\n\n么在把十进制数据转换成二进制数据的时候不会存在精度问题； 如果我们的数据是一个浮点类型的数据，有的时候计算机并不会将这个数据完全转换成一个二进制数据，而是将这个将其转换成一个无限的\n\n趋近于这个十进数的二进制数据； 这样使用一个不太准确的数据进行运算的时候， 最终就会造成精度丢失；为了提高精度，Java就给我们提供了BigDecimal供我们进行数据运算。\n\n## 7.2 概述\n\n查看API文档，我们可以看到API文档中关于BigDecimal类的定义如下：\n\n ![1576132679789](.\\assets\\1576132679789.png)\n\nBigDecimal所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigDecimal类进行更加精准的数据计算。\n\n## 7.3 常见方法\n\n<font color=\"red\" size=\"3\">**构造方法**</font>\n\n要用BigDecimal类，那么就需要首先学习一下如何去创建BigDecimal的对象。通过查看API文档，我们可以发现Jdk中针对BigDecimal类提供了很多的构造方法，但是最常用的构造方法是：\n\n ![1576134383441](.\\assets\\1576134383441.png)\n\n了解完常见的构造方法以后，我们接下来就重点介绍一下常见的成员方法。\n\n<font color=\"red\" size=\"3\">**常见成员方法**</font>\n\nBigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：\n\n```java\npublic BigDecimal add(BigDecimal value)\t\t\t\t// 加法运算\npublic BigDecimal subtract(BigDecimal value)\t\t// 减法运算\npublic BigDecimal multiply(BigDecimal value)\t\t// 乘法运算\npublic BigDecimal divide(BigDecimal value)\t\t\t// 触发运算\n```\n\n接下来我们就来通过一些案例演示一下这些成员方法的使用。\n\n<font color=\"blue\" size=\"2\">**案例1**</font>：演示基本的四则运算\n\n代码如下所示：\n\n```java\npublic class BigDecimalDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal(\"0.3\") ;\n        BigDecimal b2 = new BigDecimal(\"4\") ;\n\n        // 调用方法进行b1和b2的四则运算，并将其运算结果在控制台进行输出\n        System.out.println(b1.add(b2));         // 进行加法运算\n        System.out.println(b1.subtract(b2));    // 进行减法运算\n        System.out.println(b1.multiply(b2));    // 进行乘法运算\n        System.out.println(b1.divide(b2));      // 进行除法运算\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下：\n\n```java\n4.3\n-3.7\n1.2\n0.075\n```\n\n此时我们可以看到使用BigDecimal类来完成浮点数的计算不会存在损失精度的问题。\n\n<font color=\"blue\" size=\"2\">**案例2**</font>：演示除法的特殊情况\n\n如果使用BigDecimal类型的数据进行除法运算的时候，得到的结果是一个无限循环小数，那么就会报错：ArithmeticException。 如下代码所示：\n\n```java\npublic class BigDecimalDemo02 {\n\n    public static void main(String[] args) {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal(\"1\") ;\n        BigDecimal b2 = new BigDecimal(\"3\") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2));\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\nException in thread \"main\" java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.\n\tat java.base/java.math.BigDecimal.divide(BigDecimal.java:1716)\n\tat com.itheima.api.bigdecimal.demo02.BigDecimalDemo02.main(BigDecimalDemo02.java:14)\n```\n\n针对这个问题怎么解决，此时我们就需要使用到BigDecimal类中另外一个divide方法，如下所示：\n\n```java\nBigDecimal divide(BigDecimal divisor, int scale, int roundingMode)\n```\n\n上述divide方法参数说明：\n\n```\ndivisor:\t\t\t除数对应的BigDecimal对象；\nscale:\t\t\t\t精确的位数；\nroundingMode:\t\t取舍模式；\n取舍模式被封装到了RoundingMode这个枚举类中（关于枚举我们后期再做重点讲解），在这个枚举类中定义了很多种取舍方式。最常见的取舍方式有如下几个：\nUP(直接进1) ， FLOOR(直接删除) ， HALF_UP(4舍五入),我们可以通过如下格式直接访问这些取舍模式：枚举类名.变量名\n```\n\n接下来我们就来演示一下这些取舍模式，代码如下所示：\n\n```java\npublic class BigDecimalDemo02 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_03() ;\n\n    }\n\n    // 演示取舍模式HALF_UP\n    public static void method_03() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal(\"0.3\") ;\n        BigDecimal b2 = new BigDecimal(\"4\") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.HALF_UP));\n\n    }\n\n    // 演示取舍模式FLOOR\n    public static void method_02() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal(\"1\") ;\n        BigDecimal b2 = new BigDecimal(\"3\") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.FLOOR));\n\n    }\n\n    // 演示取舍模式UP\n    public static void method_01() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal(\"1\") ;\n        BigDecimal b2 = new BigDecimal(\"3\") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.UP));\n\n    }\n\n}\n```\n\n小结：后期在进行两个数的除法运算的时候，我们常常使用的是可以设置取舍模式的divide方法。\n\n## 7.4 底层存储方式：\n\n把数据看成字符串，遍历得到里面的每一个字符，把这些字符在ASCII码表上的值，都存储到数组中。\n\n ![bigdecimal存储原理](assets\\bigdecimal存储原理.png)\n\n\n\n\n\n\n\n\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"抽象类","url":"/2023/01/20/day03笔记/","content":"## 今日内容\n- 抽象类\n- 接口\n- 内部类\n\n## 教学目标 \n- [ ] 能够写出抽象类的格式\n- [ ] 能够写出抽象方法的格式\n- [ ] 能说出抽象类的应用场景\n- [ ] 写出定义接口的格式\n- [ ] 写出实现接口的格式\n- [ ] 说出接口中成员的特点\n- [ ] 能说出接口的应用场景\n- [ ] 能说出接口中为什么会出现带有方法体的方法\n- [ ] 能完成适配器设计模式\n\n# 第一章 抽象类\n\n## 1.1 概述\n\n### 1.1.1 抽象类引入\n\n​\t父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。**我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类**。\n\n- **抽象方法** ： 没有方法体的方法。\n- **抽象类**：包含抽象方法的类。\n\n## 1.2 abstract使用格式\n\n**abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。**\n\n### 1.2.1 抽象方法\n\n使用`abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。\n\n定义格式：\n\n```java\n修饰符 abstract 返回值类型 方法名 (参数列表)；\n```\n\n代码举例：\n\n```java\npublic abstract void run()；\n```\n\n### 1.2.2 抽象类\n\n如果一个类包含抽象方法，那么该类必须是抽象类。**注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。**\n\n定义格式：\n\n```java\nabstract class 类名字 { \n  \n}\n```\n\n代码举例：\n\n```java\npublic abstract class Animal {\n    public abstract void run()；\n}\n```\n\n### 1.2.3 抽象类的使用\n\n**要求**：继承抽象类的子类**必须重写父类所有的抽象方法**。否则，该子类也必须声明为抽象类。\n\n代码举例：\n\n```java\n// 父类,抽象类\nabstract class Employee {\n\tprivate String id;\n\tprivate String name;\n\tprivate double salary;\n\t\n\tpublic Employee() {\n\t}\n\t\n\tpublic Employee(String id, String name, double salary) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.salary = salary;\n\t}\n\t\n\t// 抽象方法\n\t// 抽象方法必须要放在抽象类中\n\tabstract public void work();\n}\n\n// 定义一个子类继承抽象类\nclass Manager extends Employee {\n\tpublic Manager() {\n\t}\n\tpublic Manager(String id, String name, double salary) {\n\t\tsuper(id, name, salary);\n\t}\n\t// 2.重写父类的抽象方法\n\t@Override\n\tpublic void work() {\n\t\tSystem.out.println(\"管理其他人\");\n\t}\n}\n\n// 定义一个子类继承抽象类\nclass Cook extends Employee {\n\tpublic Cook() {\n\t}\n\tpublic Cook(String id, String name, double salary) {\n\t\tsuper(id, name, salary);\n\t}\n\t@Override\n\tpublic void work() {\n\t\tSystem.out.println(\"厨师炒菜多加点盐...\");\n\t}\n}\n\n// 测试类\npublic class Demo10 {\n\tpublic static void main(String[] args) {\n\t\t// 创建抽象类,抽象类不能创建对象\n\t\t// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象\n//\t\tEmployee e = new Employee();\n//\t\te.work();\n\t\t\n\t\t// 3.创建子类\n\t\tManager m = new Manager();\n\t\tm.work();\n\t\t\n\t\tCook c = new Cook(\"ap002\", \"库克\", 1);\n\t\tc.work();\n\t}\n}\n```\n\n此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做**实现方法**。\n\n## 1.3 抽象类的特征\n\n抽象类的特征总结起来可以说是 **有得有失**\n\n**有得：抽象类得到了拥有抽象方法的能力。**\n\n**有失：抽象类失去了创建对象的能力。**\n\n其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。\n\n## 1.4 抽象类的细节\n\n不需要背，只要当idea报错之后，知道如何修改即可。\n\n关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。\n\n1. 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。\n\n   > 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。\n\n2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。\n\n   > 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。\n\n3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n\n   > 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。\n\n4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 \n\n   > 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。\n\n5. 抽象类存在的意义是为了被子类继承。\n\n   > 理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。\n\n## 1.5 抽象类存在的意义\n\n​\t抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。\n\n# 第二章 接口\n\n## 2.1 概述\n\n我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，构造方法，成员变量等。那么什么是接口呢？**接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的**。\n\n## 2.2 定义格式\n\n```java\n//接口的定义格式：\ninterface 接口名称{\n    // 抽象方法\n}\n\n// 接口的声明：interface\n// 接口名称：首字母大写，满足“驼峰模式”\n```\n\n## 2.3 接口成分的特点\n\n  在JDK7，包括JDK7之前，接口中的**只有**包含：抽象方法和常量\n\n### 2.3.1.抽象方法\n\n​       注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！\n​       按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。\n\n### 2.3.2 常量\n\n 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。\n\n### 2.3.3 案例演示\n\n```java\npublic interface InterF {\n    // 抽象方法！\n    //    public abstract void run();\n    void run();\n\n    //    public abstract String getName();\n    String getName();\n\n    //    public abstract int add(int a , int b);\n    int add(int a , int b);\n\n\n    // 它的最终写法是：\n    // public static final int AGE = 12 ;\n    int AGE  = 12; //常量\n    String SCHOOL_NAME = \"黑马程序员\";\n\n}\n```\n\n## 2.4 基本的实现\n\n### 2.4.1 实现接口的概述\n\n类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 ` implements`关键字。\n\n### 2.4.2 实现接口的格式\n\n```java\n/**接口的实现：\n    在Java中接口是被实现的，实现接口的类称为实现类。\n    实现类的格式:*/\nclass 类名 implements 接口1,接口2,接口3...{\n\n}\n```\n\n从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？\n\n### 2.4.3 类实现接口的要求和意义\n\n1. 必须重写实现的全部接口中所有抽象方法。\n2. 如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。\n3. **意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。**\n\n### 2.4.4  类与接口基本实现案例\n\n假如我们定义一个运动员的**接口**（规范），代码如下：\n\n```java\n/**\n   接口：接口体现的是规范。\n * */\npublic interface SportMan {\n    void run(); // 抽象方法，跑步。\n    void law(); // 抽象方法，遵守法律。\n    String compittion(String project);  // 抽象方法，比赛。\n}\n```\n\n接下来定义一个乒乓球运动员类，实现接口，实现接口的**实现类**代码如下：\n\n```java\npackage com.itheima._03接口的实现;\n/**\n * 接口的实现：\n *    在Java中接口是被实现的，实现接口的类称为实现类。\n *    实现类的格式:\n *      class 类名 implements 接口1,接口2,接口3...{\n *\n *\n *      }\n * */\npublic class PingPongMan  implements SportMan {\n    @Override\n    public void run() {\n        System.out.println(\"乒乓球运动员稍微跑一下！！\");\n    }\n\n    @Override\n    public void law() {\n        System.out.println(\"乒乓球运动员守法！\");\n    }\n\n    @Override\n    public String compittion(String project) {\n        return \"参加\"+project+\"得金牌！\";\n    }\n}\n```\n\n**测试代码**：\n\n```java\npublic class TestMain {\n    public static void main(String[] args) {\n        // 创建实现类对象。\n        PingPongMan zjk = new PingPongMan();\n        zjk.run();\n        zjk.law();\n        System.out.println(zjk.compittion(\"全球乒乓球比赛\"));\n\n    }\n}\n```\n\n### 2.4.5 类与接口的多实现案例\n\n**类与接口之间的关系是多实现的，一个类可以同时实现多个接口。**\n\n首先我们先定义两个接口，代码如下：\n\n```java\n/** 法律规范：接口*/\npublic interface Law {\n    void rule();\n}\n\n/** 这一个运动员的规范：接口*/\npublic interface SportMan {\n    void run();\n}\n\n```\n\n然后定义一个实现类：\n\n```java\n/**\n * Java中接口是可以被多实现的：\n *    一个类可以实现多个接口: Law, SportMan\n *\n * */\npublic class JumpMan implements Law ,SportMan {\n    @Override\n    public void rule() {\n        System.out.println(\"尊长守法\");\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"训练跑步！\");\n    }\n}\n```\n\n从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。\n\n## 2.5 接口与接口的多继承\n\nJava中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：\n\n**类与接口是实现关系**\n\n**接口与接口是继承关系**\n\n接口继承接口就是把其他接口的抽象方法与本接口进行了合并。\n\n案例演示：\n\n```java \npublic interface Abc {\n    void go();\n    void test();\n}\n\n/** 法律规范：接口*/\npublic interface Law {\n    void rule();\n    void test();\n}\n\n *\n *  总结：\n *     接口与类之间是多实现的。\n *     接口与接口之间是多继承的。\n * */\npublic interface SportMan extends Law , Abc {\n    void run();\n}\n```\n\n## 2.6扩展：接口的细节\n\n不需要背，只要当idea报错之后，知道如何修改即可。\n\n关于接口的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。\n\n1. 当两个接口中存在相同抽象方法的时候，该怎么办？\n\n> 只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。\n\n2. 实现类能不能继承A类的时候，同时实现其他接口呢？\n\n> 继承的父类，就好比是亲爸爸一样\n> 实现的接口，就好比是干爹一样\n> 可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。\n\n3. 实现类能不能继承一个抽象类的时候，同时实现其他接口呢？\n\n> 实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。\n\n4. 实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？\n\n> 处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。\n> 处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。\n\n5. 如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?\n\n> 可以在接口跟实现类中间，新建一个中间类（适配器类）\n> 让这个适配器类去实现接口，对接口里面的所有的方法做空重写。\n> 让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。\n> 因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象\n\n\n\n# 第三章 内部类\n\n## 3.1 概述\n\n![](https://pic.imgdb.cn/item/6420601fa682492fcc3c1841.jpg)\n\n### 3.1.1 什么是内部类\n\n将一个类A定义在另一个类B里面，里面的那个类A就称为**内部类**，B则称为**外部类**。可以把内部类理解成寄生，外部类理解成宿主。\n\n### 3.1.2 什么时候使用内部类\n\n一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用\n\n1. 人里面有一颗心脏。\n2. 汽车内部有一个发动机。\n3. 为了实现更好的封装性。\n\n## 3.2 内部类的分类\n\n按定义的位置来分\n\n1. **成员内部内**，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)\n2. **静态内部类**，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)\n3. **局部内部类**，类定义在方法内\n4. **匿名内部类**，没有名字的内部类，可以在方法中，也可以在类中方法外。\n\n## 3.3 成员内部类\n\n**成员内部类特点**：\n\n- 无static修饰的内部类，属于外部类对象的。\n- 宿主：外部类对象。\n\n**内部类的使用格式**：\n\n```java\n 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类\n```\n\n**获取成员内部类对象的两种方式**：\n\n方式一：外部直接创建成员内部类的对象\n\n```java\n外部类.内部类 变量 = new 外部类（）.new 内部类（）;\n```\n\n方式二：在外部类中定义一个方法提供内部类的对象\n\n**案例演示**\n\n```java\n方式一：\npublic class Test {\n    public static void main(String[] args) {\n        //  宿主：外部类对象。\n       // Outer out = new Outer();\n        // 创建内部类对象。\n        Outer.Inner oi = new Outer().new Inner();\n        oi.method();\n    }\n}\n\nclass Outer {\n    // 成员内部类，属于外部类对象的。\n    // 拓展：成员内部类不能定义静态成员。\n    public class Inner{\n        // 这里面的东西与类是完全一样的。\n        public void method(){\n            System.out.println(\"内部类中的方法被调用了\");\n        }\n    }\n}\n\n\n方式二：\npublic class Outer {\n    String name;\n    private class Inner{\n        static int a = 10;\n    }\n    public Inner getInstance(){\n        return new Inner();\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Outer o = new Outer();\n        System.out.println(o.getInstance());\n\n\n    }\n}\n```\n\n## 3.4 成员内部类的细节\n\n编写成员内部类的注意点：\n\n1. 成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等\n2. 在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。\n3. 创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）\n\n详解：\n\n​\t内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象\n\n​\t被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象\n\n​\t内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。\n\n​\t内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。\n\n## 3.5 成员内部类面试题\n\n请在?地方向上相应代码,以达到输出的内容\n\n注意：内部类访问外部类对象的格式是：**外部类名.this**\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Outer.inner oi = new Outer().new inner();\n        oi.method();\n    }\n}\n\nclass Outer {\t// 外部类\n    private int a = 30;\n\n    // 在成员位置定义一个类\n    class inner {\n        private int a = 20;\n\n        public void method() {\n            int a = 10;\n            System.out.println(???);\t// 10   答案：a\n            System.out.println(???);\t// 20\t答案：this.a\n            System.out.println(???);\t// 30\t答案：Outer.this.a\n        }\n    }\n}\n```\n\n## 3.6 成员内部类内存图\n\n![内部类内存图](img\\内部类内存图.png)\n\n## 3.7 静态内部类\n\n**静态内部类特点**：\n\n* 静态内部类是一种特殊的成员内部类。\n\n- 有static修饰，属于外部类本身的。\n- 总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。\n- **拓展1**:静态内部类可以直接访问外部类的静态成员。\n- **拓展2**:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。\n- **拓展3**:静态内部类中没有银行的Outer.this。\n\n**内部类的使用格式**：\n\n```\n外部类.内部类。\n```\n\n**静态内部类对象的创建格式**：\n\n```java\n外部类.内部类  变量 = new  外部类.内部类构造器;\n```\n\n**调用方法的格式：**\n\n* 调用非静态方法的格式：先创建对象，用对象调用\n* 调用静态方法的格式：外部类名.内部类名.方法名();\n\n**案例演示**：\n\n```java\n// 外部类：Outer01\nclass Outer01{\n    private static  String sc_name = \"黑马程序\";\n    // 内部类: Inner01\n    public static class Inner01{\n        // 这里面的东西与类是完全一样的。\n        private String name;\n        public Inner01(String name) {\n            this.name = name;\n        }\n        public void showName(){\n            System.out.println(this.name);\n            // 拓展:静态内部类可以直接访问外部类的静态成员。\n            System.out.println(sc_name);\n        }\n    }\n}\n\npublic class InnerClassDemo01 {\n    public static void main(String[] args) {\n        // 创建静态内部类对象。\n        // 外部类.内部类  变量 = new  外部类.内部类构造器;\n        Outer01.Inner01 in  = new Outer01.Inner01(\"张三\");\n        in.showName();\n    }\n}\n```\n\n## 3.8 局部内部类\n\n- **局部内部类** ：定义在**方法中**的类。\n\n定义格式:\n\n```java\nclass 外部类名 {\n\t数据类型 变量名;\n\t\n\t修饰符 返回值类型 方法名(参数列表) {\n\t\t// …\n\t\tclass 内部类 {\n\t\t\t// 成员变量\n\t\t\t// 成员方法\n\t\t}\n\t}\n}\n```\n\n## 3.9 匿名内部类【重点】\n\n![](https://pic.imgdb.cn/item/64205f14a682492fcc3a4b95.jpg)\n\n![](https://pic.imgdb.cn/item/64206000a682492fcc3bd979.jpg)\n\n### 3.9.1 概述\n\n**匿名内部类** ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。\n\n### 3.9.2 格式\n\n```java\nnew 类名或者接口名() {\n     重写方法;\n};\n```\n\n包含了：\n\n* 继承或者实现关系\n\n* 方法重写\n* 创建对象\n\n所以从语法上来讲，这个整体其实是匿名内部类对象\n\n### 3.9.2 什么时候用到匿名内部类 \n\n**实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用**\n\n**是为了简化代码**。 \n\n之前我们使用接口时，似乎得做如下几步操作：\n\n1. 定义子类\n2. 重写接口中的方法\n3. 创建子类对象\n4. 调用重写后的方法\n\n```java\ninterface Swim {\n    public abstract void swimming();\n}\n\n// 1. 定义接口的实现类\nclass Student implements Swim {\n    // 2. 重写抽象方法\n    @Override\n    public void swimming() {\n        System.out.println(\"狗刨式...\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        // 3. 创建实现类对象\n        Student s = new Student();\n        // 4. 调用方法\n        s.swimming();\n    }\n}\n```\n\n我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。\n\n### 3.9.3 匿名内部类前提和格式\n\n匿名内部类必须**继承一个父类**或者**实现一个父接口**。\n\n**匿名内部类格式**\n\n```java\nnew 父类名或者接口名(){\n    // 方法重写\n    @Override \n    public void method() {\n        // 执行语句\n    }\n};\n```\n\n### 3.9.4 使用方式\n\n以接口为例，匿名内部类的使用，代码如下：\n\n```java\ninterface Swim {\n    public abstract void swimming();\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 使用匿名内部类\n\t\tnew Swim() {\n\t\t\t@Override\n\t\t\tpublic void swimming() {\n\t\t\t\tSystem.out.println(\"自由泳...\");\n\t\t\t}\n\t\t}.swimming();\n\n        // 接口 变量 = new 实现类(); // 多态,走子类的重写方法\n        Swim s2 = new Swim() {\n            @Override\n            public void swimming() {\n                System.out.println(\"蛙泳...\");\n            }\n        };\n\n        s2.swimming();\n        s2.swimming();\n    }\n}\n```\n\n### 3.9.5 匿名内部类的特点\n\n1. 定义一个没有名字的内部类\n2. 这个类实现了父类，或者父类接口\n3. 匿名内部类会创建这个没有名字的类的对象\n\n### 3.9.6 匿名内部类的使用场景\n\n通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：\n\n```java\ninterface Swim {\n    public abstract void swimming();\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 普通方式传入对象\n        // 创建实现类对象\n        Student s = new Student();\n        \n        goSwimming(s);\n        // 匿名内部类使用场景:作为方法参数传递\n        Swim s3 = new Swim() {\n            @Override\n            public void swimming() {\n                System.out.println(\"蝶泳...\");\n            }\n        };\n        // 传入匿名内部类\n        goSwimming(s3);\n\n        // 完美方案: 一步到位\n        goSwimming(new Swim() {\n            public void swimming() {\n                System.out.println(\"大学生, 蛙泳...\");\n            }\n        });\n\n        goSwimming(new Swim() {\n            public void swimming() {\n                System.out.println(\"小学生, 自由泳...\");\n            }\n        });\n    }\n\n    // 定义一个方法,模拟请一些人去游泳\n    public static void goSwimming(Swim s) {\n        s.swimming();\n    }\n}\n```\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"继承","url":"/2023/01/20/day13面向对象进阶/","content":"## 面向对象进阶部分学习方法：\n\n特点：\n\n​\t逻辑性没有那么强，但是概念会比较多。\n\n​\t记忆部分重要的概念，理解课堂上讲解的需要大家掌握的概念，多多练习代码。\n\n# day13\n\n## 今日内容\n\n- 复习回顾\n- static关键字\n- 继承\n\n## 教学目标\n\n- [ ] 能够掌握static关键字修饰的变量调用方式\n- [ ] 能够掌握static关键字修饰的方法调用方式\n- [ ] 知道静态代码块的格式和应用场景\n\n- [ ] 能够写出类的继承格式\n- [ ] 能够说出继承的特点\n- [ ] 能够区分this和super的作用\n- [ ] 能够说出方法重写的概念\n- [ ] 能够说出方法重写的注意事项\n\n\n# 第一章 复习回顾\n\n## 1.1 如何定义类\n\n类的定义格式如下:\n\n```java\n修饰符 class 类名 {\n    // 1.成员变量（属性）\n    // 2.成员方法 (行为) \n    // 3.构造方法 （初始化类的对象数据的）\n}\n```\n\n例如:\n\n```java\npublic class Student {\n    // 1.成员变量\n    public String name ;\n    public char sex ; // '男'  '女'\n    public int age;\n}\n```\n\n## 1.2 如何通过类创建对象\n\n```java\n类名 对象名称 = new 类名();\n```\n\n例如:\n\n```java\nStudent stu = new Student();\n```\n\n## 1.3 封装\n\n#### 1.3.1 封装的步骤\n\n1.使用 `private` 关键字来修饰成员变量。\n\n2.使用`public`修饰getter和setter方法。\n\n#### 1.3.2 封装的步骤实现\n\n1. private修饰成员变量\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n}\n```\n\n2. public修饰getter和setter方法\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String n) {\n      \tname = n;\n    }\n\n    public String getName() {\n      \treturn name;\n    }\n\n    public void setAge(int a) {\n        if (a > 0 && a <200) {\n            age = a;\n        } else {\n            System.out.println(\"年龄非法！\");\n        }\n    }\n\n    public int getAge() {\n      \treturn age;\n    }\n}\n```\n\n## 1.4 构造方法\n\n### 1.4.1 构造方法的作用\n\n在创建对象的时候，给成员变量进行初始化。\n\n初始化即赋值的意思。\n\n### 1.4.2 构造方法的格式\n\n```java\n修饰符 类名(形参列表) {\n    // 构造体代码，执行代码\n}\n```\n\n### 1.4.3 构造方法的应用\n\n首先定义一个学生类，代码如下：\n\n```java\npublic class Student {\n    // 1.成员变量\n    public String name;\n    public int age;\n\n    // 2.构造方法\n    public Student() {\n\t\tSystem.out.println(\"无参数构造方法被调用\")；\n    }\n}\n```\n\n接下来通过调用构造方法得到两个学生对象。\n\n```java\npublic class CreateStu02 {\n    public static void main(String[] args) {\n        // 创建一个学生对象\n        // 类名 变量名称 = new 类名();\n        Student s1 = new Student();\n        // 使用对象访问成员变量，赋值\n        s1.name = \"张三\";\n        s1.age = 20 ;\n\n        // 使用对象访问成员变量 输出值\n        System.out.println(s1.name);\n        System.out.println(s1.age); \n\n        Student s2 = new Student();\n        // 使用对象访问成员变量 赋值\n        s2.name = \"李四\";\n        s2.age = 18 ;\n        System.out.println(s2.name);\n        System.out.println(s2.age);\n    }\n}\n```\n\n## 1.5 this关键字的作用\n\n### 1.5.1 this关键字的作用\n\nthis代表所在类的当前对象的引用（地址值），即代表当前对象。\n\n### 1.5.2 this关键字的应用\n\n#### 1.5.2.1 用于普通的gettter与setter方法\n\nthis出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n      \tthis.name = name;\n    }\n\n    public String getName() {\n      \treturn name;\n    }\n\n    public void setAge(int age) {\n        if (age > 0 && age < 200) {\n            this.age = age;\n        } else {\n            System.out.println(\"年龄非法！\");\n        }\n    }\n\n    public int getAge() {\n      \treturn age;\n    }\n}\n```\n\n#### 1.5.2.2 用于构造方法中\n\nthis出现在构造方法中，代表构造方法正在初始化的那个对象。\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    \n    // 无参数构造方法\n    public Student() {} \n    \n    // 有参数构造方法\n    public Student(String name,int age) {\n    \tthis.name = name;\n    \tthis.age = age; \n    }\n}\n```\n\n# 第二章 static关键字   \n\n## 2.1 概述\n\n以前我们定义过如下类：\n\n```java\npublic class Student {\n    // 成员变量\n    public String name;\n    public char sex; // '男'  '女'\n    public int age;\n\n    // 无参数构造方法\n    public Student() {\n\n    }\n    \n    // 有参数构造方法\n    public Student(String  a) {\n\n    }\n}\n```\n\n我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。\n\n而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。\n\n所以Java中成员（**变量和方法**）等是存在所属性的，Java是通过static关键字来区分的。**static关键字在Java开发非常的重要，对于理解面向对象非常关键。**\n\n关于 `static` 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是**属于类**的是放在静态区中，没有static修饰的成员变量和方法则是**属于对象**的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。\n\n## 2.2 定义格式和使用 \n\nstatic是静态的意思。 static可以修饰成员变量或者修饰方法。\n\n### 2.2.1 静态变量及其访问\n\n有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为**类变量**或者**静态成员变量**。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。\n\n**如何使用呢**\n\n例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。\n\n**定义格式**\n\n```java\n修饰符 static 数据类型 变量名 = 初始值；    \n```\n\n**举例**\n\n```java\npublic class Student {\n    public static String schoolName = \"传智播客\"； // 属于类，只有一份。\n    // .....\n}\n```\n\n**静态成员变量的访问:**\n\n**格式：类名.静态变量**\n\n```java\npublic static void  main(String[] args){\n    System.out.println(Student.schoolName); // 传智播客\n    Student.schoolName = \"黑马程序员\";\n    System.out.println(Student.schoolName); // 黑马程序员\n}\n```\n\n### 2.2.2 实例变量及其访问\n\n无static修饰的成员变量属于每个对象的，  这个成员变量叫**实例变量**，之前我们写成员变量就是实例成员变量。\n\n**需要注意的是**：实例成员变量属于每个对象，必须创建类的对象才可以访问。   \n\n**格式：对象.实例成员变量**\n\n### 2.2.3 静态方法及其访问\n\n有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为**类方法或者**静态方法**。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。\n\n与静态成员变量一样，静态方法也是直接通过**类名.方法名称**即可访问。\n\n**举例**\n\n```java\npublic class Student{\n    public static String schoolName = \"传智播客\"； // 属于类，只有一份。\n    // .....\n    public static void study(){\n    \tSystem.out.println(\"我们都在黑马程序员学习\");   \n    }\n}\n```\n\n**静态成员变量的访问:**\n\n**格式：类名.静态方法**\n\n```java\npublic static void  main(String[] args){\n    Student.study();\n}\n```\n\n### 2.2.4 实例方法及其访问\n\n无static修饰的成员方法属于每个对象的，这个成员方法也叫做**实例方法**。\n\n**需要注意的是**：实例方法是属于每个对象，必须创建类的对象才可以访问。  \n\n**格式：对象.实例方法**\n\n**示例**：\n\n```java\npublic class Student {\n    // 实例变量\n    private String name ;\n    // 2.方法：行为\n    // 无 static修饰，实例方法。属于每个对象，必须创建对象调用\n    public void run(){\n        System.out.println(\"学生可以跑步\");\n    }\n\t// 无 static修饰，实例方法\n    public  void sleep(){\n        System.out.println(\"学生睡觉\");\n    }\n    public static void study(){\n        \n    }\n}\n```\n\n```java\npublic static void main(String[] args){\n    // 创建对象 \n    Student stu = new Student ;\n    stu.name = \"徐干\";\n    // Student.sleep();// 报错，必须用对象访问。\n    stu.sleep();\n    stu.run();\n}\n```\n\n## 2.3 小结\n\n1.当 `static` 修饰成员变量或者成员方法时，该变量称为**静态变量**，该方法称为**静态方法**。该类的每个对象都**共享**同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。\n\n2.无static修饰的成员变量或者成员方法，称为**实例变量，实例方法**，实例变量和实例方法必须创建类的对象，然后通过对象来访问。\n\n3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。\n\n4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。\n\n\n# 第三章 继承 \n\n## 3.1 概述\n\n### 3.1.1 引入\n假如我们要定义如下类:\n学生类,老师类和工人类，分析如下。\n\n1. 学生类\n   属性:姓名,年龄\n   行为:吃饭,睡觉\n\n2. 老师类\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，教书\n\n3. 班主任\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，管理\n\n如果我们定义了这三个类去开发一个系统，那么这三个类中就存在大量重复的信息（属性:姓名，年龄。行为：吃饭，睡觉）。这样就导致了相同代码大量重复，代码显得很臃肿和冗余，那么如何解决呢？\n\n假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要**继承**那一个类即可。如图所示：\n![](imgs/1.jpg)\n\n其中，多个类可以称为**子类**，单独被继承的那一个类称为**父类**、**超类（superclass）**或者**基类**。\n\n### 3.1.2 继承的含义\n\n继承描述的是事物之间的所属关系，这种关系是：`is-a` 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。\n\n**继承**：就是子类继承父类的**属性**和**行为**，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的**非私有**的属性和行为。\n\n### 3.1.3 继承的好处\n1. 提高**代码的复用性**（减少代码冗余，相同代码重复利用）。\n2. 使类与类之间产生了关系。\n\n## 3.2 继承的格式\n通过 `extends` 关键字，可以声明一个子类继承另外一个父类，定义格式如下：\n```java\nclass 父类 {\n\t...\n}\n\nclass 子类 extends 父类 {\n\t...\n}\n```\n\n**需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。**\n\n## 3.3 继承案例\n### 3.3.1 案例\n\n请使用继承定义以下类:\n\n1. 学生类\n   属性:姓名,年龄\n   行为:吃饭,睡觉\n2. 老师类\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，教书\n3. 班主任\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，管理\n\n### 3.3.2 案例图解分析\n\n老师类，学生类，还有班主任类，实际上都是属于人类的，我们可以定义一个人类，把他们相同的属性和行为都定义在人类中，然后继承人类即可，子类特有的属性和行为就定义在子类中了。\n\n如下图所示。\n\n![](imgs/360截图20181202211331250.jpg)\n\n### 3.3.3 案例代码实现\n\n**1.父类Human类**\n\n  ```java\n public class Human {\n    // 合理隐藏\n    private String name ;\n    private int age ;\n\t\n    // 合理暴露\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n }\n  ```\n\n**2.子类Teacher类**\n\n  ```java\npublic class Teacher extends Human {\n    // 工资\n    private double salary ;\n    \n    // 特有方法\n    public void teach(){\n        System.out.println(\"老师在认真教技术！\")；\n    }\n\n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n}\n  ```\n\n**3.子类Student类**\n\n  ```java\npublic class Student extends Human{\n \n}\n  ```\n\n**4.子类BanZhuren类**\n\n```java \npublic class Teacher extends Human {\n    // 工资\n    private double salary ;\n    \n       // 特有方法\n    public void admin(){\n        System.out.println(\"班主任强调纪律问题！\")；\n    }\n    \n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n}\n```\n\n\n**5.测试类**\n\n  ```java\n  public class Test {\n      public static void main(String[] args) {\n          Teacher dlei = new Teacher();\n          dlei.setName(\"播仔\");\n          dlei.setAge(\"31\");\n          dlei.setSalary(1000.99);\n          System.out.println(dlei.getName());\n          System.out.println(dlei.getAge());\n          System.out.println(dlei.getSalary());\n          dlei.teach();\n          \n          BanZhuRen linTao = new BanZhuRen();\n          linTao.setName(\"灵涛\");\n          linTao.setAge(\"28\");\n          linTao.setSalary(1000.99);\n          System.out.println(linTao.getName());\n          System.out.println(linTao.getAge());\n          System.out.println(linTao.getSalary());\n          linTao.admin();\n\n          Student xugan = new Student();\n          xugan.setName(\"播仔\");\n          xugan.setAge(\"31\");\n          //xugan.setSalary(1000.99); // xugan没有薪水属性，报错！\n          System.out.println(xugan.getName());\n          System.out.println(xugan.getAge());\n\n\n\n      }\n  }\n  ```\n\n### 3.3.4 小结\n\n1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。\n\n2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？请看下节！\n\n## 3.4 子类不能继承的内容\n\n### 3.4.1 引入\n\n并不是父类的所有内容都可以给子类继承的：\n\n**子类不能继承父类的构造方法。**\n\n**值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。**\n\n### 3.4.1 演示代码\n```java\npublic class Demo03 {\n    public static void main(String[] args) {\n        Zi z = new Zi();\n        System.out.println(z.num1);\n//\t\tSystem.out.println(z.num2); // 私有的子类无法使用\n        // 通过getter/setter方法访问父类的private成员变量\n        System.out.println(z.getNum2());\n\n        z.show1();\n        // z.show2(); // 私有的子类无法使用\n    }\n}\n\nclass Fu {\n    public int num1 = 10;\n    private int num2 = 20;\n\n    public void show1() {\n        System.out.println(\"show1\");\n    }\n\n    private void show2() {\n        System.out.println(\"show2\");\n    }\n\n    public int getNum2() {\n        return num2;\n    }\n\n    public void setNum2(int num2) {\n        this.num2 = num2;\n    }\n}\n\nclass Zi extends Fu {\n}\n```\n\n## 3.5 继承后的特点—成员变量\n\n当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？\n\n### 3.5.1 成员变量不重名\n\n如果子类父类中出现**不重名**的成员变量，这时的访问是**没有影响的**。代码如下：\n\n```java\nclass Fu {\n\t// Fu中的成员变量\n\tint num = 5;\n}\nclass Zi extends Fu {\n\t// Zi中的成员变量\n\tint num2 = 6;\n  \n\t// Zi中的成员方法\n\tpublic void show() {\n\t\t// 访问父类中的num\n\t\tSystem.out.println(\"Fu num=\"+num); // 继承而来，所以直接访问。\n\t\t// 访问子类中的num2\n\t\tSystem.out.println(\"Zi num2=\"+num2);\n\t}\n}\nclass Demo04 {\n\tpublic static void main(String[] args) {\n        // 创建子类对象\n\t\tZi z = new Zi(); \n      \t// 调用子类中的show方法\n\t\tz.show();  \n\t}\n}\n\n演示结果：\nFu num = 5\nZi num2 = 6\n```\n\n### 3.5.2 成员变量重名\n\n如果子类父类中出现**重名**的成员变量，这时的访问是**有影响的**。代码如下：\n\n```java\nclass Fu1 {\n\t// Fu中的成员变量。\n\tint num = 5;\n}\nclass Zi1 extends Fu1 {\n\t// Zi中的成员变量\n\tint num = 6;\n  \n\tpublic void show() {\n\t\t// 访问父类中的num\n\t\tSystem.out.println(\"Fu num=\" + num);\n\t\t// 访问子类中的num\n\t\tSystem.out.println(\"Zi num=\" + num);\n\t}\n}\nclass Demo04 {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n\t\tZi1 z = new Zi1(); \n      \t// 调用子类中的show方法\n\t\tz1.show(); \n\t}\n}\n演示结果：\nFu num = 6\nZi num = 6\n```\n\n子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。\n\n### 3.5.3  super访问父类成员变量\n\n子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用`super` 关键字，修饰父类成员变量，类似于之前学过的 `this` 。\n\n需要注意的是：**super代表的是父类对象的引用，this代表的是当前对象的引用。**\n\n**使用格式：**\n\n```java\nsuper.父类成员变量名\n```\n\n子类方法需要修改，代码如下：\n\n```java\nclass Fu {\n\t// Fu中的成员变量。\n\tint num = 5;\n}\n\nclass Zi extends Fu {\n\t// Zi中的成员变量\n\tint num = 6;\n  \n\tpublic void show() {\n        int num = 1;\n      \n        // 访问方法中的num\n        System.out.println(\"method num=\" + num);\n        // 访问子类中的num\n        System.out.println(\"Zi num=\" + this.num);\n        // 访问父类中的num\n        System.out.println(\"Fu num=\" + super.num);\n\t}\n}\n\nclass Demo04 {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n\t\tZi1 z = new Zi1(); \n      \t// 调用子类中的show方法\n\t\tz1.show(); \n\t}\n}\n\n演示结果：\nmethod num=1\nZi num=6\nFu num=5\n```\n\n> 小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。\n\n## 3.6 继承后的特点—成员方法\n\n当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？\n\n### 3.6.1 成员方法不重名\n\n如果子类父类中出现**不重名**的成员方法，这时的调用是**没有影响的**。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：\n\n```java\nclass Fu {\n\tpublic void show() {\n\t\tSystem.out.println(\"Fu类中的show方法执行\");\n\t}\n}\nclass Zi extends Fu {\n\tpublic void show2() {\n\t\tSystem.out.println(\"Zi类中的show2方法执行\");\n\t}\n}\npublic  class Demo05 {\n\tpublic static void main(String[] args) {\n\t\tZi z = new Zi();\n     \t//子类中没有show方法，但是可以找到父类方法去执行\n\t\tz.show(); \n\t\tz.show2();\n\t}\n}\n```\n\n### 3.6.2 成员方法重名\n\n如果子类父类中出现**重名**的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。\n\n代码如下：\n\n```java\nclass Fu {\n\tpublic void show() {\n\t\tSystem.out.println(\"Fu show\");\n\t}\n}\nclass Zi extends Fu {\n\t//子类重写了父类的show方法\n\tpublic void show() {\n\t\tSystem.out.println(\"Zi show\");\n\t}\n}\npublic class ExtendsDemo05{\n\tpublic static void main(String[] args) {\n\t\tZi z = new Zi();\n     \t// 子类中有show方法，只执行重写后的show方法\n\t\tz.show();  // Zi show\n\t}\n}\n```\n\n## 3.7 方法重写\n\n### 3.7.1 概念\n\n**方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。**声明不变，重新实现**。\n\n### 3.7.2 使用场景与案例\n\n发生在子父类之间的关系。\n子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。\n\n例如：我们定义了一个动物类代码如下：\n\n```java\npublic class Animal  {\n    public void run(){\n        System.out.println(\"动物跑的很快！\");\n    }\n    public void cry(){\n        System.out.println(\"动物都可以叫~~~\");\n    }\n}\n```\n\n然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求\n\n代码如下：\n\n```java\npublic class Cat extends Animal {\n    public void cry(){\n        System.out.println(\"我们一起学猫叫，喵喵喵！喵的非常好听！\");\n    }\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n      \tCat ddm = new Cat()；\n        // 调用父类继承而来的方法\n        ddm.run();\n      \t// 调用子类重写的方法\n      \tddm.cry();\n\t}\n}\n```\n\n### 3.7.2 @Override重写注解\n\n* @Override:注解，重写注解校验！\n\n* 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。\n\n* 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！\n\n  加上后的子类代码形式如下：\n\n  ``` java\n  public class Cat extends Animal {\n       // 声明不变，重新实现\n      // 方法名称与父类全部一样，只是方法体中的功能重写写了！\n      @Override\n      public void cry(){\n          System.out.println(\"我们一起学猫叫，喵喵喵！喵的非常好听！\");\n      }\n  }\n  ```\n\n\n### 3.7.3 注意事项\n\n1. 方法重写是发生在子父类之间的关系。\n2. 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。\n3. 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。\n\n## 3.8 继承后的特点—构造方法\n### 3.8.1 引入\n\n当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？\n首先我们要回忆两个事情，构造方法的定义格式和作用。\n\n1. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。\n2. 构造方法的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个`super()` ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（**先有爸爸，才能有儿子**）\n\n**继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法**\n\n### 3.8.2 案例演示\n\n按如下需求定义类:\n\n1. 人类\n   成员变量: 姓名,年龄\n   成员方法: 吃饭\n2. 学生类\n   成员变量: 姓名,年龄,成绩\n   成员方法: 吃饭\n\n代码如下：\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n        System.out.println(\"父类无参\");\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score;\n\n    public Student() {\n        //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行\n        System.out.println(\"子类无参\");\n    }\n    \n     public Student(double score) {\n        //super();  // 调用父类无参,默认就存在，可以不写，必须再第一行\n        this.score = score;    \n        System.out.println(\"子类有参\");\n     }\n\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        System.out.println(\"----------\");\n        Student s2 = new Student(99.9);\n    }\n}\n\n输出结果：\n父类无参\n子类无参\n----------\n父类无参\n子类有参\n```\n\n### 3.8.3 小结\n\n* 子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。\n* 子类构造方法的第一行都隐含了一个**super()**去调用父类无参数构造方法，**super()**可以省略不写。\n\n## 3.9 super(...)和this(...)\n\n### 3.9.1  引入\n\n请看上节中的如下案例：\n\n```java \nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n        System.out.println(\"父类无参\");\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score;\n\n    public Student() {\n        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        System.out.println(\"子类无参\");\n    }\n    \n     public Student(double score) {\n        //super();  // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        this.score = score;    \n        System.out.println(\"子类有参\");\n     }\n      // getter/setter省略\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 调用子类有参数构造方法\n        Student s2 = new Student(99.9);\n        System.out.println(s2.getScore()); // 99.9\n        System.out.println(s2.getName()); // 输出 null\n        System.out.println(s2.getAge()); // 输出 0\n    }\n}\n```\n\n我们发现，子类有参数构造方法只是初始化了自己对象中的成员变量score，而父类中的成员变量name和age依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(...)去调用父类构造方法，以便初始化继承自父类对象的name和age.\n\n### 3.9.2 super和this的用法格式\n\nsuper和this完整的用法如下，其中this，super访问成员我们已经接触过了。\n\n```java\nthis.成员变量    \t--    本类的\nsuper.成员变量    \t--    父类的\n\nthis.成员方法名()  \t--    本类的    \nsuper.成员方法名()   --    父类的\n```\n\n接下来我们使用调用构造方法格式：\n\n```java\nsuper(...) -- 调用父类的构造方法，根据参数匹配确认\nthis(...) -- 调用本类的其他构造方法，根据参数匹配确认\n```\n\n### 3.9.3 super(....)用法演示\n\n代码如下：\n\n```java\nclass Person {\n    private String name =\"凤姐\";\n    private int age = 20;\n\n    public Person() {\n        System.out.println(\"父类无参\");\n    }\n    \n    public Person(String name , int age){\n        this.name = name ;\n        this.age = age ;\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score = 100;\n\n    public Student() {\n        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        System.out.println(\"子类无参\");\n    }\n    \n     public Student(String name ， int age，double score) {\n        super(name ,age);// 调用父类有参构造方法Person(String name , int age)初始化name和age\n        this.score = score;    \n        System.out.println(\"子类有参\");\n     }\n      // getter/setter省略\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 调用子类有参数构造方法\n        Student s2 = new Student(\"张三\"，20，99);\n        System.out.println(s2.getScore()); // 99\n        System.out.println(s2.getName()); // 输出 张三\n        System.out.println(s2.getAge()); // 输出 20\n    }\n}\n```\n\n**注意：**\n\n**子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**\n\n**super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。**\n\nsuper(..)是根据参数去确定调用父类哪个构造方法的。\n\n### 3.9.4 super(...)案例图解\n\n**父类空间优先于子类对象产生**\n\n在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下：\n\n![](imgs/2.jpg)\n\n\n\n### 3.9.5 this(...)用法演示\n\nthis(...)\n *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。\n *    为了借用其他构造方法的功能。\n\n```java\npackage com.itheima._08this和super调用构造方法;\n/**\n * this(...):\n *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。\n *    为了借用其他构造方法的功能。\n *\n */\npublic class ThisDemo01 {\n    public static void main(String[] args) {\n        Student xuGan = new Student();\n        System.out.println(xuGan.getName()); // 输出:徐干\n        System.out.println(xuGan.getAge());// 输出:21\n        System.out.println(xuGan.getSex());// 输出： 男\n    }\n}\n\nclass Student{\n    private String name ;\n    private int age ;\n    private char sex ;\n\n    public Student() {\n  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)\n        this(\"徐干\",21,'男');\n    }\n\n    public Student(String name, int age, char sex) {\n        this.name = name ;\n        this.age = age   ;\n        this.sex = sex   ;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public char getSex() {\n        return sex;\n    }\n\n    public void setSex(char sex) {\n        this.sex = sex;\n    }\n}\n```\n\n### 3.9.6 小结\n\n* **子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**\n\n* **super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。**\n\n* **super(..)和this(...)是根据参数去确定调用父类哪个构造方法的。**\n* super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。\n* this(..)可以调用本类中的其他构造方法。\n\n## 3.10 继承的特点\n1. Java只支持单继承，不支持多继承。\n  ```java\n// 一个类只能有一个父类，不可以有多个父类。\nclass A {}\nclass B {}\nclass C1 extends A {} // ok\n// class C2 extends A, B {} // error\n  ```\n\n2. 一个类可以有多个子类。\n  ```java\n// A可以有多个子类\nclass A {}\nclass C1 extends A {}\nclass C2 extends  A {}\n  ```\n\n3. 可以多层继承。\n  ```java\nclass A {}\nclass C1 extends A {}\nclass D extends C1 {}\n  ```\n  > 顶层父类是Object类。所有的类默认继承Object，作为父类。\n\n## 4. 关于今天知识的小结：\n\n会写一个继承结构下的标准Javabean即可\n\n需求：\n\n​\t猫：属性，姓名，年龄，颜色\n\n​\t狗：属性，姓名，年龄，颜色，吼叫\n\n 分享书写技巧：\n\n​        1.在大脑中要区分谁是父，谁是子\n\n​        2.把共性写到父类中，独有的东西写在子类中\n\n​        3.开始编写标准Javabean（从上往下写）\n\n​        4.在测试类中，创建对象并赋值调用\n\n\n\n代码示例：\n\n```java\npackage com.itheima.test4;\n\npublic class Animal {\n    //姓名，年龄，颜色\n    private String name;\n    private int age;\n    private String color;\n\n\n    public Animal() {\n    }\n\n    public Animal(String name, int age, String color) {\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\n\npublic class Cat extends Animal{\n    //因为猫类中没有独有的属性。\n    //所以此时不需要写私有的成员变量\n\n    //空参\n    public Cat() {\n    }\n\n    //需要带子类和父类中所有的属性\n    public Cat(String name, int age, String color) {\n        super(name,age,color);\n    }\n}\n\n\npublic class Dog extends Animal{\n    //Dog ：吼叫\n    private String wang;\n\n    //构造\n    public Dog() {\n    }\n\n    //带参构造：带子类加父类所有的属性\n    public Dog(String name, int age, String color,String wang) {\n        //共性的属性交给父类赋值\n        super(name,age,color);\n        //独有的属性自己赋值\n        this.wang = wang;\n    }\n\n    public String getWang() {\n        return wang;\n    }\n\n    public void setWang(String wang) {\n        this.wang = wang;\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        //Animal ： 姓名，年龄，颜色\n        //Cat :\n        //Dog ：吼叫\n\n        //创建狗的对象\n        Dog d = new Dog(\"旺财\",2,\"黑色\",\"嗷呜~~\");\n        System.out.println(d.getName()+\", \" + d.getAge() + \", \" + d.getColor() + \", \" + d.getWang());\n\n        //创建猫的对象\n        Cat c = new Cat(\"中华田园猫\",3,\"黄色\");\n        System.out.println(c.getName() + \", \" + c.getAge() + \", \" + c.getColor());\n    }\n}\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"类和对象","url":"/2023/01/20/day08-面向对象/","content":"## 1. 类和对象\n\n### 1.1 类和对象的理解\n\n客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\n\n* 类\n  * 类的理解\n    * 类是对现实生活中一类具有共同属性和行为的事物的抽象\n    * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合\n    * 简单理解：类就是对现实事物的一种描述\n  * 类的组成\n    * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）\n    * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）\n* 类和对象的关系\n  * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象\n  * 对象：是能够看得到摸的着的真实存在的实体\n  * 简单理解：**类是对事物的一种描述，对象则为具体存在的事物**\n\n### 1.2 类的定义\n\n类的组成是由属性和行为两部分组成\n\n* 属性：在类中通过成员变量来体现（类中方法外的变量）\n* 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）\n\n类的定义步骤：\n\n①定义类\n\n②编写类的成员变量\n\n③编写类的成员方法\n\n```java\npublic class 类名 {\n\t// 成员变量\n\t变量1的数据类型 变量1；\n\t变量2的数据类型 变量2;\n\t…\n\t// 成员方法\n\t方法1;\n\t方法2;\t\n}\n```\n\n示例代码：\n\n```java\n/*\n    手机类：\n        类名：\n        手机(Phone)\n\n        成员变量：\n        品牌(brand)\n        价格(price)\n\n        成员方法：\n        打电话(call)\n        发短信(sendMessage)\n */\npublic class Phone {\n    //成员变量\n    String brand;\n    int price;\n\n    //成员方法\n    public void call() {\n        System.out.println(\"打电话\");\n    }\n\n    public void sendMessage() {\n        System.out.println(\"发短信\");\n    }\n}\n\n```\n\n### 1.3 对象的使用\n\n* 创建对象的格式：\n  * 类名 对象名 = new 类名();\n* 调用成员的格式：\n  * 对象名.成员变量\n  * 对象名.成员方法();\n* 示例代码\n\n```java\n/*\n    创建对象\n        格式：类名 对象名 = new 类名();\n        范例：Phone p = new Phone();\n\n    使用对象\n        1：使用成员变量\n            格式：对象名.变量名\n            范例：p.brand\n        2：使用成员方法\n            格式：对象名.方法名()\n            范例：p.call()\n */\npublic class PhoneDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Phone p = new Phone();\n\n        //使用成员变量\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        p.brand = \"小米\";\n        p.price = 2999;\n\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        //使用成员方法\n        p.call();\n        p.sendMessage();\n    }\n}\n```\n\n### 1.4 学生对象-练习\n\n* 需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用\n* 分析：\n  * 成员变量：姓名，年龄…\n  * 成员方法：学习，做作业…\n* 示例代码：\n\n```java\npublic class Student {\n    //成员变量\n    String name;\n    int age;\n\n    //成员方法\n    public void study() {\n        System.out.println(\"好好学习，天天向上\");\n    }\n\n    public void doHomework() {\n        System.out.println(\"键盘敲烂，月薪过万\");\n    }\n}\n/*\n    学生测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n\n        //使用对象\n        System.out.println(s.name + \",\" + s.age);\n\n        s.name = \"林青霞\";\n        s.age = 30;\n\n        System.out.println(s.name + \",\" + s.age);\n\n        s.study();\n        s.doHomework();\n    }\n}\n```\n\n## 2. 对象内存图\n\n### 2.1 单个对象内存图\n\n* 成员变量使用过程\n\n![1](images\\1.png)\n\n* 成员方法调用过程\n\n![2](images\\2.png)\n\n### 2.2 多个对象内存图\n\n* 成员变量使用过程\n\n![3](images\\3.png)\n\n* 成员方法调用过程\n\n![4](images\\4.png)\n\n* 总结：\n\n  多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\n\n## 3. 成员变量和局部变量\n\n### 3.1 成员变量和局部变量的区别\n\n* 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）\n* 内存中位置不同：成员变量（堆内存）局部变量（栈内存）\n* 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）\n* 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\n\n## 4. 封装\n\n### 4.1 封装思想\n\n1. 封装概述\n   是面向对象三大特征之一（封装，继承，多态）\n\n   **对象代表什么，就得封装对应的数据，并提供数据对应的行为** \n\n2. 封装代码实现\n   将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问\n   成员变量private，提供对应的getXxx()/setXxx()方法\n\n### 4.2 private关键字\n\nprivate是一个修饰符，可以用来修饰成员（成员变量，成员方法）\n\n* 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作\n  * 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰\n  * 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰\n\n* 示例代码：\n\n  ```java\n  /*\n      学生类\n   */\n  class Student {\n      //成员变量\n      String name;\n      private int age;\n  \n      //提供get/set方法\n      public void setAge(int a) {\n          if(a<0 || a>120) {\n              System.out.println(\"你给的年龄有误\");\n          } else {\n              age = a;\n          }\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      //成员方法\n      public void show() {\n          System.out.println(name + \",\" + age);\n      }\n  }\n  /*\n      学生测试类\n   */\n  public class StudentDemo {\n      public static void main(String[] args) {\n          //创建对象\n          Student s = new Student();\n          //给成员变量赋值\n          s.name = \"林青霞\";\n          s.setAge(30);\n          //调用show方法\n          s.show();\n      }\n  }\n  ```\n\n### 4.3 private的使用\n\n* 需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出  林青霞，30 \n\n* 示例代码：\n\n  ```java\n  /*\n      学生类\n   */\n  class Student {\n      //成员变量\n      private String name;\n      private int age;\n  \n      //get/set方法\n      public void setName(String n) {\n          name = n;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setAge(int a) {\n          age = a;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void show() {\n          System.out.println(name + \",\" + age);\n      }\n  }\n  /*\n      学生测试类\n   */\n  public class StudentDemo {\n      public static void main(String[] args) {\n          //创建对象\n          Student s = new Student();\n  \n          //使用set方法给成员变量赋值\n          s.setName(\"林青霞\");\n          s.setAge(30);\n  \n          s.show();\n  \n          //使用get方法获取成员变量的值\n          System.out.println(s.getName() + \"---\" + s.getAge());\n          System.out.println(s.getName() + \",\" + s.getAge());\n  \n      }\n  }\n  ```\n\n### 4.4 this关键字\n\n* this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）\n  * 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量\n  * 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void show() {\n        System.out.println(name + \",\" + age);\n    }\n}\n```\n\n## 5. 构造方法\n\n### 5.1 构造方法概述\n\n构造方法是一种特殊的方法\n\n* 作用：创建对象   Student stu = **new Student();**\n\n* 格式：\n\n  public class 类名{\n\n  ​        修饰符 类名( 参数 ) {\n\n  ​        }\n\n  }\n\n* 功能：主要是完成对象数据的初始化\n\n* 示例代码：\n\n```java\nclass Student {\n    private String name;\n    private int age;\n\n    //构造方法\n    public Student() {\n        System.out.println(\"无参构造方法\");\n    }\n\n    public void show() {\n        System.out.println(name + \",\" + age);\n    }\n}\n/*\n    测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n        s.show();\n    }\n}\n```\n\n### 5.2 构造方法的注意事项\n\n* 构造方法的创建\n\n如果没有定义构造方法，系统将给出一个默认的无参数构造方法\n如果定义了构造方法，系统将不再提供默认的构造方法\n\n* 构造方法的重载\n\n如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法\n\n* 推荐的使用方式\n\n无论是否使用，都手工书写无参数构造方法\n\n* 重要功能！\n\n可以使用带参构造，为成员变量进行初始化\n\n* 示例代码\n\n```java\n/*\n    学生类\n */\nclass Student {\n    private String name;\n    private int age;\n\n    public Student() {}\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public Student(int age) {\n        this.age = age;\n    }\n\n    public Student(String name,int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void show() {\n        System.out.println(name + \",\" + age);\n    }\n}\n/*\n    测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s1 = new Student();\n        s1.show();\n\n        //public Student(String name)\n        Student s2 = new Student(\"林青霞\");\n        s2.show();\n\n        //public Student(int age)\n        Student s3 = new Student(30);\n        s3.show();\n\n        //public Student(String name,int age)\n        Student s4 = new Student(\"林青霞\",30);\n        s4.show();\n    }\n}\n```\n\n### 5.3 标准类制作\n\n① 类名需要见名知意\n\n② 成员变量使用private修饰\n\n③ 提供至少两个构造方法 \n\n* 无参构造方法\n* 带全部参数的构造方法\n\n④ get和set方法 \n\n​\t提供每一个成员变量对应的setXxx()/getXxx()\n\n⑤ 如果还有其他行为，也需要写上\n\n### 5.4 练习1\n\n需求：\n\n​\t定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 \n\n* 示例代码：\n\n```java\nclass Student {\n    //成员变量\n    private String name;\n    private int age;\n\n    //构造方法\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    //成员方法\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void show() {\n        System.out.println(name + \",\" + age);\n    }\n}\n/*\n    创建对象并为其成员变量赋值的两种方式\n        1:无参构造方法创建对象后使用setXxx()赋值\n        2:使用带参构造方法直接创建带有属性值的对象\n*/\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //无参构造方法创建对象后使用setXxx()赋值\n        Student s1 = new Student();\n        s1.setName(\"林青霞\");\n        s1.setAge(30);\n        s1.show();\n\n        //使用带参构造方法直接创建带有属性值的对象\n        Student s2 = new Student(\"林青霞\",30);\n        s2.show();\n    }\n}\n```\n\n### 5.4 练习2\n\n![111](images\\111.jpg)\n\n```java\npublic class User {\n    //1.私有化全部的成员变量\n    //2.空参构造\n    //3.带全部参数的构造\n    //4.针对于每一个私有化的成员变量都要提供其对应的get和set方法\n    //5.如果当前事物还有其他行为，那么也要写出来，比如学生的吃饭，睡觉等行为\n\n    private String username;//用户名\n    private String password;//密码\n    private String email;//邮箱\n    private char gender;//性别\n    private int age;//年龄\n\n    //空参构造方法\n    public User() {\n    }\n\n    //带全部参数的构造\n    public User(String username, String password, String email, char gender, int age) {\n        this.username = username;\n        this.password = password;\n        this.email = email;\n        this.gender = gender;\n        this.age = age;\n    }\n\n    //get和set\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void eat(){\n        System.out.println(username + \"在吃饭\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        //写一个标准的javabean类\n        //咱们在课后只要能把这个标准的javabean能自己写出来，那么就表示今天的知识点就ok了\n\n\n        //利用空参构造创建对象\n        User u1 = new User();\n        //如果利用空参创建对象，还想赋值只能用set方法赋值\n        u1.setUsername(\"zhangsan\");\n        u1.setPassword(\"1234qwer\");\n        u1.setEmail(\"itheima@itcast.cn\");\n        u1.setGender('男');\n        u1.setAge(23);\n        //获取属性的值并打印\n        System.out.println(u1.getUsername() + \", \" + u1.getPassword()\n                + \", \" + u1.getEmail() + \", \" + u1.getGender() + \", \" + u1.getAge());\n        u1.eat();\n\n        System.out.println(\"=============================\");\n\n        //简单的办法\n        //利用带全部参数的构造来创建对象\n        //快捷键:ctrl + p\n        User u2 = new User(\"lisi\",\"12345678\",\"lisi@itcast.cn\",'女',24);\n        System.out.println(u2.getUsername() + \", \" + u2.getPassword()\n                + \", \" + u2.getEmail() + \", \" + u2.getGender() + \", \" + u2.getAge());\n        u2.eat();\n    }\n}\n\n```\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"多态","url":"/2023/01/20/day14笔记/","content":"# day14\n\n## 今日内容\n\n- 多态\n- 包\n- final\n- 权限修饰符\n- 代码块\n\n## 教学目标\n\n- [ ] 能够说出使用多态的前提条件\n- [ ] 理解多态的向上转型\n- [ ] 理解多态的向下转型\n- [ ] 能够知道多态的使用场景\n\n- [ ] 包的作用\n- [ ] public和private权限修饰符的作用\n- [ ] 描述final修饰的类的特点\n- [ ] 描述final修饰的方法的特点\n- [ ] 描述final修饰的变量的特点\n\n\n\n# 第一章 多态\n\n## 1.1 多态的形式\n\n**多态是继封装、继承之后，面向对象的第三大特性。**\n\n**多态是出现在继承或者实现关系中的**。\n\n**多态体现的格式**：\n\n```java\n父类类型 变量名 = new 子类/实现类构造器;\n变量名.方法名();\n```\n\n**多态的前提**：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。\n\n## 1.2 多态的使用场景\n\n如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。\n\n![多态的应用场景](img\\多态的应用场景1.png)\n\n有了多态之后，方法的形参就可以定义为共同的父类Person。\n\n**要注意的是：**\n\n* 当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。\n* 当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象（后面会学）。\n* 而且多态还可以根据传递的不同对象来调用不同类中的方法。\n\n![多态的应用场景](img\\多态的应用场景2.png)\n\n代码示例：\n\n```java\n父类：\npublic class Person {\n    private String name;\n    private int age;\n\n    空参构造\n    带全部参数的构造\n    get和set方法\n\n    public void show(){\n        System.out.println(name + \", \" + age);\n    }\n}\n\n子类1：\npublic class Administrator extends Person {\n    @Override\n    public void show() {\n        System.out.println(\"管理员的信息为：\" + getName() + \", \" + getAge());\n    }\n}\n\n子类2：\npublic class Student extends Person{\n\n    @Override\n    public void show() {\n        System.out.println(\"学生的信息为：\" + getName() + \", \" + getAge());\n    }\n}\n\n子类3：\npublic class Teacher extends Person{\n\n    @Override\n    public void show() {\n        System.out.println(\"老师的信息为：\" + getName() + \", \" + getAge());\n    }\n}\n\n测试类：\npublic class Test {\n    public static void main(String[] args) {\n        //创建三个对象，并调用register方法\n\n        Student s = new Student();\n        s.setName(\"张三\");\n        s.setAge(18);\n\n\n        Teacher t = new Teacher();\n        t.setName(\"王建国\");\n        t.setAge(30);\n\n        Administrator admin = new Administrator();\n        admin.setName(\"管理员\");\n        admin.setAge(35);\n\n\n\n        register(s);\n        register(t);\n        register(admin);\n\n\n    }\n\n\n\n    //这个方法既能接收老师，又能接收学生，还能接收管理员\n    //只能把参数写成这三个类型的父类\n    public static void register(Person p){\n        p.show();\n    }\n}\n```\n\n## 1.3 多态的定义和前提\n\n**多态**： 是指同一行为，具有多个不同表现形式。\n\n从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。\n\n **前提【重点】**\n\n1. 有继承或者实现关系\n\n2. 方法的重写【意义体现：不重写，无意义】\n\n3. 父类引用指向子类对象【格式体现】\n\n   > 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。\n\n## 1.4 多态的运行特点\n\n调用成员变量时：编译看左边，运行看左边\n\n调用成员方法时：编译看左边，运行看右边\n\n代码示例：\n\n```java\nFu f = new Zi()；\n//编译看左边的父类中有没有name这个属性，没有就报错\n//在实际运行的时候，把父类name属性的值打印出来\nSystem.out.println(f.name);\n//编译看左边的父类中有没有show这个方法，没有就报错\n//在实际运行的时候，运行的是子类中的show方法\nf.show();\n```\n\n## 1.5 多态的弊端\n\n我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时**多态的写法就无法访问子类独有功能了**。\n\n```java \nclass Animal{\n    public  void eat()｛\n        System.out.println(\"动物吃东西！\")\n    ｝\n}\nclass Cat extends Animal {  \n    public void eat() {  \n        System.out.println(\"吃鱼\");  \n    }  \n   \n    public void catchMouse() {  \n        System.out.println(\"抓老鼠\");  \n    }  \n}  \n\nclass Dog extends Animal {  \n    public void eat() {  \n        System.out.println(\"吃骨头\");  \n    }  \n}\n\nclass Test{\n    public static void main(String[] args){\n        Animal a = new Cat();\n        a.eat();\n        a.catchMouse();//编译报错，编译看左边，Animal没有这个方法\n    }\n}\n```\n\n## 1.6 引用类型转换\n\n### 1.6.1 为什么要转型\n\n**多态的写法就无法访问子类独有功能了。**\n\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点\"小麻烦\"。所以，想要调用子类特有的方法，必须做向下转型。\n\n回顾基本数据类型转换\n\n- 自动转换: 范围小的赋值给范围大的.自动完成:double d = 5; \n- 强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14 \n\n​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。\n\n### 1.6.2 向上转型（自动转换）\n\n- **向上转型**：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。\n  当父类引用指向一个子类对象时，便是向上转型。\n  使用格式：\n\n```java\n父类类型  变量名 = new 子类类型();\n如：Animal a = new Cat();\n```\n\n**原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。**所以子类范围小可以直接自动转型给父类类型的变量。\n\n### 1.6.3 向下转型（强制转换）\n\n- **向下转型**：父类类型向子类类型向下转换的过程，这个过程是强制的。\n  一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。\n\n使用格式：\n\n```java\n子类类型 变量名 = (子类类型) 父类变量名;\n如:Aniaml a = new Cat();\n   Cat c =(Cat) a;  \n```\n\n### 1.6.4 案例演示\n\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点\"小麻烦\"。所以，想要调用子类特有的方法，必须做向下转型。\n\n转型演示，代码如下：\n\n定义类：\n\n```java\nabstract class Animal {  \n    abstract void eat();  \n}  \n\nclass Cat extends Animal {  \n    public void eat() {  \n        System.out.println(\"吃鱼\");  \n    }  \n    public void catchMouse() {  \n        System.out.println(\"抓老鼠\");  \n    }  \n}  \n\nclass Dog extends Animal {  \n    public void eat() {  \n        System.out.println(\"吃骨头\");  \n    }  \n    public void watchHouse() {  \n        System.out.println(\"看家\");  \n    }  \n}\n```\n\n定义测试类：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat(); \t\t\t\t// 调用的是 Cat 的 eat\n\n        // 向下转型  \n        Cat c = (Cat)a;       \n        c.catchMouse(); \t\t// 调用的是 Cat 的 catchMouse\n    }  \n}\n```\n\n### 1.6.5 转型的异常\n\n转型的过程中，一不小心就会遇到这样的问题，请看如下代码：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat();               // 调用的是 Cat 的 eat\n\n        // 向下转型  \n        Dog d = (Dog)a;       \n        d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】\n    }  \n}\n```\n\n这段代码可以通过编译，但是运行时，却报出了 `ClassCastException` ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。\n\n### 1.6.6 instanceof关键字\n\n为了避免ClassCastException的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验，格式如下：\n\n```java\n变量名 instanceof 数据类型 \n如果变量属于该数据类型或者其子类类型，返回true。\n如果变量不属于该数据类型或者其子类类型，返回false。\n```\n\n所以，转换前，我们最好先做一个判断，代码如下：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat();               // 调用的是 Cat 的 eat\n\n        // 向下转型  \n        if (a instanceof Cat){\n            Cat c = (Cat)a;       \n            c.catchMouse();        // 调用的是 Cat 的 catchMouse\n        } else if (a instanceof Dog){\n            Dog d = (Dog)a;       \n            d.watchHouse();       // 调用的是 Dog 的 watchHouse\n        }\n    }  \n}\n```\n\n### 1.6.7 instanceof新特性\n\nJDK14的时候提出了新特性，把判断和强转合并成了一行\n\n```java\n//新特性\n//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d\n//如果不是，则不强转，结果直接是false\nif(a instanceof Dog d){\n    d.lookHome();\n}else if(a instanceof Cat c){\n    c.catchMouse();\n}else{\n    System.out.println(\"没有这个类型，无法转换\");\n}\n```\n\n### 1.7 综合练习\n\n```java\n需求：根据需求完成代码:\n\t1.定义狗类\n\t\t属性：\n\t\t\t年龄，颜色\n\t\t行为:\n\t\t\teat(String something)(something表示吃的东西)\n\t\t\t看家lookHome方法(无参数)\n2.定义猫类\n\t属性：\n\t\t年龄，颜色\n\t行为:\n\t\teat(String something)方法(something表示吃的东西)\n\t\t逮老鼠catchMouse方法(无参数)\n3.定义Person类//饲养员\n\t属性：\n\t\t姓名，年龄\n\t行为：\n\t\tkeepPet(Dog dog,String something)方法\n\t\t\t功能：喂养宠物狗，something表示喂养的东西\n\t行为：\n\t\tkeepPet(Cat cat,String something)方法\n\t\t\t功能：喂养宠物猫，something表示喂养的东西\n\t生成空参有参构造，set和get方法  \n4.定义测试类(完成以下打印效果):\n\tkeepPet(Dog dog,String somethind)方法打印内容如下：\n\t\t年龄为30岁的老王养了一只黑颜色的2岁的狗\n\t\t2岁的黑颜色的狗两只前腿死死的抱住骨头猛吃\n\tkeepPet(Cat cat,String somethind)方法打印内容如下：\n\t\t年龄为25岁的老李养了一只灰颜色的3岁的猫\n\t\t3岁的灰颜色的猫眯着眼睛侧着头吃鱼\n5.思考：\t\t\n\t1.Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？\n\t2.Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？\n```\n画图分析：\n\n![多态练习的分析](img\\多态练习的分析.png)\n\n\n\n代码示例：\n\n```java\n//动物类（父类）\npublic class Animal {\n    private int age;\n    private String color;\n\n\n    public Animal() {\n    }\n\n    public Animal(int age, String color) {\n        this.age = age;\n        this.color = color;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public void eat(String something){\n        System.out.println(\"动物在吃\" + something);\n    }\n}\n\n//猫类（子类）\npublic class Cat extends Animal {\n\n    public Cat() {\n    }\n\n    public Cat(int age, String color) {\n        super(age, color);\n    }\n\n    @Override\n    public void eat(String something) {\n        System.out.println(getAge() + \"岁的\" + getColor() + \"颜色的猫眯着眼睛侧着头吃\" + something);\n    }\n\n    public void catchMouse(){\n        System.out.println(\"猫抓老鼠\");\n    }\n\n}\n\n//狗类（子类）\npublic class Dog extends Animal {\n    public Dog() {\n    }\n\n    public Dog(int age, String color) {\n        super(age, color);\n    }\n\n    //行为\n    //eat(String something)(something表示吃的东西)\n    //看家lookHome方法(无参数)\n    @Override\n    public void eat(String something) {\n        System.out.println(getAge() + \"岁的\" + getColor() + \"颜色的狗两只前腿死死的抱住\" + something + \"猛吃\");\n    }\n\n    public void lookHome(){\n        System.out.println(\"狗在看家\");\n    }\n}\n\n\n//饲养员类\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    //饲养狗\n   /* public void keepPet(Dog dog, String something) {\n        System.out.println(\"年龄为\" + age + \"岁的\" + name + \"养了一只\" + dog.getColor() + \"颜色的\" + dog.getAge() + \"岁的狗\");\n        dog.eat(something);\n    }\n\n    //饲养猫\n    public void keepPet(Cat cat, String something) {\n        System.out.println(\"年龄为\" + age + \"岁的\" + name + \"养了一只\" + cat.getColor() + \"颜色的\" + cat.getAge() + \"岁的猫\");\n        cat.eat(something);\n    }*/\n\n\n    //想要一个方法，能接收所有的动物，包括猫，包括狗\n    //方法的形参：可以写这些类的父类 Animal\n    public void keepPet(Animal a, String something) {\n        if(a instanceof Dog d){\n            System.out.println(\"年龄为\" + age + \"岁的\" + name + \"养了一只\" + a.getColor() + \"颜色的\" + a.getAge() + \"岁的狗\");\n            d.eat(something);\n        }else if(a instanceof Cat c){\n            System.out.println(\"年龄为\" + age + \"岁的\" + name + \"养了一只\" + c.getColor() + \"颜色的\" + c.getAge() + \"岁的猫\");\n            c.eat(something);\n        }else{\n            System.out.println(\"没有这种动物\");\n        }\n    }\n}\n\n//测试类\npublic class Test {\n    public static void main(String[] args) {\n        //创建对象并调用方法\n       /* Person p1 = new Person(\"老王\",30);\n        Dog d = new Dog(2,\"黑\");\n        p1.keepPet(d,\"骨头\");\n\n\n        Person p2 = new Person(\"老李\",25);\n        Cat c = new Cat(3,\"灰\");\n        p2.keepPet(c,\"鱼\");*/\n\n\n        //创建饲养员的对象\n        Person p = new Person(\"老王\",30);\n        Dog d = new Dog(2,\"黑\");\n        Cat c = new Cat(3,\"灰\");\n        p.keepPet(d,\"骨头\");\n        p.keepPet(c,\"鱼\");\n\n    }\n}\n```\n\n# 第二章 包\n\n## 2.1 包\n\n​\t包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。\n\n在IDEA项目中，建包的操作如下：\n\n![](img/aaa.jpg)\n\n**包名的命名规范**：\n\n```java\n路径名.路径名.xxx.xxx\n// 例如：com.itheima.oa\n```\n\n- 包名一般是公司域名的倒写。例如：黑马是www.itheima.com,包名就可以定义成com.itheima.技术名称。\n- 包名必须用”.“连接。\n- 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。\n\n## 2.2 导包\n\n什么时候需要导包？\n\n​\t情况一：在使用Java中提供的非核心包中的类时\n\n​\t情况二：使用自己写的其他包中的类时\n\n什么时候不需要导包？\n\n​\t情况一：在使用Java核心包（java.lang）中的类时\n\n​\t情况二：在使用自己写的同一个包中的类时\n\n## 2.3 使用不同包下的相同类怎么办？\n\n假设demo1和demo2中都有一个Student该如何使用？\n\n代码示例：\n\n```java\n//使用全类名的形式即可。\n//全类名：包名 + 类名\n//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference\ncom.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student();\ncom.itheima.homework.demo2.Student s2 = new com.itheima.homework.demo2.Student();\n```\n\n# 第三章 权限修饰符\n\n## 3.1 权限修饰符\n\n​\t在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。\n\n- public：公共的，所有地方都可以访问。\n\n- protected：本类 ，本包，其他包中的子类都可以访问。\n\n- 默认（没有修饰符）：本类 ，本包可以访问。\n\n  注意：默认是空着不写，不是default\n\n- private：私有的，当前类可以访问。\n  `public > protected > 默认 > private`\n\n## 3.2 不同权限的访问能力\n\n|                  | public | protected | 默认 | private |\n| ---------------- | ------ | --------- | ---- | ------- |\n| 同一类中         | √      | √         | √    | √       |\n| 同一包中的类     | √      | √         | √    |         |\n| 不同包的子类     | √      | √         |      |         |\n| 不同包中的无关类 | √      |           |      |         |\n\n可见，public具有最大权限。private则是最小权限。\n\n编写代码时，如果没有特殊的考虑，建议这样使用权限：\n\n- 成员变量使用`private` ，隐藏细节。\n- 构造方法使用` public` ，方便创建对象。\n- 成员方法使用`public` ，方便调用方法。\n\n> 小贴士：不加权限修饰符，就是默认权限\n\n# 第四章 final关键字\n\n## 4.1 概述\n\n​\t学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。\n\n如果有一个方法我不想别人去改写里面内容，该怎么办呢？\n\nJava提供了`final` 关键字，表示修饰的内容不可变。\n\n- **final**：  不可改变，最终的含义。可以用于修饰类、方法和变量。\n  - 类：被修饰的类，不能被继承。\n  - 方法：被修饰的方法，不能被重写。\n  - 变量：被修饰的变量，有且仅能被赋值一次。\n\n## 4.2 使用方式\n\n### 4.2.1 修饰类\n\nfinal修饰的类，不能被继承。\n\n格式如下：\n\n```java\nfinal class 类名 {\n}\n```\n\n代码:\n\n```java\nfinal class Fu {\n}\n// class Zi extends Fu {} // 报错,不能继承final的类\n```\n\n查询API发现像 `public final class String` 、`public final class Math` 、`public final class Scanner` 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。\n\n### 4.2.2 修饰方法\n\nfinal修饰的方法，不能被重写。\n格式如下：\n\n```java\n修饰符 final 返回值类型 方法名(参数列表){\n    //方法体\n}\n```\n\n代码: \n\n```java\nclass Fu2 {\n\tfinal public void show1() {\n\t\tSystem.out.println(\"Fu2 show1\");\n\t}\n\tpublic void show2() {\n\t\tSystem.out.println(\"Fu2 show2\");\n\t}\n}\n\nclass Zi2 extends Fu2 {\n//\t@Override\n//\tpublic void show1() {\n//\t\tSystem.out.println(\"Zi2 show1\");\n//\t}\n\t@Override\n\tpublic void show2() {\n\t\tSystem.out.println(\"Zi2 show2\");\n\t}\n}\n```\n\n### 4.2.3 修饰变量-局部变量\n\n1. **局部变量——基本类型**\n   基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：\n\n```java\npublic class FinalDemo1 {\n    public static void main(String[] args) {\n        // 声明变量，使用final修饰\n        final int a;\n        // 第一次赋值 \n        a = 10;\n        // 第二次赋值\n        a = 20; // 报错,不可重新赋值\n\n        // 声明变量，直接赋值，使用final修饰\n        final int b = 10;\n        // 第二次赋值\n        b = 20; // 报错,不可重新赋值\n    }\n}\n```\n\n思考，下面两种写法，哪种可以通过编译？\n\n写法1：\n\n```java\nfinal int c = 0;\nfor (int i = 0; i < 10; i++) {\n    c = i;\n    System.out.println(c);\n}\n```\n\n写法2：\n\n```java\nfor (int i = 0; i < 10; i++) {\n    final int c = i;\n    System.out.println(c);\n}\n```\n\n根据 `final` 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。\n\n### 4.2.4 修饰变量-成员变量\n\n成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：\n\n- 显示初始化(在定义成员变量的时候立马赋值)（常用）；\n\n```java\npublic class Student {\n    final int num = 10;\n}\n```\n\n- 构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。\n\n  **注意：每个构造方法中都要赋值一次！**\n\n```java\npublic class Student {\n    final int num = 10;\n    final int num2;\n\n    public Student() {\n        this.num2 = 20;\n//     this.num2 = 20;\n    }\n    \n     public Student(String name) {\n        this.num2 = 20;\n//     this.num2 = 20;\n    }\n}\n```\n\n> 被final修饰的常量名称，一般都有书写规范，所有字母都**大写**。\n\n\n\n\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"正则表达式_练习","url":"/2023/01/20/学习总结-03/","content":"## 今日内容\n\n* 正则表达式\n\n## 教学目标  \n\n- [ ] 能够理解正则表达式的作用\n- [ ] 能够使用正则表达式的字符类\n- [ ] 能够使用正则表达式的逻辑运算符\n- [ ] 能够使用正则表达式的预定义字符类\n- [ ] 能够使用正则表达式的限定符\n- [ ] 能够使用正则表达式的分组\n- [ ] 能够在String的split方法中使用正则表达式\n\n# 正则表达式\n\n## 1.1 正则表达式的概念及演示\n\n- 在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。\n- 先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证：\n  - QQ号码必须是5--15位长度\n  - 而且必须全部是数字\n  - 而且首位不能为0\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo1 {\n    public static void main(String[] args) {\n        /* 假如现在要求校验一个qq号码是否正确。\n            规则:6位及20位之内，日不能在开头，必须全部是数字。\n            先使用目前所学知识完成校验需求然后体验一下正则表达式检验。\n        */\n\n        String qq =\"1234567890\";\n        System.out.println(checkQQ(qq));\n\n        System.out.println(qq.matches(\"[1-9]\\\\d{5,19}\"));\n\n    }\n\n    public static boolean checkQQ(String qq) {\n        //规则:6位及20位之内，日不能在开头，必须全部是数字 。\n        //核心思想:\n        //先把异常数据进行过滤\n        //下面的就是满足要求的数据了。\n        int len = qq.length();\n        if (len < 6 || len > 20) {\n            return false;\n        }\n        //0不能在开头\n        if (qq.startsWith(\"0\")) {\n            return false;\n        }\n        //必须全部是数字\n        for (int i = 0; i < qq.length(); i++) {\n            char c = qq.charAt(i);\n            if (c < '0' | c > '9') {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- 使用正则表达式验证：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        String qq =\"1234567890\";\n        System.out.println(qq.matches(\"[1-9]\\\\d{5,19}\"));\n    }\n}\n```\n\n**我们接下来就重点学习怎样写正则表达式**\n\n## 1.2 正则表达式-字符类\n\n- 语法示例：\n\n1. \\[abc\\]：代表a或者b，或者c字符中的一个。\n2. \\[^abc\\]：代表除a,b,c以外的任何字符。\n3. [a-z]：代表a-z的所有小写字符中的一个。\n4. [A-Z]：代表A-Z的所有大写字符中的一个。\n5. [0-9]：代表0-9之间的某一个数字字符。\n6. [a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。\n7. [a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 \n\n- 代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo2 {\n    public static void main(String[] args) {\n        //public boolean matches(String regex):判断是否与正则表达式匹配，匹配返回true\n        // 只能是a b c\n        System.out.println(\"-----------1-------------\");\n        System.out.println(\"a\".matches(\"[abc]\")); // true\n        System.out.println(\"z\".matches(\"[abc]\")); // false\n\n        // 不能出现a b c\n        System.out.println(\"-----------2-------------\");\n        System.out.println(\"a\".matches(\"[^abc]\")); // false\n        System.out.println(\"z\".matches(\"[^abc]\")); // true\n        System.out.println(\"zz\".matches(\"[^abc]\")); //false\n        System.out.println(\"zz\".matches(\"[^abc][^abc]\")); //true\n\n        // a到zA到Z(包括头尾的范围)\n        System.out.println(\"-----------3-------------\");\n        System.out.println(\"a\".matches(\"[a-zA-z]\")); // true\n        System.out.println(\"z\".matches(\"[a-zA-z]\")); // true\n        System.out.println(\"aa\".matches(\"[a-zA-z]\"));//false\n        System.out.println(\"zz\".matches(\"[a-zA-Z]\")); //false\n        System.out.println(\"zz\".matches(\"[a-zA-Z][a-zA-Z]\")); //true\n        System.out.println(\"0\".matches(\"[a-zA-Z]\"));//false\n        System.out.println(\"0\".matches(\"[a-zA-Z0-9]\"));//true\n\n\n        // [a-d[m-p]] a到d，或m到p\n        System.out.println(\"-----------4-------------\");\n        System.out.println(\"a\".matches(\"[a-d[m-p]]\"));//true\n        System.out.println(\"d\".matches(\"[a-d[m-p]]\")); //true\n        System.out.println(\"m\".matches(\"[a-d[m-p]]\")); //true\n        System.out.println(\"p\".matches(\"[a-d[m-p]]\")); //true\n        System.out.println(\"e\".matches(\"[a-d[m-p]]\")); //false\n        System.out.println(\"0\".matches(\"[a-d[m-p]]\")); //false\n\n        // [a-z&&[def]] a-z和def的交集。为:d，e，f\n        System.out.println(\"----------5------------\");\n        System.out.println(\"a\".matches(\"[a-z&[def]]\")); //false\n        System.out.println(\"d\".matches(\"[a-z&&[def]]\")); //true\n        System.out.println(\"0\".matches(\"[a-z&&[def]]\")); //false\n\n        // [a-z&&[^bc]] a-z和非bc的交集。(等同于[ad-z])\n        System.out.println(\"-----------6------------_\");\n        System.out.println(\"a\".matches(\"[a-z&&[^bc]]\"));//true\n        System.out.println(\"b\".matches(\"[a-z&&[^bc]]\")); //false\n        System.out.println(\"0\".matches(\"[a-z&&[^bc]]\")); //false\n\n        // [a-z&&[^m-p]] a到z和除了m到p的交集。(等同于[a-1q-z])\n        System.out.println(\"-----------7-------------\");\n        System.out.println(\"a\".matches(\"[a-z&&[^m-p]]\")); //true\n        System.out.println(\"m\".matches(\"[a-z&&[^m-p]]\")); //false\n        System.out.println(\"0\".matches(\"[a-z&&[^m-p]]\")); //false\n\n    }\n}\n\n```\n\n## 1.3 正则表达式-逻辑运算符\n\n- 语法示例：\n  1. &&：并且\n  2. |    ：或者\n  3.  \\  ：转义字符\n- 代码示例：\n\n```java\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"had\";\n\t\t\n\t\t//1.要求字符串是小写辅音字符开头，后跟ad\n\t\tString regex = \"[a-z&&[^aeiou]]ad\";\n\t\tSystem.out.println(\"1.\" + str.matches(regex));\n\t\t\n\t\t//2.要求字符串是aeiou中的某个字符开头，后跟ad\n\t\tregex = \"[a|e|i|o|u]ad\";//这种写法相当于：regex = \"[aeiou]ad\";\n\t\tSystem.out.println(\"2.\" + str.matches(regex));\n\t}\n}\n\n```\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo3 {\n    public static void main(String[] args) {\n        // \\ 转义字符 改变后面那个字符原本的含义\n        //练习:以字符串的形式打印一个双引号\n        //\"在Java中表示字符串的开头或者结尾\n\n        //此时\\表示转义字符，改变了后面那个双引号原本的含义\n        //把他变成了一个普普通通的双引号而已。\n        System.out.println(\"\\\"\");\n\n        // \\表示转义字符\n        //两个\\的理解方式：前面的\\是一个转义字符，改变了后面\\原本的含义，把他变成一个普普通通的\\而已。\n        System.out.println(\"c:Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\myapi\\\\src\\\\com\\\\itheima\\\\a08regexdemo\\\\RegexDemo1.java\");\n\n\n\n\n    }\n}\n\n```\n\n\n\n## 1.4 正则表达式-预定义字符\n\n- 语法示例：\n  1. \".\" ： 匹配任何字符。\n  2. \"\\d\"：任何数字[0-9]的简写；\n  3. \"\\D\"：任何非数字\\[^0-9\\]的简写；\n  4. \"\\s\"： 空白字符：[ \\t\\n\\x0B\\f\\r] 的简写\n  5. \"\\S\"： 非空白字符：\\[^\\s\\] 的简写\n  6. \"\\w\"：单词字符：[a-zA-Z_0-9]的简写\n  7. \"\\W\"：非单词字符：\\[^\\w\\]\n- 代码示例：\n\n```java\npublic class Demo {\n\tpublic static void main(String[] args) {\n        //.表示任意一个字符\n        System.out.println(\"你\".matches(\"..\")); //false\n        System.out.println(\"你\".matches(\".\")); //true\n        System.out.println(\"你a\".matches(\"..\"));//true\n\n        // \\\\d 表示任意的一个数字\n        // \\\\d只能是任意的一位数字\n        // 简单来记:两个\\表示一个\\\n        System.out.println(\"a\".matches(\"\\\\d\")); // false\n        System.out.println(\"3\".matches(\"\\\\d\")); // true\n        System.out.println(\"333\".matches(\"\\\\d\")); // false\n\n        //\\\\w只能是一位单词字符[a-zA-Z_0-9]\n        System.out.println(\"z\".matches(\"\\\\w\")); // true\n        System.out.println(\"2\".matches(\"\\\\w\")); // true\n        System.out.println(\"21\".matches(\"\\\\w\")); // false\n        System.out.println(\"你\".matches(\"\\\\w\"));//false\n\n        // 非单词字符\n        System.out.println(\"你\".matches(\"\\\\W\")); // true\n        System.out.println(\"---------------------------------------------\");\n        // 以上正则匹配只能校验单个字符。\n\n\n        // 必须是数字 字母 下划线 至少 6位\n        System.out.println(\"2442fsfsf\".matches(\"\\\\w{6,}\"));//true\n        System.out.println(\"244f\".matches(\"\\\\w{6,}\"));//false\n\n        // 必须是数字和字符 必须是4位\n        System.out.println(\"23dF\".matches(\"[a-zA-Z0-9]{4}\"));//true\n        System.out.println(\"23 F\".matches(\"[a-zA-Z0-9]{4}\"));//false\n        System.out.println(\"23dF\".matches(\"[\\\\w&&[^_]]{4}\"));//true\n        System.out.println(\"23_F\".matches(\"[\\\\w&&[^_]]{4}\"));//false\n\t\t\n\t}\n}\n```\n\n## 1.5 正则表达式-数量词\n\n- 语法示例：\n  1. X? : 0次或1次\n  2. X* : 0次到多次\n  3. X+ : 1次或多次\n  4. X{n} : 恰好n次\n  5. X{n,} : 至少n次\n  6. X{n,m}: n到m次(n和m都是包含的)\n- 代码示例：\n\n```java\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\t // 必须是数字 字母 下划线 至少 6位\n        System.out.println(\"2442fsfsf\".matches(\"\\\\w{6,}\"));//true\n        System.out.println(\"244f\".matches(\"\\\\w{6,}\"));//false\n\n        // 必须是数字和字符 必须是4位\n        System.out.println(\"23dF\".matches(\"[a-zA-Z0-9]{4}\"));//true\n        System.out.println(\"23 F\".matches(\"[a-zA-Z0-9]{4}\"));//false\n        System.out.println(\"23dF\".matches(\"[\\\\w&&[^_]]{4}\"));//true\n        System.out.println(\"23_F\".matches(\"[\\\\w&&[^_]]{4}\"));//false\n\t}\n}\n\n```\n\n## 1.6 正则表达式练习1\n\n需求：\n\n​\t请编写正则表达式验证用户输入的手机号码是否满足要求。\n\n​\t请编写正则表达式验证用户输入的邮箱号是否满足要求。\n\n​\t请编写正则表达式验证用户输入的电话号码是否满足要求。\n\n​\t验证手机号码 13112345678 13712345667 13945679027 139456790271\n\n​\t验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434\n\n​\t验证邮箱号码 3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n\n代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo4 {\n    public static void main(String[] args) {\n        /*\n            需求\n            请编写正则表达式验证用户输入的手机号码是否满足要求。请编写正则表达式验证用户输入的邮箱号是否满足要求。请编写正则表达式验证用户输入的电话号码是否满足要求。\n            验证手机号码 13112345678 13712345667 13945679027 139456790271\n            验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434\n            验证邮箱号码 3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n        */\n\n        //心得:\n        //拿着一个正确的数据，从左到右依次去写。\n        //13112345678\n        //分成三部分:\n        //第一部分:1 表示手机号码只能以1开头\n        //第二部分:[3-9] 表示手机号码第二位只能是3-9之间的\n        //第三部分:\\\\d{9} 表示任意数字可以出现9次，也只能出现9次\n        String regex1 = \"1[3-9]\\\\d{9}\";\n        System.out.println(\"13112345678\".matches(regex1));//true\n        System.out.println(\"13712345667\".matches(regex1));//true\n        System.out.println(\"13945679027\".matches(regex1));//true\n        System.out.println(\"139456790271\".matches(regex1));//false\n        System.out.println(\"-----------------------------------\");\n\n        //座机电话号码\n        //020-2324242 02122442 027-42424 0712-3242434\n        //思路:\n        //在书写座机号正则的时候需要把正确的数据分为三部分\n        //一:区号@\\\\d{2,3}\n        //      0:表示区号一定是以0开头的\n        //      \\\\d{2,3}:表示区号从第二位开始可以是任意的数字，可以出现2到3次。\n        //二:- ?表示次数，日次或一次\n        //三:号码 号码的第一位也不能以日开头，从第二位开始可以是任意的数字，号码的总长度:5-10位\n        String regex2 = \"0\\\\d{2,3}-?[1-9]\\\\d{4,9}\";\n        System.out.println(\"020-2324242\".matches(regex2));\n        System.out.println(\"02122442\".matches(regex2));\n        System.out.println(\"027-42424\".matches(regex2));\n        System.out.println(\"0712-3242434\".matches(regex2));\n\n        //邮箱号码\n        //3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n        //思路:\n        //在书写邮箱号码正则的时候需要把正确的数据分为三部分\n        //第一部分:@的左边 \\\\w+\n        //      任意的字母数字下划线，至少出现一次就可以了\n        //第二部分:@ 只能出现一次\n        //第三部分:\n        //      3.1         .的左边[\\\\w&&[^_]]{2,6}\n        //                  任意的字母加数字，总共出现2-6次(此时不能出现下划线)\n        //      3.2         . \\\\.\n        //      3.3         大写字母，小写字母都可以，只能出现2-3次[a-zA-Z]{2,3}\n        //      我们可以把3.2和3.3看成一组，这一组可以出现1次或者两次\n        String regex3 = \"\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2}\";\n        System.out.println(\"3232323@qq.com\".matches(regex3));\n        System.out.println(\"zhangsan@itcast.cnn\".matches(regex3));\n        System.out.println(\"dlei0009@163.com\".matches(regex3));\n        System.out.println(\"dlei0009@pci.com.cn\".matches(regex3));\n\n\n        //24小时的正则表达式\n        String regex4 = \"([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\";\n        System.out.println(\"23:11:11\".matches(regex4));\n\n        String regex5 = \"([01]\\\\d 2[0-3])(:[0-5]\\\\d){2}\";\n        System.out.println(\"23:11:11\".matches(regex5));\n    }\n}\n\n```\n\n## 1.7 正则表达式练习2\n\n需求\n\t请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位\n\t请编写正则表达式验证身份证号码是否满足要求。\n\t简单要求:\n    \t\t18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n\t复杂要求:\n    \t\t按照身份证号码的格式严格要求。\n\n​\t身份证号码:\n​\t\t41080119930228457x\n​\t\t510801197609022309\n​\t\t15040119810705387X\n​\t\t130133197204039024 \n​\t\t430102197606046442\n\n代码示例：\n\n```java\npublic class RegexDemo5 {\n    public static void main(String[] args) {\n        /*\n            正则表达式练习:\n            需求\n            请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位\n            请编写正则表达式验证身份证号码是否满足要求。\n            简单要求:\n                18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n            复杂要求:\n                按照身份证号码的格式严格要求。\n\n            身份证号码:\n            41080119930228457x\n            510801197609022309\n            15040119810705387X\n            130133197204039024 I\n            430102197606046442\n        */\n\n        //用户名要求:大小写字母，数字，下划线一共4-16位\n        String regex1 = \"\\\\w{4,16}\";\n        System.out.println(\"zhangsan\".matches(regex1));\n        System.out.println(\"lisi\".matches(regex1));\n        System.out.println(\"wangwu\".matches(regex1));\n        System.out.println(\"$123\".matches(regex1));\n\n\n        //身份证号码的简单校验:\n        //18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n        String regex2 = \"[1-9]\\\\d{16}(\\\\d|x|x)\";\n        String regex3 = \"[1-9]\\\\d{16}[\\\\dXx]\";\n        String regex5 = \"[1-9]\\\\d{16}(\\\\d(?i)x)\";\n\n        System.out.println(\"41080119930228457x\".matches(regex3));\n        System.out.println(\"510801197609022309\".matches(regex3));\n        System.out.println(\"15040119810705387X\".matches(regex3));\n        System.out.println(\"130133197204039024\".matches(regex3));\n        System.out.println(\"430102197606046442\".matches(regex3));\n\n\n        //忽略大小写的书写方式\n        //在匹配的时候忽略abc的大小写\n        String regex4 = \"a((?i)b)c\";\n        System.out.println(\"------------------------------\");\n        System.out.println(\"abc\".matches(regex4));//true\n        System.out.println(\"ABC\".matches(regex4));//false\n        System.out.println(\"aBc\".matches(regex4));//true\n\n\n        //身份证号码的严格校验\n        //编写正则的小心得:\n        //第一步:按照正确的数据进行拆分\n        //第二步:找每一部分的规律，并编写正则表达式\n        //第三步:把每一部分的正则拼接在一起，就是最终的结果\n        //书写的时候:从左到右去书写。\n\n        //410801 1993 02 28 457x\n        //前面6位:省份，市区，派出所等信息，第一位不能是0，后面5位是任意数字       [1-9]\\\\d{5}\n        //年的前半段: 18 19 20                                                (18|19|20)\n        //年的后半段: 任意数字出现两次                                           \\\\d{2}\n        //月份: 01~ 09 10 11 12                                               (@[1-9]|1[0-2])\n        //日期: 01~09 10~19 20~29 30 31                                       (0[1-9]|[12]\\\\d|3[01])\n        //后面四位: 任意数字出现3次 最后一位可以是数字也可以是大写x或者小写x        \\\\d{3}[\\\\dXx]\n        String regex6 = \"[1-9]\\\\d{5}(18|19|20)\\\\d{2}(@[1-9]|1[0-2])(@[1-9]|[12]\\\\d|3[01])\\\\d{3}[\\\\dxXx]\";\n\n        System.out.println(\"41080119930228457x\".matches(regex6));\n        System.out.println(\"510801197609022309\".matches(regex6));\n        System.out.println(\"15040119810705387X\".matches(regex6));\n        System.out.println(\"130133197204039024\".matches(regex6));\n        System.out.println(\"430102197606046442\".matches(regex6));\n\n\n    }\n}\n\n```\n\n## 1.8 本地数据爬取\n\nPattern：表示正则表达式\nMatcher：文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。\n         \t在大串中去找符合匹配规则的子串。\n\n代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexDemo6 {\n    public static void main(String[] args) {\n        /* 有如下文本，请按照要求爬取数据。\n                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\n                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\n                要求:找出里面所有的JavaXX\n         */\n\n        String str = \"Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\" +\n                \"因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\";\n\n\n        //1.获取正则表达式的对象\n        Pattern p = Pattern.compile(\"Java\\\\d{0,2}\");\n        //2.获取文本匹配器的对象\n        //拿着m去读取str，找符合p规则的子串\n        Matcher m = p.matcher(str);\n\n        //3.利用循环获取\n        while (m.find()) {\n            String s = m.group();\n            System.out.println(s);\n        }\n\n\n    }\n\n    private static void method1(String str) {\n        //Pattern:表示正则表达式\n        //Matcher: 文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。\n        //          在大串中去找符合匹配规则的子串。\n\n        //获取正则表达式的对象\n        Pattern p = Pattern.compile(\"Java\\\\d{0,2}\");\n        //获取文本匹配器的对象\n        //m:文本匹配器的对象\n        //str:大串\n        //p:规则\n        //m要在str中找符合p规则的小串\n        Matcher m = p.matcher(str);\n\n        //拿着文本匹配器从头开始读取，寻找是否有满足规则的子串\n        //如果没有，方法返回false\n        //如果有，返回true。在底层记录子串的起始索引和结束索引+1\n        // 0,4\n        boolean b = m.find();\n\n        //方法底层会根据find方法记录的索引进行字符串的截取\n        // substring(起始索引，结束索引);包头不包尾\n        // (0,4)但是不包含4索引\n        // 会把截取的小串进行返回。\n        String s1 = m.group();\n        System.out.println(s1);\n\n\n        //第二次在调用find的时候，会继续读取后面的内容\n        //读取到第二个满足要求的子串，方法会继续返回true\n        //并把第二个子串的起始索引和结束索引+1，进行记录\n        b = m.find();\n\n        //第二次调用group方法的时候，会根据find方法记录的索引再次截取子串\n        String s2 = m.group();\n        System.out.println(s2);\n    }\n}\n```\n\n## 1.9 网络数据爬取（了解）\n\n需求：\n\n​\t把连接:https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i中所有的身份证号码都爬取出来。\n\n代码示例：\n\n```java\npublic class RegexDemo7 {\n    public static void main(String[] args) throws IOException {\n        /* 扩展需求2:\n            把连接:https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i\n            中所有的身份证号码都爬取出来。\n        */\n\n        //创建一个URL对象\n        URL url = new URL(\"https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i\");\n        //连接上这个网址\n        //细节:保证网络是畅通\n        URLConnection conn = url.openConnection();//创建一个对象去读取网络中的数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String line;\n        //获取正则表达式的对象pattern\n        String regex = \"[1-9]\\\\d{17}\";\n        Pattern pattern = Pattern.compile(regex);//在读取的时候每次读一整行\n        while ((line = br.readLine()) != null) {\n            //拿着文本匹配器的对象matcher按照pattern的规则去读取当前的这一行信息\n            Matcher matcher = pattern.matcher(line);\n            while (matcher.find()) {\n                System.out.println(matcher.group());\n            }\n        }\n        br.close();\n    }\n}\n\n```\n\n## 1.10 爬取数据练习\n\n需求：\n\n​\t把下面文本中的座机电话，邮箱，手机号，热线都爬取出来。\n\n来黑马程序员学习Java，手机号:18512516758，18512508907或者联系邮箱:boniu@itcast.cn，座机电话:01036517895，010-98951256邮箱:bozai@itcast.cn，热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090手机号的正则表达式:1[3-9]\\d{9}\n\n代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexDemo8 {\n    public static void main(String[] args) {\n        /*\n            需求:把下面文本中的座机电话，邮箱，手机号，热线都爬取出来。\n            来黑马程序员学习Java，\n            手机号:18512516758，18512508907或者联系邮箱:boniu@itcast.cn，\n            座机电话:01036517895，010-98951256邮箱:bozai@itcast.cn，\n            热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090\n\n            手机号的正则表达式:1[3-9]\\d{9}\n            邮箱的正则表达式:\\w+@[\\w&&[^_]]{2,6}(\\.[a-zA-Z]{2,3}){1,2}座机电话的正则表达式:θ\\d{2,3}-?[1-9]\\d{4,9}\n            热线电话的正则表达式:400-?[1-9]\\\\d{2}-?[1-9]\\\\d{3}\n\n        */\n\n        String s = \"来黑马程序员学习Java，\" +\n                \"电话:18512516758，18512508907\" + \"或者联系邮箱:boniu@itcast.cn，\" +\n                \"座机电话:01036517895，010-98951256\" + \"邮箱:bozai@itcast.cn，\" +\n                \"热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090\";\n\n        System.out.println(\"400-618-9090\");\n\n        String regex = \"(1[3-9]\\\\d{9})|(\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2})\" +\n                \"|(0\\\\d{2,3}-?[1-9]\\\\d{4,9})\" +\n                \"(400-?[1-9]\\\\d{2}-?[1-9]\\\\d{3})\";\n\n        //1.获取正则表达式的对象\n        Pattern p = Pattern.compile(regex);\n\n        //2.获取文本匹配器的对象\n        //利用m去读取s，会按照p的规则找里面的小串\n        Matcher m = p.matcher(s);\n        //3.利用循环获取每一个数据 while(m.find()){\n        String str = m.group();\n        System.out.println(str);\n\n    }\n}\n```\n\n## 1.11 按要求爬取\n\n需求：\n\n​\t有如下文本，按要求爬取数据。   \n\n​\t Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台。\n\n需求1：\n\n​\t爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。\n\n需求2：\n\n​\t爬取版本号为8，11，17的Java文本。正确爬取结果为：Java8 Java11 Java17 Java17\n\n需求3：\n\n​\t爬取除了版本号为8，11，17的Java文本。\n代码示例：\n\n```java\npublic class RegexDemo9 {\n    public static void main(String[] args) {\n        /*\n            有如下文本，按要求爬取数据。\n                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\n                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\n\n\n            需求1:爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。\n            需求2:爬取版本号为8，11，17的Java文本。正确爬取结果为:Java8 Java11 Java17 Java17\n            需求3:爬取除了版本号为8，11.17的Java文本，\n        */\n        String s = \"Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\" +\n            \"因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\";\n\n        //1.定义正则表达式\n        //?理解为前面的数据Java\n        //=表示在Java后面要跟随的数据\n        //但是在获取的时候，只获取前半部分\n        //需求1:\n        String regex1 = \"((?i)Java)(?=8|11|17)\";\n        //需求2:\n        String regex2 = \"((?i)Java)(8|11|17)\";\n        String regex3 = \"((?i)Java)(?:8|11|17)\";\n        //需求3:\n        String regex4 = \"((?i)Java)(?!8|11|17)\";\n\n        Pattern p = Pattern.compile(regex4);\n        Matcher m = p.matcher(s);\n        while (m.find()) {\n            System.out.println(m.group());\n        }\n    }\n}\n\n```\n\n## 1.12 贪婪爬取和非贪婪爬取\n\n```java\n只写+和表示贪婪匹配，如果在+和后面加问号表示非贪婪爬取\n+? 非贪婪匹配\n*? 非贪婪匹配\n贪婪爬取:在爬取数据的时候尽可能的多获取数据\n非贪婪爬取:在爬取数据的时候尽可能的少获取数据\n\n举例：\n如果获取数据：ab+\n贪婪爬取获取结果:abbbbbbbbbbbb\n非贪婪爬取获取结果:ab\n```\n\n代码示例：\n\n```java\npublic class RegexDemo10 {\n    public static void main(String[] args) {\n        /*\n            只写+和*表示贪婪匹配\n\n            +? 非贪婪匹配\n            *? 非贪婪匹配\n\n            贪婪爬取:在爬取数据的时候尽可能的多获取数据\n            非贪婪爬取:在爬取数据的时候尽可能的少获取数据\n\n            ab+:\n            贪婪爬取:abbbbbbbbbbbb\n            非贪婪爬取:ab\n        */\n        String s = \"Java自从95年问世以来，abbbbbbbbbbbbaaaaaaaaaaaaaaaaaa\" +\n                \"经历了很多版木，目前企业中用的最多的是]ava8和]ava11，因为这两个是长期支持版木。\" +\n                \"下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\";\n\n        String regex = \"ab+\";\n        Pattern p = Pattern.compile(regex);\n        Matcher m = p.matcher(s);\n\n        while (m.find()) {\n            System.out.println(m.group());\n        }\n\n\n    }\n}\n\n```\n\n## 1.13 String的split方法中使用正则表达式\n\n- String类的split()方法原型：\n\n  ```java\n  public String[] split(String regex)\n  //参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为\"分隔符\"来切割字符串。\n  ```\n\n- 代码示例：\n\n```java\n/*\n            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\n            要求1:把字符串中三个姓名之间的字母替换为vs\n            要求2:把字符串中的三个姓名切割出来*/\n\nString s = \"小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\";\n//细节:\n//方法在底层跟之前一样也会创建文本解析器的对象\n//然后从头开始去读取字符串中的内容，只要有满足的，那么就切割。\nString[] arr = s.split(\"[\\\\w&&[^_]]+\");\nfor (int i = 0; i < arr.length; i++) {\n    System.out.println(arr[i]);\n}\n```\n\n## 1.14 String类的replaceAll方法中使用正则表达式\n\n- String类的replaceAll()方法原型：\n\n```java\npublic String replaceAll(String regex,String newStr)\n//参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。\n```\n\n- 代码示例：\n\n```java\n/*\n            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\n            要求1:把字符串中三个姓名之间的字母替换为vs\n            要求2:把字符串中的三个姓名切割出来*/\n\nString s = \"小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\";\n//细节:\n//方法在底层跟之前一样也会创建文本解析器的对象\n//然后从头开始去读取字符串中的内容，只要有满足的，那么就用第一个参数去替换。\nString result1 = s.replaceAll(\"[\\\\w&&[^_]]+\", \"vs\");\nSystem.out.println(result1);\n```\n\n## 1.15 正则表达式-分组括号( )\n\n细节：如何识别组号？\n\n只看左括号，不看有括号，按照左括号的顺序，从左往右，依次为第一组，第二组，第三组等等\n\n```java\n//需求1:判断一个字符串的开始字符和结束字符是否一致?只考虑一个字符\n//举例: a123a b456b 17891 &abc& a123b(false)\n// \\\\组号:表示把第X组的内容再出来用一次\nString regex1 = \"(.).+\\\\1\";\nSystem.out.println(\"a123a\".matches(regex1));\nSystem.out.println(\"b456b\".matches(regex1));\nSystem.out.println(\"17891\".matches(regex1));\nSystem.out.println(\"&abc&\".matches(regex1));\nSystem.out.println(\"a123b\".matches(regex1));\nSystem.out.println(\"--------------------------\");\n\n\n//需求2:判断一个字符串的开始部分和结束部分是否一致?可以有多个字符\n//举例: abc123abc b456b 123789123 &!@abc&!@ abc123abd(false)\nString regex2 = \"(.+).+\\\\1\";\nSystem.out.println(\"abc123abc\".matches(regex2));\nSystem.out.println(\"b456b\".matches(regex2));\nSystem.out.println(\"123789123\".matches(regex2));\nSystem.out.println(\"&!@abc&!@\".matches(regex2));\nSystem.out.println(\"abc123abd\".matches(regex2));\nSystem.out.println(\"---------------------\");\n\n//需求3:判断一个字符串的开始部分和结束部分是否一致?开始部分内部每个字符也需要一致\n//举例: aaa123aaa bbb456bbb 111789111 &&abc&&\n//(.):把首字母看做一组\n// \\\\2:把首字母拿出来再次使用\n// *:作用于\\\\2,表示后面重复的内容出现日次或多次\nString regex3 = \"((.)\\\\2*).+\\\\1\";\nSystem.out.println(\"aaa123aaa\".matches(regex3));\nSystem.out.println(\"bbb456bbb\".matches(regex3));\nSystem.out.println(\"111789111\".matches(regex3));\nSystem.out.println(\"&&abc&&\".matches(regex3));\nSystem.out.println(\"aaa123aab\".matches(regex3));\n```\n\n## 1.16 分组练习\n\n需求:\n\n​    将字符串：我要学学编编编编程程程程程程。\n\n​    替换为：我要学编程\n\n```java\nString str = \"我要学学编编编编程程程程程程\";\n\n//需求:把重复的内容 替换为 单个的\n//学学                学\n//编编编编            编\n//程程程程程程        程\n//  (.)表示把重复内容的第一个字符看做一组\n//  \\\\1表示第一字符再次出现\n//  + 至少一次\n//  $1 表示把正则表达式中第一组的内容，再拿出来用\nString result = str.replaceAll(\"(.)\\\\1+\", \"$1\");\nSystem.out.println(result);\n```\n\n## 1.17 忽略大小写的写法\n\n```java\n//(?i) ：表示忽略后面数据的大小写\n//忽略abc的大小写\nString regex = \"(?i)abc\";\n//a需要一模一样，忽略bc的大小写\nString regex = \"a(?i)bc\";\n//ac需要一模一样，忽略b的大小写\nString regex = \"a((?i)b)c\";\n```\n\n## 1.18 非捕获分组\n\n非捕获分组：分组之后不需要再用本组数据，仅仅是把数据括起来。\n\n```java\n//身份证号码的简易正则表达式\n//非捕获分组:仅仅是把数据括起来\n//特点:不占用组号\n//这里\\\\1报错原因:(?:)就是非捕获分组，此时是不占用组号的。\n\n\n//(?:) (?=) (?!)都是非捕获分组//更多的使用第一个\n//String regex1 =\"[1-9]\\\\d{16}(?:\\\\d|x|x)\\\\1\";\nString regex2 =\"[1-9]\\\\d{16}(\\\\d Xx)\\\\1\";\n//^([01]\\d|2[0-3]):[0-5]\\d:[@-5]\\d$\n\nSystem.out.println(\"41080119930228457x\".matches(regex2));\n```\n\n## 1.19 正则表达式练习\n\n```java\n手机号码:1[3-9]\\\\d{9}\n座机号码：0\\\\d{2,3}-?[1-9]\\\\d{4,9}\n邮箱号码：\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2}\n24小时：([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\n\t   ([01]\\\\d|2[0-3])(:[0-5]\\\\d){2}\n用户名:\t\\\\w{4,16}\n身份证号码，简单校验：\n\t\t[1-9]\\\\d{16}(\\\\d|X|x)\n\t\t[1-9]\\\\d{16}[\\\\dXx]\n\t\t[1-9]\\\\d{16}(\\\\d(?i)X)\n身份证号码，严格校验：\n\t\t[1-9]\\\\d{5}(18|19|20)\\\\d{2}(0[1-9]|1[0-2])(0[1-9|[12])\\\\d|3[01])\\\\d{3}[\\\\dXx]\n```\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"String","url":"/2023/01/20/常用API/","content":"## 1.API\n\n### 1.1API概述\n\n- 什么是API\n\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\n\n- java中的API\n\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\n\n### 1.2如何使用API帮助文档\n\n- 打开帮助文档\n\n![01](img\\01.png)\n\n- 找到索引选项卡中的输入框\n\n![02](img\\02.png)\n\n- 在输入框中输入Random\n\n![03](img\\03.png)\n\n- 看类在哪个包下\n\n![04](img\\04.png)\n\n- 看类的描述\n\n![05](img\\05.png)\n\n- 看构造方法\n\n![06](img\\06.png)\n\n- 看成员方法\n\n![07](img\\07.png)\n\n## 2.String类\n\n### 2.1String类概述\n\n​\tString 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！\n\n### 2.2String类的特点\n\n- 字符串不可变，它们的值在创建后不能被更改\n- 虽然 String 的值是不可变的，但是它们可以被共享\n- 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )\n\n### 2.3String类的构造方法\n\n- 常用的构造方法\n\n  | 方法名                      | 说明                                      |\n  | --------------------------- | ----------------------------------------- |\n  | public   String()           | 创建一个空白字符串对象，不含有任何内容    |\n  | public   String(char[] chs) | 根据字符数组的内容，来创建字符串对象      |\n  | public   String(byte[] bys) | 根据字节数组的内容，来创建字符串对象      |\n  | String s =   “abc”;         | 直接赋值的方式创建字符串对象，内容就是abc |\n\n- 示例代码\n\n  ```java\n  public class StringDemo01 {\n      public static void main(String[] args) {\n          //public String()：创建一个空白字符串对象，不含有任何内容\n          String s1 = new String();\n          System.out.println(\"s1:\" + s1);\n  \n          //public String(char[] chs)：根据字符数组的内容，来创建字符串对象\n          char[] chs = {'a', 'b', 'c'};\n          String s2 = new String(chs);\n          System.out.println(\"s2:\" + s2);\n  \n          //public String(byte[] bys)：根据字节数组的内容，来创建字符串对象\n          byte[] bys = {97, 98, 99};\n          String s3 = new String(bys);\n          System.out.println(\"s3:\" + s3);\n  \n          //String s = “abc”;\t直接赋值的方式创建字符串对象，内容就是abc\n          String s4 = \"abc\";\n          System.out.println(\"s4:\" + s4);\n      }\n  }\n  ```\n\n### 2.4创建字符串对象两种方式的区别\n\n- 通过构造方法创建\n\n  ​\t通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\n\n- 直接赋值方式创建\n\n  ​\t以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护\n\n### 2.5字符串的比较\n\n#### 2.5.1==号的作用\n\n- 比较基本数据类型：比较的是具体的值\n- 比较引用数据类型：比较的是对象地址值\n\n#### 2.5.2equals方法的作用\n\n- 方法介绍\n\n  ```java\n  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写\n  ```\n\n- 示例代码\n\n  ```java\n  public class StringDemo02 {\n      public static void main(String[] args) {\n          //构造方法的方式得到对象\n          char[] chs = {'a', 'b', 'c'};\n          String s1 = new String(chs);\n          String s2 = new String(chs);\n  \n          //直接赋值的方式得到对象\n          String s3 = \"abc\";\n          String s4 = \"abc\";\n  \n          //比较字符串对象地址是否相同\n          System.out.println(s1 == s2);\n          System.out.println(s1 == s3);\n          System.out.println(s3 == s4);\n          System.out.println(\"--------\");\n  \n          //比较字符串内容是否相同\n          System.out.println(s1.equals(s2));\n          System.out.println(s1.equals(s3));\n          System.out.println(s3.equals(s4));\n      }\n  }\n  ```\n\n### 2.6用户登录案例\n\n#### 2.6.1案例需求\n\n​\t已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示\n\n#### 2.6.2代码实现\n\n```java\npublic class Test1登录案例 {\n    public static void main(String[] args) {\n        //1.定义两个变量用来记录正确的用户名和密码\n        String rightUsername = \"itheima\";\n        String rightPassword = \"1234qwer\";\n\n        //2.键盘录入用户名和密码\n        //ctrl + alt + T 选择包裹方式\n\n        for (int i = 0; i < 3; i++) {//0 1 2\n            Scanner sc = new Scanner(System.in);\n            System.out.println(\"请输入用户名\");\n            String username = sc.next();\n            System.out.println(\"请输入密码\");\n            String password = sc.next();\n\n            //3.判断比较\n            if (username.equals(rightUsername) && password.equals(rightPassword)) {\n                System.out.println(\"登录成功\");\n                //如果正确，循环结束\n                break;\n            } else {\n                //最后一次机会\n                if(i == 2){\n                    System.out.println(\"账户\" + username + \"被锁定，请联系黑马程序员官方小姐姐：XXXXXXX\");\n                }else{\n                    //不是最后一次机会\n                    System.out.println(\"用户名或密码错误，登录失败,还剩下\" + (2 - i) + \"次机会\");//2 1 0\n                }\n            }\n        }\n\n    }\n}\n\n```\n\n### 2.7遍历字符串案例\n\n#### 2.7.1案例需求\n\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\n\n#### 2.7.2直接遍历字符串\n\n```java\npublic class Test2字符串直接遍历 {\n    public static void main(String[] args) {\n        //两个方法：\n        //charAt()：会根据索引获取对应的字符\n        //length(): 会返回字符串的长度\n\n\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入字符串\");\n        String str = sc.next();\n        System.out.println(str);\n\n        //2.遍历\n        for (int i = 0; i < str.length(); i++) {\n            //i 依次表示字符串的每一个索引\n            //索引的范围：0 ~  长度-1\n\n            //根据索引获取字符串里面的每一个字符\n            //ctrl + alt + V 自动生成左边的接受变量\n            char c = str.charAt(i);\n            System.out.println(c);\n        }\n    }\n}\n\n```\n\n### 2.8统计字符次数案例\n\n#### 2.8.1案例需求\n\n​\t键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)\n\n#### 2.8.2代码实现\n\n```java\npublic class Test4统计个数 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，统计大写，小写，数字出现的次数\n\n\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串\");\n        String str = sc.next();\n\n\n        //2.统计 --- 计数器count\n        //此时我要统计的有3样东西，所以要定义3个计数器分别进行统计\n        int bigCount = 0;\n        int smallCount = 0;\n        int numberCount = 0;\n        //得到这个字符串里面每一个字符\n        for (int i = 0; i < str.length(); i++) {\n            //i 表示字符串中的索引\n            //c 表示字符串中的每一个字符\n            char c = str.charAt(i);\n\n            //对c进行判断\n            if (c >= 'a' && c <= 'z') {\n                smallCount++;\n            }else if(c >= 'A' && c <= 'Z'){\n                bigCount++;\n            }else if(c >= '0' && c <= '9'){\n                numberCount++;\n            }\n        }\n\n        //3.当循环结束之后，三个变量记录的就是对应的个数\n        System.out.println(\"大写字符有:\" + bigCount + \"个\");\n        System.out.println(\"小写字符有:\" + smallCount + \"个\");\n        System.out.println(\"数字字符有:\" + numberCount + \"个\");\n    }\n}\n\n```\n\n### 2.9字符串拼接案例\n\n#### 2.9.1案例需求\n\n​\t定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n\n​\t并在控制台输出结果。例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n#### 2.9.2代码实现\n\n```java\npublic class Test5数组拼接成字符串 {\n    public static void main(String[] args) {\n        //定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n        //并在控制台输出结果。例如，数组为 int[] arr = {1,2,3};\n        //执行方法后的输出结果为：[1, 2, 3]\n\n\n        int[] arr = {1, 2, 3, 4, 5};\n\n        String str = arrToString(arr);\n        System.out.println(str);\n\n    }\n\n\n    //作用：把一个数组变成字符串\n    public static String arrToString(int[] arr) {\n        String s = \"\";\n        //拼接左括号\n        s = s + \"[\"; //此时是拿着长度为0的字符串，跟[进行拼接，产生一个新的字符串。\n        //把新的字符串再赋值给s，此时变量s记录的就是新的字符串\"[\"的地址值\n\n        //下面我想得到数组里面的每一个元素并进行拼接\n        //那么就需要遍历数组，得到每一个元素才行\n        for (int i = 0; i < arr.length; i++) {\n            //假设第一次循环:i = 0 获取的就是0索引上的元素\n            //在拼接的时候：\"[\" + 1 + \", \" 拼接完毕之后产生一个新的字符串 \"[1, \"\n            //第二次循环：i = 1 获取的就是1索引上的元素\n            //在拼接的时候： 此时s就是第一次循环结束后拼接完毕的结果：\"[1, \"\n            //在拼接的时候：\"[1, \" + 2 + \", \" 拼接完毕之后产生一个新的字符串 \"[1, 2, \"\n            //...\n           if(i == arr.length - 1){\n               //如果是最后一个元素，那么不需要拼接逗号空格\n               s = s + arr[i];\n           }else{\n               //如果不是最后一个元素，需要拼接元素和逗号空格\n               s = s + arr[i] + \", \";\n           }\n        }\n\n        //等循环结束之后，再拼接最后一个右括号\n        s = s + \"]\";\n\n        return s;\n\n    }\n\n\n    //用来遍历数组\n    public static void printArr(int[] arr) {\n        System.out.print(\"[\");\n        for (int i = 0; i < arr.length; i++) {\n            if (i == arr.length - 1) {\n                System.out.print(arr[i]);\n            } else {\n                System.out.print(arr[i] + \", \");\n            }\n        }\n        System.out.println(\"]\");\n\n        //[1, 2, 3, 4, 5]\n        //我们现在要知道，这个最终结果是怎么来的？\n        //从到右依次打印得来的。\n    }\n}\n\n```\n\n### 2.10字符串反转案例\n\n#### 2.10.1案例需求\n\n​\t定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n\n​\t例如，键盘录入 abc，输出结果 cba\n\n#### 2.10.2代码实现\n\n```java\npublic class Test6反转字符串 {\n    public static void main(String[] args) {\n        /*定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n        例如，键盘录入 abc，输出结果 cba*/\n\n\n\n        //1.定义一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串\");\n        String str = sc.next();\n        //2.定义一个方法，反转字符串\n        //abc  --->  cba\n        //可以把字符串倒着遍历，再拼接\n        String result = reverse(str);\n        System.out.println(result);\n\n\n    }\n\n    //注释：方法的作用就是反转字符串\n    //把传递进来的字符串进行反转\n    public static String reverse(String str){//abc\n        //核心思想：倒着遍历并进行拼接就可以了\n        //fori :正着遍历  forr：倒着遍历\n        String s = \"\";\n        for (int i = str.length() - 1; i >= 0; i--) {\n            //i 依次表示字符串里面的每一个索引（倒着的）\n            //我们就可以拿到里面的每一个字符并拼接\n            s = s + str.charAt(i);\n        }\n\n        //把倒着拼接之后的结果返回即可\n        return s;\n\n    }\n}\n\n```\n\n### 2.11 金额转换\n\n#### 2.11.1 案例需求\n\n​\t把2135变成：零佰零拾零万贰仟壹佰叁拾伍元 \n\n​\t把789变成：零佰零拾零万零仟柒佰捌拾玖元\n\n#### 2.11.2 代码实现\n\n```java\npackage com.itheima.stringdemo;\n\nimport java.util.Scanner;\n\npublic class StringDemo9 {\n    public static void main(String[] args) {\n        //1.键盘录入一个金额\n        Scanner sc = new Scanner(System.in);\n        int money;\n        while (true) {\n            System.out.println(\"请录入一个金额\");\n            money = sc.nextInt();\n            if (money >= 0 && money <= 9999999) {\n                break;\n            } else {\n                System.out.println(\"金额无效\");\n            }\n        }\n\n        //定义一个变量用来表示钱的大写\n        String moneyStr = \"\";\n\n        //2.得到money里面的每一位数字,再转成中文\n        while (true) {//2135\n            //从右往左获取数据，因为右侧是数据的个位\n            int ge = money % 10;\n            String capitalNumber = getCapitalNumber(ge);\n            //把转换之后的大写拼接到moneyStr当中\n            moneyStr = capitalNumber + moneyStr;\n            //第一次循环 ： \"伍\" + \"\" = \"伍\"\n            //第二次循环 ： \"叁\" + \"伍\" = \"叁伍\"\n            //去掉刚刚获取的数据\n            money = money / 10;\n\n            //如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束\n            if (money == 0) {\n                break;\n            }\n        }\n\n        //3.在前面补0，补齐7位\n        int count = 7 - moneyStr.length();\n        for (int i = 0; i < count; i++) {\n            moneyStr = \"零\" + moneyStr;\n        }\n        System.out.println(moneyStr);//零零零贰壹叁伍\n\n        //4.插入单位\n        //定义一个数组表示单位\n        String[] arr = {\"佰\",\"拾\",\"万\",\"仟\",\"佰\",\"拾\",\"元\"};\n        //               零    零   零   贰   壹   叁   伍\n\n        //遍历moneyStr，依次得到 零    零   零   贰   壹   叁   伍\n        //然后把arr的单位插入进去\n\n        String result = \"\";\n        for (int i = 0; i < moneyStr.length(); i++) {\n            char c = moneyStr.charAt(i);\n            //把大写数字和单位拼接到result当中\n            result = result + c + arr[i];\n        }\n\n        //5.打印最终结果\n        System.out.println(result);\n\n    }\n\n\n    //定义一个方法把数字变成大写的中文\n    //1 -- 壹\n    public static String getCapitalNumber(int number) {\n        //定义数组，让数字跟大写的中文产生一个对应关系\n        String[] arr = {\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"};\n        //返回结果\n        return arr[number];\n    }\n\n}\n\n```\n\n### 2.12 手机号屏蔽\n\n需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\n\n最终效果为：`131****9468`\n\n代码实现：\n\n```java\npublic class Test8手机号屏蔽 {\n    public static void main(String[] args) {\n        /*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\n        最终效果为：131****9468*/\n\n        //1.键盘录入一个手机号码\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入手机号码\");\n        String phoneNumber = sc.next();//13112349408\n\n        //2.截取手机号码中的前三位\n        String star = phoneNumber.substring(0, 3);\n\n        //3.截取手机号码中的最后四位\n        //此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好\n        //因为现在我要截取到最后，所以建议使用1个参数的。\n        String end = phoneNumber.substring(7);\n\n        //4.拼接\n        String result = star + \"****\" + end;\n\n        System.out.println(result);\n\n    }\n}\n\n```\n\n### 2.13 敏感词替换 \n\n需求1：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 \n\n```java\npublic class Test9敏感词替换 {\n    public static void main(String[] args) {\n        //1.定义一个变量表示骂人的话\n        String talk = \"后裔你玩什么啊，TMD\";\n\n\n        //2.把这句话中的敏感词进行替换\n        String result = talk.replace(\"TMD\", \"***\");\n\n        //3.打印\n        System.out.println(talk);\n        System.out.println(result);\n    }\n}\n\n```\n\n需求2：如果要替换的敏感词比较多怎么办？\n\n```java\npublic class Test10多个敏感词替换 {\n    public static void main(String[] args) {\n        //实际开发中，敏感词会有很多很多\n\n        //1.先键盘录入要说的话\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入要说的话\");\n        String talk = sc.next();//后裔你玩什么啊，TMD,GDX,ctmd,ZZ\n\n        //2.定义一个数组用来存多个敏感词\n        String[] arr = {\"TMD\",\"GDX\",\"ctmd\",\"ZZ\",\"lj\",\"FW\",\"nt\"};\n\n        //3.把说的话中所有的敏感词都替换为***\n\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引\n            //arr[i] 元素 --- 敏感词\n            talk = talk.replace(arr[i],\"***\");\n        }\n\n        //4.打印结果\n        System.out.println(talk);//后裔你玩什么啊，***,***,***,***\n\n    }\n}\n\n```\n\n### 2.14 身份证信息查看\n\n​\t身份证的每一位都是有固定的含义：\n\n* 1、2位：省份 \n* 3、4位：城市 \n* 5、6位：区县 \n* 7-14位：出生年、月、日 \n* 15、16位：所在地派出所 \n* 17位：性别（奇数男性，偶数女性）\n* 18位：个人信息码（随机产生） \n\n要求打印内容方式如下：\n\n​\t人物信息为：\n\n​\t出生年月日：XXXX年X月X日\n\n​\t性别为：男/女\n\n```java\npackage com.itheima.stringdemo;\n\npublic class StringDemo11 {\n    public static void main(String[] args) {\n        //1.定义一个字符串记录身份证号码\n        String id = \"321281202001011234\";\n\n        //2.获取出生年月日\n        String year = id.substring(6, 10);\n        String month = id.substring(10, 12);\n        String day = id.substring(12, 14);\n\n\n        System.out.println(\"人物信息为：\");\n        System.out.println(\"出生年月日:\" + year + \"年\" + month + \"月\" + day + \"日\");\n\n        //3.获取性别\n        char gender = id.charAt(16);//'3'  ---> 3\n        //利用ASCII码表进行转换\n        //'0' --->  48\n        //'1' --->  49\n        //'2' --->  50\n        //'3' --->  51\n        //'4' --->  52\n        //'5' --->  53\n        //'6' --->  54\n        //'7' --->  55\n        //'8' --->  56\n        //'9' --->  57\n\n       int num = gender - 48;\n        if(num % 2 == 0){\n            System.out.println(\"性别为:女\");\n        }else{\n            System.out.println(\"性别为:男\");\n        }\n    }\n}\n```\n\n## 3.StringBuilder\n\nStringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。\n\n当我们在拼接字符串和反转字符串的时候会使用到\n\n### 3.1 基本使用\n\n```java\npublic class StringBuilderDemo3 {\n    public static void main(String[] args) {\n        //1.创建对象\n        StringBuilder sb = new StringBuilder(\"abc\");\n\n        //2.添加元素\n        /*sb.append(1);\n        sb.append(2.3);\n        sb.append(true);*/\n\n        //反转\n        sb.reverse();\n\n        //获取长度\n        int len = sb.length();\n        System.out.println(len);\n\n\n        //打印\n        //普及：\n        //因为StringBuilder是Java已经写好的类\n        //java在底层对他做了一些特殊处理。\n        //打印对象不是地址值而是属性值。\n        System.out.println(sb);\n    }\n}\n```\n\n### 3.2 链式编程\n\n```java\npublic class StringBuilderDemo4 {\n    public static void main(String[] args) {\n        //1.创建对象\n        StringBuilder sb = new StringBuilder();\n\n        //2.添加字符串\n        sb.append(\"aaa\").append(\"bbb\").append(\"ccc\").append(\"ddd\");\n\n        System.out.println(sb);//aaabbbcccddd\n\n        //3.再把StringBuilder变回字符串\n        String str = sb.toString();\n        System.out.println(str);//aaabbbcccddd\n\n    }\n}\n```\n\n### 3.3 练习1：对称字符串 \n\n需求：\n\n​\t键盘接受一个字符串，程序判断出该字符串是否是对称字符串，并在控制台打印是或不是\n\n  \t对称字符串：123321、111\n  \t\n  \t非对称字符串：123123\n\n代码示例：\n\n```java\npublic class StringBuilderDemo6 {\n    //使用StringBuilder的场景：\n    //1.字符串的拼接\n    //2.字符串的反转\n\n    public static void main(String[] args) {\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串\");\n        String str = sc.next();\n\n        //2.反转键盘录入的字符串\n        String result = new StringBuilder().append(str).reverse().toString();\n\n        //3.比较\n        if(str.equals(result)){\n            System.out.println(\"当前字符串是对称字符串\");\n        }else{\n            System.out.println(\"当前字符串不是对称字符串\");\n        }\n\n    }\n}\n\n```\n\n\n\n### 3.4 练习2：拼接字符串 \n\n需求：定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回。\n\n​          调用该方法，并在控制台输出结果。\n\n​          例如：数组为int[] arr = {1,2,3}; \n\n​          执行方法后的输出结果为：[1, 2, 3]\n\n代码示例:\n\n```java\npackage com.itheima.stringbuilderdemo;\n\npublic class StringBuilderDemo7 {\n    public static void main(String[] args) {\n        //1.定义数组\n        int[] arr = {1,2,3};\n\n        //2.调用方法把数组变成字符串\n        String str = arrToString(arr);\n\n        System.out.println(str);\n\n    }\n\n\n    public static String arrToString(int[] arr){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n\n        for (int i = 0; i < arr.length; i++) {\n            if(i == arr.length - 1){\n                sb.append(arr[i]);\n            }else{\n                sb.append(arr[i]).append(\", \");\n            }\n        }\n        sb.append(\"]\");\n\n        return sb.toString();\n    }\n}\n\n```\n\n## 4. StringJoiner\n\n* StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。\n* 作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。 \n* JDK8出现的\n\n基本使用：\n\n```java\n//1.创建一个对象，并指定中间的间隔符号\nStringJoiner sj = new StringJoiner(\"---\");\n//2.添加元素\nsj.add(\"aaa\").add(\"bbb\").add(\"ccc\");\n//3.打印结果\nSystem.out.println(sj);//aaa---bbb---ccc\n```\n\n```java\n//1.创建对象\nStringJoiner sj = new StringJoiner(\", \",\"[\",\"]\");\n//2.添加元素\nsj.add(\"aaa\").add(\"bbb\").add(\"ccc\");\nint len = sj.length();\nSystem.out.println(len);//15\n//3.打印\nSystem.out.println(sj);//[aaa, bbb, ccc]\nString str = sj.toString();\nSystem.out.println(str);//[aaa, bbb, ccc]\n```\n\n## 关于字符串的小扩展：\n\n1. 字符串存储的内存原理\n\n   String s = “abc”；直接赋值\n\n   特点：\n\n   ​\t此时字符串abc是存在字符串常量池中的。\n\n   ​\t先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。\n\n   所以，直接赋值的方式，代码简单，而且节约内存。\n\n2. new出来的字符串\n\n   看到new关键字，一定是在堆里面开辟了一个小空间。\n\n   String s1 = new String（“abc”）；\n\n   String s2 = “abc”；\n\n   s1记录的是new出来的，在堆里面的地址值。\n\n   s2是直接赋值的，所以记录的是字符串常量池中的地址值。\n\n3. ==号比较的到底是什么？\n\n   如果比较的是基本数据类型：比的是具体的数值是否相等。\n\n   如果比较的是引用数据类型：比的是地址值是否相等。\n\n   结论：==只能用于比较基本数据类型。不能比较引用数据类型。\n\n\n\n\n\n\n\n\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"循环高级","url":"/2023/01/20/循环高级/","content":"## 1.无限循环\n\n### 概念：\n\n​\t又叫死循环。循环一直停不下来。\n\n### for格式：\n\n```java\nfor(;;){\n    System.out.println(\"循环执行一直在打印内容\");\n}\n```\n\n解释：\n\n初始化语句可以空着不写，表示循环之前不定义任何的控制变量。\n\n条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。\n\n条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。\n\n### while格式：\n\n```java\nwhile(true){\n    System.out.println(\"循环执行一直在打印内容\");\n}\n```\n\n解释：\n\n​\t小括号里面就不能省略了，true一定要写出来，否则代码会报错。\n\n### do...while格式：\n\n```java\ndo{\n    System.out.println(\"循环执行一直在打印内容\");\n}while(true);\n```\n\n解释：\n\n​\t小括号里面就不能省略了，true一定要写出来，否则代码会报错。\n\n### 无限循环的注意事项：\n\n* 最为常用的格式：while\n* 无限循环下面不能再写其他代码了，因为永远执行不到。\n\n## 2.条件控制语句\n\n* break\n* continue\n\n### break:\n\n​\t不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。\n\n代码示例：\n\n```java\n//1.吃1~5号包子\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(\"在吃第\" + i + \"个包子\");\n    //2.吃完第三个的时候就不吃了\n    if(i == 3){\n        break;//结束整个循环。\n    }\n}\n```\n\n### continue:\n\n​\t不能单独存在的。只能存在于循环当中。\n\n​\t表示：跳过本次循环，继续执行下次循环。\n\n代码示例：\n\n```java\n//1.吃1~5号包子\nfor (int i = 1; i <= 5; i++) {\n    //2.第3个包子有虫子就跳过，继续吃下面的包子\n    if(i == 3){\n        //跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。\n        continue;\n    }\n    System.out.println(\"在吃第\" + i + \"个包子\");\n}\n```\n\n## 3. Random\n\nRandom跟Scanner一样，也是Java提前写好的类，我们不需要关心是如何实现的，只要直接使用就可以了。\n\n### 使用步骤：\n\n1. 导包\n\n```java\nimport java.util.Random;\n导包的动作必须出现在类定义的上边。\n```\n\n2. 创建对象\n\n```java\nRandom r = new Random ();\n上面这个格式里面，只有r是变量名，可以变，其他的都不允许变。\n```\n\n3. 生成随机数\n\n```java\nint number = r.nextInt(随机数的范围);\n上面这个格式里面，只有number是变量名，可以变，其他的都不允许变。\n随机数范围的特点：从0开始，不包含指定值。比如：参数为10，生成的范围[0,10)\n```\n\n代码示例：\n\n```java\n//1.导包\nimport java.util.Random;\n\npublic class RandomDemo1 {\n    public static void main(String[] args) {\n        //2.创建对象\n        Random r = new Random();\n        //3.生成随机数\n        int number = r.nextInt(100);//包左不包右，包头不包尾\n        //0 ~ 99\n        System.out.println(number);\n\n    }\n}\n```\n\n## 4. 逢七过\n\n需求：\n\n​\t朋友聚会的时候可能会玩一个游戏：逢7过 \n\n​\t游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过\n\n​\t使用程序在控制台打印出1-100之间的满足逢七必过规则的数据 \n\n举例：\n\n​\t1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 ...\n\n代码示例：\n\n```java\n/*朋友聚会的时候可能会玩一个游戏：逢7过\n        游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过\n        需求：使用程序在控制台打印出1-100之间的满足逢七必过规则的数据*/\n//分析：\n//个位7  十位7   7倍数\n//1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 19 20 过....\n//69 过 过 过 过 过 过... 80\n//1.得到1~100之间的每一个数字\n//开始：1\n//结束：100\nfor (int i = 1; i <= 100; i++) {\n    //2.判断每一个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字\n    if(i % 10 == 7 || i / 10 % 10 == 7  ||  i % 7 == 0){\n        System.out.println(\"过\");\n        continue;\n    }\n    System.out.println(i);\n}\n```\n\n## 5. 平方根\n\n需求：\n\n​\t键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。结果只保留整数部分 ，小数部分将被舍去 。\n\n代码示例：\n\n```java\n/*需求：键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。\n        结果只保留整数部分 ，小数部分将被舍去 。*/\n\n\n//分析：\n//平方根   16的平方根4\n//         4的平方根2\n\n\n// 10\n// 1 * 1 = 1 < 10\n// 2 * 2 = 4 < 10\n// 3 * 3 = 9 < 10\n// 4 * 4 = 16 > 10\n//推断：10的平方根是在3~4之间。\n\n\n// 20\n// 1 * 1 = 1 < 20\n// 2 * 2 = 4 < 20\n// 3 * 3 = 9 < 20\n// 4 * 4 = 16 < 20\n// 5 * 5 = 25 > 20\n//推断：20的平方根是在4~5之间。\n\n\n//在代码当中\n//从1开始循环，拿着数字的平方跟原来的数字进行比较\n//如果小于的，那么继续往后判断\n//如果相等，那么当前数字就是平方根\n//如果大于的，那么前一个数字就是平方跟的整数部分\n\n\n//1.键盘录入一个整数\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"请输入一个整数\");\nint number = sc.nextInt();\n//2.从1开始循环判断\n//开始：1 结束: number\nfor (int i = 1; i <= number; i++) {\n    //用i * i 再跟number进行比较\n    if(i * i == number){\n        System.out.println(i + \"就是\" + number + \"的平方根\");\n        //一旦找到了，循环就可以停止了，后面的数字就不需要再找了，提高代码的运行效率。\n        break;\n    }else if(i * i > number){\n        System.out.println((i - 1) + \"就是\" + number + \"平方根的整数部分\");\n        break;\n    }\n}\n```\n\n## 6.判断是否为质数\n\n需求：\n\n​\t键盘录入一个正整数 x ，判断该整数是否为一个质数。 \n\n代码示例：\n\n```java\n//需求：键盘录入一个正整数 x ，判断该整数是否为一个质数。\n\n//质数：\n//如果一个整数只能被1和本身整除，那么这个数就是质数。否则这个数叫做合数\n//7 = 1 * 7 质数\n//8 = 1 * 8  2 * 4 合数\n\n\n//分析：\n//1.键盘录入一个正整数\n//number\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"请输入一个正整数\");\nint number = sc.nextInt();//9\n\n//定义一个变量，表示标记\n//标记着number是否为一个质数\n//true： 是一个质数\n//false : 不是一个质数\n\n//表示最初就认为number是一个质数\nboolean flag = true;\n\n\n//2.判断\n//写一个循环，从2开始判断，一直判断到number-1为止\n//看这个范围之内，有没有数字可以被number整除\nfor (int i = 2; i < number; i++) {\n    //i 依次表示这个范围之内的每一个数字\n    //看number是否能被i整除就可以了\n    if(number % i == 0){// 9 % 2 = 1\n        flag = false;\n        //System.out.println(number + \"不是一个质数\");\n        break;\n    }/*else{\n                System.out.println(number + \"是一个质数\");\n            }*/\n}\n\n//只有当这个循环结束了，表示这个范围之内所有的数字都判断完毕了\n//此时才能断定number是一个质数\nif(flag){\n    System.out.println(number + \"是一个质数\");\n}else{\n    System.out.println(number + \"不是一个质数\");\n}\n```\n\n## 7. 猜数字小游戏\n\n需求：\n\n​\t程序自动生成一个1-100之间的随机数，在代码中使用键盘录入去猜出这个数字是多少？\n\n要求：\n\n​\t使用循环猜，一直猜中为止。\n\n思路分析：\n\n1. 生成一个1-100之间的随机数\n2. 使用键盘录入去猜出这个数字是多少\n3. 把反复猜的代码写在循环中\n\n代码示例：\n\n```java\n//1.生成一个1-100之间的随机数\nRandom r = new Random();\nint number = r.nextInt(100) + 1;// 0 ~ 99 + 1 --- 1 ~ 100\nSystem.out.println(number);\n\n//2.使用键盘录入去猜出这个数字是多少？\nScanner sc = new Scanner(System.in);\nwhile(true){\n    System.out.println(\"请输入一个整数\");\n    int guessNumber = sc.nextInt();\n    //3.比较\n    if(guessNumber > number){\n        System.out.println(\"您猜的数字大了\");\n    }else if(guessNumber < number){\n        System.out.println(\"您猜的数字小了\");\n    }else{\n        System.out.println(\"恭喜你，猜中了\");\n        break;\n    }\n}\n```\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"数组","url":"/2023/01/20/数组/","content":"# 1.数组\n\n### 概念：\n\n​\t指的是一种容器，可以同来存储同种数据类型的多个值。\n\n​\t但是数组容器在存储数据的时候，需要结合隐式转换考虑。\n\n比如：\n\n​\t定义了一个int类型的数组。那么boolean。double类型的数据是不能存到这个数组中的，\n\n​\t但是byte类型，short类型，int类型的数据是可以存到这个数组里面的。\n\n建议：\n\n​\t容器的类，和存储的数据类型保持一致。\n\n举例：\n\n​\t整数1 2 3 4 56 就可以使用int类型的数组来存储。\n\n​\t小数1.1 1.2 1.3 1.4 就可以使用double类型的数组来存储。\n\n​\t字符串\"aaa\"  \"bbb\"  \"ccc\" 就可以使用String类型的数组来存储。\n\n# 2.数组的定义\n\n### 格式一：\n\n​\t数据类型 [] 数组名\n\n比如：int [] array\n\n### 格式二：\n\n​\t数据类型  数组名 []\n\n比如： int array []\n\n### 详解：\n\n数据类型：限定了数组以后能存什么类型的数据。\n\n方括号：表示现在定义的是一个数组。\n\n数组名：就是一个名字而已，方便以后使用。\n\n### 注意点：\n\n​\t方法括号跟数组名，谁写在前面，谁写在后面都是一样的。\n\n​\t平时习惯性使用第一种方式。\n\n# 3.数组的静态初始化\n\n### 完整格式：\n\n​\t数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...};\n\n比如：\n\n​\tint[] arr = new int[]{11,22,33};\n\n​\tdouble[] arr = new double[]{1.1,1.2,1.3};\n\n### 格式详解：\n\n​\t数据类型：限定了数组以后能存什么类型的数据。\n\n​\t方括号：表示现在定义的是一个数组。\n\n​\t数组名：其实就是名字而已，方便以后使用，在起名字的时候遵循小驼峰命名法。\n\n​\t\t\tarr   namesArr\n\n​\tnew：就是给数组在内存中开辟了一个空间。\n\n​\t数据类型：限定了数组以后能存什么类型的数据。\n\n​\t\t\t  前面和后面的数据类型一定要保持一致。\n\n​\t\t\tint[] arr = new double[]{11,22,33};//错误写法\n\n​\t方括号：表示现在定义的是一个数组。\n\n​\t大括号：表示数组里面的元素。元素也就是存入到数组中的数据。\n\n​\t\t\t多个元素之间，一定要用逗号隔开。\n\n### 注意点：\n\n* 等号前后的数据类型必须保持一致。\n* 数组一旦创建之后，长度不能发生变化。\n\n### 简化格式:\n\n​\t数据类型[] 数组名 = {元素1，元素2，元素3，元素4...};\n\n比如：\n\n​\tint[] array = {1,2,3,4,5};\n\n​\tdouble[] array = {1.1,1.2,1.3};\n\n### 练习1：\n\n定义数组存储5个学生的年龄。\n\n```java\n1.给数组限定什么类型？ int\n2.利用静态初始化完成创建并添加元素\nint[] agesArr = new int[]{18,19,20,21,22};\nint[] agesArr = {18,19,20,21,22};\n```\n\n### 练习2：\n\n定义数组存储3个学生的姓名。\n\n```java\n1.给数组限定什么类型？ String\n2.利用静态初始化完成创建并添加元素\nString[] namesArr = new String[]{\"zhangsan\",\"lisi\",\"wangwu\"};\nString[] namesArr = {\"zhangsan\",\"lisi\",\"wangwu\"};\n```\n\n### 练习3：\n\n定义数组存储4个学生的身高。\n\n```java\n1.给数组限定什么类型？ double\n2.利用静态初始化完成创建并添加元素\ndouble[] heightsArr = new double[]{1.85,1.82,1.78,1.65};\ndouble[] heightsArr = {1.85,1.82,1.78,1.65};\n```\n\n# 4.地址值\n\n```java\nint[] arr = {1,2,3,4,5};\nSystem.out.println(arr);//[I@6d03e736\n\ndouble[] arr2 = {1.1,2.2,3.3};\nSystem.out.println(arr2);//[D@568db2f2\n```\n\n打印数组的时候，实际出现的是数组的地址值。\n\n数组的地址值：就表示数组在内存中的位置。\n\n以[I@6d03e736为例：\n\n[ ：表示现在打印的是一个数组。\n\nI：表示现在打印的数组是int类型的。\n\n@：仅仅是一个间隔符号而已。\n\n6d03e736：就是数组在内存中真正的地址值。（十六进制的）\n\n但是，我们习惯性会把[I@6d03e736这个整体称之为数组的地址值。\n\n地址值对于我们来京，作用不大，简单了解。\n\n# 5.数组元素访问\n\n### 格式：\n\n​\t数组名[索引];\n\n### 作用：\n\n* 获取数组中对应索引上的值\n\n* 修改数组中对应索引上的值\n\n  一旦修改之后，原来的值就会被覆盖了。\n\n### 代码示例：\n\n```java\npublic class ArrDemo2 {\n    /*\n\n        数组中元素访问的格式：\n                数组名[索引];\n\n         作用：\n            1.获取指定索引上对应的元素\n            2.修改指定索引上对应的元素\n\n\n    */\n    public static void main(String[] args) {\n       int[] arr = {1,2,3,4,5};\n       //需求1：获取arr数组中，3索引上的值\n        int number = arr[3];\n        System.out.println(number);\n        System.out.println(arr[3]);\n\n       //需求2：将arr数组中，3索引上的值修改为10\n            arr[3] = 10;\n        System.out.println(\"修改之后为:\" + arr[3]);\n\n    }\n}\n```\n\n# 6.索引\n\n​\t也叫角标、下标\n\n​\t就是数组容器中每一个小格子对应的编号。\n\n### 索引的特点：\n\n* 索引一定是从0开始的。\n* 连续不间断。\n* 逐个+1增长。\n\n# 7.数组的遍历\n\n遍历：就是把数组里面所有的内容一个一个全部取出来。\n\n数组的长度：数组名.length;\n\n通用代码：\n\n```java\nfor(int i = 0; i < arr.length; i++){\n    //在循环的过程中，i依次表示数组中的每一个索引\n    sout(arr[i]);//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。\n}\n```\n\n# 8.数组的动态初始化\n\n### 格式：\n\n​\t数据类型[] 数组名 = new 数据类型[数组的长度];\n\n### 举例：\n\n```java\n//1.定义一个数组，存3个人的年龄，年龄未知\nint[] agesArr = new int[3];\n\n\n//2.定义一个数组，存班级10名学生的考试成绩，考试成绩暂时未知，考完才知道。\nint[] scoresArr = new int[10];\n```\n\n### 数组的默认初始化值：\n\n整数类型：0\n\n小数类型：0.0\n\n布尔类型：false\n\n字符类型：'\\u0000'\n\n引用类型：null\n\n# 9.数组两种初始化方式的区别\n\n静态初始化：int[] arr = {1,2,3,4,5};\n\n动态初始化：int[] arr = new int[3];\n\n静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。\n\n动态初始化：手动指定数组长度，由系统给出默认初始化值。\n\n### 使用场景：\n\n只明确元素个数，但是不明确具体的数据，推荐使用动态初始化。\n\n已经明确了要操作的所有数据，推荐使用静态初始化。\n\n### 举例：\n\n* 使用数组来存储键盘录入的5个整数。\n\n  int[] arr = new int[5];\n\n* 将全班的学生成绩存入数组中，已知学生成绩为：66,77,88,99,100\n\n  int[] arr = new int[5];\n\n  arr[0] = 66;\n\n  arr[1] = 77;\n\n  ... 虽然可以实现，但是太麻烦了。\n\n  建议使用静态初始化：int[] arr = {66,77,88,99,100};\n\n# 10.数组常见问题\n\n当访问了数组中不存在的索引，就会引发索引越界异常。\n\n避免：\n\n​\t针对于任意一个数组，索引的范围：\n   \t最小索引：0\n   \t最大索引：数组的长度 - 1\n​           \t\t    数组名.length - 1\n\n```java\npublic class ArrDemo6 {\n    public static void main(String[] args) {\n       int[] arr = {1,2,3,4,5,5,5,5,5};\n        //用索引来访问数组中的元素\n        System.out.println(arr[1]);\n        System.out.println(arr[10]);//ArrayIndexOutOfBoundsException\n\n    }\n}\n```\n\n# 11.数组的练习\n\n## 练习1：求和\n\n需求：定义一个数组，存储1,2,3,4,5\n\n遍历数组得到每一个元素，求数组里面所有的数据和\n\n代码示例：\n\n```java\n/*定义一个数组，存储1,2,3,4,5\n        遍历数组得到每一个元素，求数组里面所有的数据和*/\n\n\n//分析：\n//1.定义一个数组，并添加数据1,2,3,4,5\nint[] arr = {1,2,3,4,5};\n\n//求和变量\nint sum = 0;\n//2.遍历数组得到每一个数据，累加求和\nfor (int i = 0; i < arr.length; i++) {\n    //i 依次表示数组里面的每一个索引\n    //arr[i] 依次表示数组里面的每一个元素\n    sum = sum + arr[i];\n}\n\n//当循环结束之后，sum的值就是累加之后的结果\nSystem.out.println(sum);\n```\n\n## 练习2：统计个数\n\n需求：定义一个数组，存储1,2,3,4,5,6,7,8,9,10\n\n遍历数组得到每一个元素，统计数组里面一共有多少个能被3整除的数字\n\n代码示例：\n\n```java\n//分析：\n//1.定义一个数组 存储1,2,3,4,5,6,7,8,9,10\nint[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n//定义一个变量，用来统计次数\nint count = 0;\n//2.遍历数组得到每一个元素\nfor (int i = 0; i < arr.length; i++) {\n    //i 表示数组里面的每一个索引\n    //arr[i] 表示数组里面的每一个元素\n    //3.判断当前的元素是否为3的倍数，如果是那么统计变量就需要自增一次。\n    if(arr[i] % 3 == 0){\n        // System.out.println(arr[i]);\n        count++;\n    }\n}\n//当循环结束之后，就表示数组里面所有的数字都判断完毕了，直接打印count即可\nSystem.out.println(\"数组中能被3整除的数字有\" + count + \"个\");\n```\n\n## 练习3：变化数据\n\n需求：\n\n定义一个数组，存储1,2,3,4,5,6,7,8,9,10\n\n遍历数组得到每一个元素。\n\n要求：\n\n1，如果是奇数，则将当前数字扩大两倍\n\n2，如果是偶数，则将当前数字变成二分之一\n\n代码示例：\n\n```java\n//分析：\n//1.定义一个数组，存1,2,3,4,5,6,7,8,9,10\nint[] arr = {1,2,3,4,5,6,7,8,9,10};\n//2.遍历数组得到每一个元素\nfor (int i = 0; i < arr.length; i++) {\n    //i 依次表示数组里面的每一个索引\n    //arr[i] 依次表示数组里面的每一个元素\n    //3.对每一个元素进行判断\n    if(arr[i] % 2 == 0){\n        //偶数 变成二分之一\n        arr[i] = arr[i] / 2;\n    }else{\n        //奇数 扩大两倍\n        arr[i] = arr[i] * 2;\n    }\n}\n\n//遍历数组\n//一个循环尽量只做一件事情。\nfor (int i = 0; i < arr.length; i++) {\n    System.out.println(arr[i]);\n}\n```\n\n## 练习4：求最值\n\n需求：求数组中的最大值\n\n代码示例：\n\n```java\n//定义数组求最大值：33,5,22,44,55\n\n//扩展问题：\n//1.根据求最大值的思路，自己改写一下求最小智\n//2.为什么max要记录为arr[0],默认值不能为0吗？\n//不能写0\n//max的初始化值一定要是数组中的值。\n//3.循环中开始条件一定是0吗？\n//循环的开始条件如果为0，那么第一次循环的时候是自己跟自己比了一下，对结果没有任何影响，但是效率偏低\n//为了提高效率，减少一次循环的次数，循环开始条件可以写1.\n\n\n//1.定义数组用来存储5个值\nint[] arr = {33,5,22,44,55};\n//2.定义一个变量max用来存储最大值\n//临时认为0索引的数据是最大的\nint max = arr[0];\n//3.循环获取数组中的每一个元素\n//拿着每一个元素跟max进行比较\nfor (int i = 1; i < arr.length; i++) {\n    //i 索引  arr[i] 元素\n    if(arr[i] > max){\n        max = arr[i];\n    }\n}\n//4.当循环结束之后，max记录的就是数组中的最大值\nSystem.out.println(max);//55\n```\n\n## 练习5：统计个数\n\n需求：生成10个1~100之间的随机数存入数组。\n\n1）求出所有数据的和\n\n2）求所有数据的平均数\n\n3）统计有多少个数据比平均值小\n\n代码示例：\n\n```java\n//分析：\n//1.定义数组\nint[] arr = new int[10];\n//2.把随机数存入到数组当中\nRandom r = new Random();\n\nfor (int i = 0; i < arr.length; i++) {\n    //每循环一次，就会生成一个新的随机数\n    int number = r.nextInt(100) + 1;\n    //把生成的随机数添加的数组当中\n    //数组名[索引] = 数据;\n    arr[i] = number;\n}\n\n\n// 1）求出所有数据的和\n//定义求和变量\nint sum = 0;\nfor (int i = 0; i < arr.length; i++) {\n    //循环得到每一个元素\n    //并把元素累加到sum当中\n    sum = sum + arr[i];\n}\nSystem.out.println(\"数组中所有数据的和为：\" + sum);\n\n\n//2）求所有数据的平均数\nint avg = sum / arr.length;\nSystem.out.println(\"数组中平均数为：\" + avg);\n\n\n\n//3）统计有多少个数据比平均值小\nint count = 0;\nfor (int i = 0; i < arr.length; i++) {\n    if(arr[i] < avg){\n        count++;\n    }\n}\n\n//当循环结束之后，就表示我已经找到了所有的比平均数小的数据\nSystem.out.println(\"在数组中，一共有\" + count + \"个数据，比平均数小\");\n\n\n\n//遍历数组，验证答案\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + \" \");\n}\n```\n\n## 练习6：交换数据\n\n需求：定义一个数组，存入1,2,3,4,5。按照要求交换索引对应的元素。\n\n交换前：1,2,3,4,5\n\n交换后：5,2,3,4,1\n\n代码示例：\n\n```java\n//1.定义数组存储数据\nint[] arr = {1,2,3,4,5};\n//2.利用循环去交换数据\nfor(int i = 0,j = arr.length - 1; i < j; i++,j--){\n    //交换变量i和变量j指向的元素\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n//当循环结束之后，那么数组中的数据就实现了头尾交换\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + \" \");\n}\n```\n\n## 练习7：打乱数据 \n\n需求：定义一个数组，存入1~5。要求打乱数组中所有数据的顺序。\n\n代码示例：\n\n```java\n//1.定义数组存储1~5\nint[] arr = {1, 2, 3, 4, 5};\n//2.循环遍历数组，从0索引开始打乱数据的顺序\nRandom r = new Random();\nfor (int i = 0; i < arr.length; i++) {\n    //生成一个随机索引\n    int randomIndex = r.nextInt(arr.length);\n    //拿着随机索引指向的元素 跟 i 指向的元素进行交换\n    int temp = arr[i];\n    arr[i] = arr[randomIndex];\n    arr[randomIndex] = temp;\n}\n//当循环结束之后，那么数组中所有的数据已经打乱顺序了\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + \" \");\n}\n```\n\n","tags":["Java","Java笔记"],"categories":["程序猿","Java基础"]},{"title":"番号","url":"/2023/01/20/番号/","content":"|   番号    |    演员    |                          图片                          | 类型 |  码  |\n| :-------: | :--------: | :----------------------------------------------------: | :--: | :--: |\n| gachi1151 |     蘭     | https://pic.imgdb.cn/item/63ca603fbe43e0d30eb8f859.png |      |  有  |\n| MDTM-013  | 铃原爱蜜莉 | https://pic.imgdb.cn/item/63ca603fbe43e0d30eb8f859.png |      |  有  |\n|           |            |                                                        |      |      |\n|           |            |                                                        |      |      |\n|           |            |                                                        |      |      |\n|           |            |                                                        |      |      |\n|           |            |                                                        |      |      |\n|           |            |                                                        |      |      |\n|           |            |                                                        |      |      |\n","tags":["番号"],"categories":["娱乐"]},{"title":"生活脚步_01","url":"/2023/01/20/生活脚步-01/","tags":["生活"],"categories":["生活"]},{"title":"正则表达式-day17","url":"/2023/01/20/学习总结-02/","content":"## 在Api文档中搜pattern获取规则信息\n## 字符类（只匹配一个字符）\n```java\n[abc] 只能是a,b,或c\n[^abc] 除了a,b,c之外的任何字符\n[a-zA-Z] a到zA到Z,包括（范围）\n[a-d[m-p]] a到d,或m到p\n[a-z&&[def]] a-z和def的交集。为：d,e,f\n[a-z&&[^bc] a-z和非bc的交集。（等同于[ad-z])\n[a-z&&[^m-p] a到z和除了m到p的交集。\n (等同于[a-lq-z])\n```\n\n## 预定义字符（只匹配一个字符）\n\n```java\n. 任何字符\n\\d 一个数字：[0-9]\n\\D 非数字：[^0-9]\n\\s 一个空白字符：[\\t\\n\\x0B\\f\\r]\n\\S 非空白字符：[^\\s]\n\\w [a-zA-Z_0-9]英文、数字、下划线\n\\W [^\\W]一个非单词字符\n```\n\n## 数量词\n\n```java\nX? X,一次或0次\nX* X,零次或多次\nX+ X,一次或多次\nXn} X,正好n次\nX{n,} X,至少n次\nX [n,m} X,至少n但不超过m次\n```\n\n\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]},{"title":"Object-day17","url":"/2023/01/20/学习总结_01/","content":"## Object\n1. Object是 Java 中的顶级父类。  \n         所有的类都直接或间接的继承于object类。\n2. `toString():`一般会重写，打印对象时打印属性  \n3. `equals():`比较对象时会重写，比较对象属性值是否相同  \n4. `c1one():`默认浅克隆。  \n       如果需要深克隆需要重写方法或者使用第三方工具类。\n## Objects  \n\n1. `Objects`是一个对象工具类，提供了一些操作对象的方法\n\n2. `equals(对象1 ，对象2)：`先做非空判断，比较两个对象\n\n3. `isNull(对象)`判断对象是否为空\n\n4. `nonNull(对象)`  判断对象是否不是空\n\n## BigInteger构造方法小结\n1. 如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。    \n2. 如果BigInteger表示的超出long的范围，可以用构造方法获取。\n3. 对象一旦创建，BigInteger内部记录的值不能发生改变。\n4. 只要进行计算都会产生一个新的BigIntegerx对象\n## BigDecimall\n### BigDecimall的作用是什么？\n * 表示较大的小数和解决小数运算精度失真问题。\n### BigDecimal的对象如何获取？\n * `BigDecimal bd1=new BigDecimal(\"较大的小数\")；`  \n * `BigDecimal bd2 BigDecimal.valueof(0.1);`\n### 常见操作\n * 加：`add`\n * 减：`subtract`\n * 乘：`multiply`\n * 除：`divide(四舍五入：RoundingMode,HALF UP)`\n\n","tags":["Java","Java个人总结"],"categories":["程序猿","Java基础"]}]